;;=======================================================================
;;=======================================================================
;; AUTHOR: Peter Vogt
;;
;; This file is part of the GTB software package.
;; GTB is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;; GTB is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;; GNU General Public License for more details.
;; You should have received a copy of the GNU General Public License
;; along with GTB.  If not, see <https://www.gnu.org/licenses/>.
;;
;; GTB is written in the IDL language, and you must be the legal owner of
;; an IDL licence to compile the IDL source code. Further information
;; on the IDL software can be found at: https://www.harrisgeospatial.com.
;; Alternative to using IDL, feel free to recode the IDL source code
;; to the programming language of your choice.
;;
;; GTB homepage: https://forest.jrc.ec.europa.eu/en/activities/lpa/gtb/
;;
;;=======================================================================
compile_opt idl2
;;=======================================================================
;; include required subroutines
@guidos_progs/canny
@guidos_progs/cgerrormsg 
@guidos_progs/cgprogressbar__define 
@guidos_progs/disp_png
@guidos_progs/entropy_mspainp
@guidos_progs/error_message
@guidos_progs/filter_image
@guidos_progs/find_boundary
@guidos_progs/fmdistg
@guidos_progs/get_CIparams
@guidos_progs/get_fad
@guidos_progs/get_fgobj
@guidos_progs/get_fos
@guidos_progs/get_kernel
@guidos_progs/get_lineres
@guidos_progs/get_locset
@guidos_progs/get_marker
@guidos_progs/get_MSPAparams
@guidos_progs/get_roires
@guidos_progs/get_xrecode
@guidos_progs/get_xset
@guidos_progs/laplace
@guidos_progs/roimask 
@guidos_progs/setdefaultvalue 
@guidos_progs/sharpen 
@guidos_progs/showprogress__define 
@guidos_progs/sigma_filter
@guidos_progs/tvimage
@guidos_progs/tvread 
@guidos_progs/xcontrast_roi
@guidos_progs/xmorph_roi
@guidos_progs/xthreshold_roi

PRO UNDEFINE, varname
  On_Error, 1
  IF N_Params() EQ 0 THEN $
    Message, 'One argument required in call to UNDEFINE'
  if (n_elements(varname) eq 0) then return ; already undefined
  tempvar = SIZE(TEMPORARY(varname))
END

FUNCTION UrlBigFileGetCallbackStatus, status, progress, oProgressbar
  IF progress[0] THEN oProgressbar->Update, 100.0*progress[2]/progress[1]
  ;print, 'Check for update: '+status
  return, 1
END

;;=======================================================================
;;=======================================================================
;;;;         I M A G E   D I S P L A Y   R O U T I N E
;;=======================================================================
;;=======================================================================
PRO Guidos_Image, image0, autostretch, posx, posy

;; Catch any error in the Guidos_Image program.
Catch, theError
IF theError NE 0 THEN BEGIN
   Catch, / Cancel
   ok = Error_Message(!Error_State.Msg + ' Returning...', $
                      Traceback = Keyword_Set(debug))
   RETURN
ENDIF

IF n_elements(posx) GT 0 THEN posx = posx ELSE posx = 0
IF n_elements(posy) GT 0 THEN posy = posy ELSE posy = 0
IF autostretch THEN BEGIN
 tvscl, image0, / nan, posx, posy
ENDIF ELSE BEGIN
 tv, image0, /nan, posx, posy
ENDELSE

END ;; of 'Guidos_Image'
;;=======================================================================
;;=======================================================================
;;=======================================================================
;;;;    E N D   O F   I M A G E   D I S P L A Y   R O U T I N E
;;=======================================================================
;;=======================================================================

;;=======================================================================
;;=======================================================================
;;;;       C H E C K   I N P U T   C O M P L I A N C E
;;=======================================================================
;;=======================================================================
PRO MSPA_Compliance, fname, image0, immaxsize, verbose, result
;; get image info and validate the input for MSPA processing
result = 0
res = strpos(fname,' ') ge 0
IF res EQ 1 THEN BEGIN
  msg = 'Empty space in directory path or input filename.' + string(10b) + 'Returning...'
  IF verbose EQ 1 THEN res = dialog_message(msg, / information)
  GOTO, fin
ENDIF

;; check if input is an image format
res = query_image(fname, inpinfo)

;; check for single image in file
;;===========================
IF inpinfo.num_images GT 1 THEN BEGIN
   msg = 'MSPA-compliant image required: ' + string(10b) + $
         'Input file has more than 1 image.' + string(10b) + 'Returning...'
   IF verbose EQ 1 THEN res = dialog_message(msg, / information)
   GOTO, fin
ENDIF

;; check for single channel image
;;===========================
IF size(image0, / n_dim) NE 2 THEN BEGIN
   msg = 'MSPA-compliant image required: ' + string(10b) + $
         'Input image has more than 1 band.' + string(10b) + $
         "Try using General Tools: Preprocessing: RGB -> Single Band" + string(10b) + 'Returning...'
   IF verbose EQ 1 THEN res = dialog_message(msg, / information)
   GOTO, fin
ENDIF

;; check for byte array
;;===========================
IF size(image0, / type) NE 1 THEN BEGIN
   msg = 'MSPA-compliant image required: ' + string(10b) + $
         'Input image is not of type BYTE.' + string(10b) + $
         "Try using General Tools: Preprocessing: Convert -> Byte"  + string(10b) + 'Returning...'
   IF verbose EQ 1 THEN res = dialog_message(msg, / information)
   GOTO, fin
ENDIF

;; check for maximum image size
;;===========================
imsize = (size(image0))[4] / (1024.0^2)
IF imsize GT immaxsize THEN BEGIN
   msg = 'Input file too large.' + string(10b) + $
         '(Maximum size: ' + strtrim(round(immaxsize), 2) + ' MB)' + $
         string(10b) + "Try using: Image Analysis: Pattern: Morphological: MSPA Tiling" + string(10b) + 'Returning...'
   IF verbose EQ 1 THEN res = dialog_message(msg, / information)
   GOTO, fin
ENDIF

;; check min/max value in image
;;===========================
mxx = max(image0, min = mii)
IF mxx GT 2b THEN BEGIN
   msg = 'MSPA-compliant image required: ' + string(10b) + $
         'Image maximum is larger than 2 BYTE.' + string(10b) + $
         "Try an option from General Tools: Preprocessing" + string(10b) + 'Returning...'
   IF verbose EQ 1 THEN res = dialog_message(msg, / information)
   GOTO, fin
ENDIF ELSE IF mxx LT 2b THEN BEGIN
   msg = 'MSPA-compliant image required: ' + string(10b) + $
         'Image has no foreground (2 BYTE).' + string(10b) + $
         "Try an option from General Tools: Preprocessing" + string(10b) + 'Returning...'
   IF verbose EQ 1 THEN res = dialog_message(msg, / information)
   GOTO, fin
ENDIF
IF mii GT 1b THEN BEGIN
   msg = 'MSPA-compliant image required: ' + string(10b) + $
         'Image has no background (1 BYTE).' + string(10b) + $
         "Try an option from General Tools: Preprocessing" + string(10b) + 'Returning...'
   IF verbose EQ 1 THEN res = dialog_message(msg, / information)
   GOTO, fin
ENDIF

;; if you arrive here the image is MSPA compliant
result = 1

;;==================================================
;; end of check input compliance
fin:
END

;;=======================================================================
;;=======================================================================
PRO LM_Compliance, fname, image0, ptype, immaxsize, verbose, result
  ;; get image info and validate the input for LM processing
  result = 0
  res = strpos(fname,' ') ge 0
  IF res EQ 1 THEN BEGIN
    msg = 'Empty spaces in the directory path or the input filename.' + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF

  ;; check if input is an image format
  res = query_image(fname, inpinfo)

  ;; check for single image in file
  ;;===========================
  IF inpinfo.num_images GT 1 THEN BEGIN
    msg = 'LM-compliant image required: ' + string(10b) + $
      'Input file has more than 1 image.' + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF

  ;; check for single channel image
  ;;===========================
  IF size(image0, / n_dim) NE 2 THEN BEGIN
    msg = 'LM-compliant image required: ' + string(10b) + $
      'Input image has more than 1 band.' + string(10b) + $
      "Try using General Tools: Preprocessing: RGB -> Single Band" + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF

  ;; check for byte array
  ;;===========================
  IF size(image0, / type) NE 1 THEN BEGIN
    msg = 'LM-compliant image required: ' + string(10b) + $
      '(0b missing data, optional) 1, 2, 3 BYTE.' + string(10b) + $
      'Input image is not of type BYTE.' + string(10b) + $
      "Try using General Tools: Preprocessing: Convert -> Byte"  + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF

  ;; check for maximum image size
  ;;===========================
  imsize = (size(image0))[4] / (1024.0^2)
  IF imsize GT immaxsize THEN BEGIN
    msg = 'Input file too large.' + string(10b) + $
      '(Maximum size: ' + strtrim(round(immaxsize), 2) + ' MB)' + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF

  ;; check min/max value in image
  ;;===========================
  mxx = max(image0, min = mii)
  ss='LM'
  if ptype then ss=strupcase(ptype)
  ;; constrain maximum value to 3 or 2
  IF (ss EQ 'LM') AND (mxx GT 3b) THEN BEGIN
    msg = ss + '-compliant image required: ' + string(10b) + $
      '(0b missing data, optional) 1, 2, 3 BYTE.' + string(10b) + $
      'Image maximum data value is larger than 3 BYTE.' + string(10b) + $
      "Try an option from General Tools: Preprocessing" + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF 
  IF (ss EQ 'FAD') AND (mxx GT 4b) THEN BEGIN
    msg = ss + '-compliant image required: ' + string(10b) + $
      '1 Byte - background, 2 Byte - foreground.' + string(10b) + $
      '(0 Byte - missing data, optional)' + string(10b) + $
      '(3 Byte - specific background 1, optional)' + string(10b) + $
      '(4 Byte - specific background 2, optional)' + string(10b) + $
      'Image maximum data value is larger than 4 BYTE.' + string(10b) + $
      "Try an option from General Tools: Preprocessing" + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF
  IF mxx LT 2b THEN BEGIN
    IF (ss EQ 'LM') THEN BEGIN
      msg = ss + '-compliant image required: ' + string(10b) + $
        '(0b missing data, optional) 1, 2, 3 BYTE.' + string(10b) + $
        'Image maximum data value is less than 2 BYTE.' + string(10b) + $
        "Try an option from General Tools: Preprocessing" + string(10b) + 'Returning...'
    ENDIF
    IF (ss EQ 'FAD') THEN BEGIN
      msg = ss + '-compliant image required: ' + string(10b) + $
        '1 Byte - background, 2 Byte - foreground.' + string(10b) + $
        '(0 Byte - missing data, optional)' + string(10b) + $
        '(3 Byte - specific background 1, optional)' + string(10b) + $
        '(4 Byte - specific background 2, optional)' + string(10b) + $
        'Image maximum data value is less than 2 BYTE.' + string(10b) + $
        "Try an option from General Tools: Preprocessing" + string(10b) + 'Returning...'
    ENDIF
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF
  ;; now the maxx is 2 or 3, constrain minimum value to 1 or 2
  IF (ss EQ 'LM') AND (mii GT 2b) THEN BEGIN
    msg = ss + '-compliant image required: ' + string(10b) + $
      '(0b missing data, optional) 1, 2, 3 BYTE.' + string(10b) + $
      'Image minimum and maximum data value is 3 BYTE.' + string(10b) + $
      "Please recode your input to have at least 2 non-zero class values" + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF
  IF (ss EQ 'FAD') AND (mii GT 2b) THEN BEGIN
    msg = ss + '-compliant image required: ' + string(10b) + $
      '1 Byte - background, 2 Byte - foreground.' + string(10b) + $
      '(0 Byte - missing data, optional)' + string(10b) + $
      '(3 Byte - specific background 1, optional)' + string(10b) + $
      '(4 Byte - specific background 2, optional)' + string(10b) + $
      'Image minimum data value is larger than 2 BYTE.' + string(10b) + $
      "Please recode your input to have at least 2 non-zero class values" + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF

  ;; if we arrive here then we know that the maxx= 2 or 3
  ;; and the mii can only be 0,1,2,3
  ;; now we only need to check that 
  ;; a) when doing FAD
  ;;    - we must have foreground pixels (2) and we must have BG-pixels (1)
  ;; b) when doing P23
  ;;    - we must have foreground pixels (2) and we must have interesting background (3) 
  ;; c) when doing LM
  ;;    we must have at least two different non-zero values
  ;; because we do not want to calculate LM/P23 for a map with only 1, or 2, or 3
  upv = where(histogram( image0, /l64) GT 0)
  
  if ptype eq 'fad' then begin
    q=where(upv eq 2, ct)
    IF ct NE 1 THEN BEGIN
      msg = 'FAD-compliant image required: ' + string(10b) + $
        '1 Byte - background, 2 Byte - foreground.' + string(10b) + $
        '(0 Byte - missing data, optional)' + string(10b) + $
        '(3 Byte - specific background 1, optional)' + string(10b) + $
        '(4 Byte - specific background 2, optional)' + string(10b) + $
        'No pixels with mandatory FG-data value 2 BYTE found.' + string(10b) + $
        "Try an option from General Tools: Preprocessing" + string(10b) + 'Returning...'
      IF verbose EQ 1 THEN res = dialog_message(msg, / information)
      GOTO, fin
    ENDIF 
    q=where(upv eq 1, ct)
    IF ct NE 1 THEN BEGIN
      msg = 'FAD-compliant image required: ' + string(10b) + $
        '1 Byte - background, 2 Byte - foreground.' + string(10b) + $
        '(0 Byte - missing data, optional)' + string(10b) + $
        '(3 Byte - specific background 1, optional)' + string(10b) + $
        '(4 Byte - specific background 2, optional)' + string(10b) + $
        'No pixels with mandatory BG-data value 1 BYTE found.' + string(10b) + $
        "Try an option from General Tools: Preprocessing" + string(10b) + 'Returning...'
      IF verbose EQ 1 THEN res = dialog_message(msg, / information)
      GOTO, fin
    ENDIF
  ENDIF

  if ptype eq 'p23' then begin
    q=where(upv eq 2, ct)
    IF ct NE 1 THEN BEGIN
      msg = 'P23-compliant image required: ' + string(10b) + $
        '(0b missing data, optional) 1, 2, 3 BYTE.' + string(10b) + $
        'No pixels with mandatory data value 2 BYTE found.' + string(10b) + $
        "Try an option from General Tools: Preprocessing" + string(10b) + 'Returning...'
      IF verbose EQ 1 THEN res = dialog_message(msg, / information)
      GOTO, fin
    ENDIF 
    q=where(upv eq 3, ct)
    IF ct NE 1 THEN BEGIN
      msg = 'LP23-compliant image required: ' + string(10b) + $
        '(0b missing data, optional) 1, 2, 3 BYTE.' + string(10b) + $
        'No pixels with mandatory data value 3 BYTE found.' + string(10b) + $
        "Try an option from General Tools: Preprocessing" + string(10b) + 'Returning...'
      IF verbose EQ 1 THEN res = dialog_message(msg, / information)
      GOTO, fin
    ENDIF
  endif 
  ;; test to have at least two different non-zero classes, good for both, lm and p23
  q=n_elements(where(upv ne 0))
  if q eq 1 then begin
    msg = 'LM-compliant image required: ' + string(10b) + $
      '(0b missing data, optional) 1, 2, 3 BYTE.' + string(10b) + $
      'This image has only 1 non-zero layer.' + string(10b) + $
      "Please recode your input to have at least 2 non-zero class values." + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  endif
  ;; if we arrive here the image is LM compliant
  result = 1

  ;;==================================================
  ;; end of check input compliance
  fin:
END

;;=======================================================================
PRO Labelall_Compliance, fname, image0, immaxsize, verbose, result
  ;; get image info and validate the input for labelall processing
  result = 0
  
  res = strpos(fname,' ') ge 0
  IF res EQ 1 THEN BEGIN
    msg = 'Empty spaces in the directory path or the input filename.' + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF

  ;; check if input is an image format
  res = query_image(fname, inpinfo)

  ;; check for single image in file
  ;;===========================
  IF inpinfo.num_images GT 1 THEN BEGIN
    msg = 'Input file has more than 1 image.' + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF

  ;; check for single channel image
  ;;===========================
  IF size(image0, / n_dim) NE 2 THEN BEGIN
    msg = 'Input image has more than 1 band.' + string(10b) + $
      "Try using General Tools: Preprocessing: RGB -> Single Band" + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF

  ;; check for byte/integer array
  ;;===========================
  tt = size(image0, / type) & bi = [1, 2, 12, 3, 13, 14, 15]
  ;; byte or integer is one of the bi above
  q = where(tt eq bi, ct)
  IF ct eq 0 THEN BEGIN
    msg = 'Input image is not of type BYTE or INTEGER.' + string(10b) + $
      "Try using General Tools: Preprocessing: Convert -> Byte"  + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF

  ;; check for maximum image size
  ;;===========================
  imsize = (size(image0))[4] / (1024.0^2)
  IF imsize GT immaxsize THEN BEGIN
    msg = 'Input file too large.' + string(10b) + $
      '(Maximum size: ' + strtrim(round(immaxsize), 2) + ' MB)' + string(10b) + 'Returning...'
    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
    GOTO, fin
  ENDIF

  ;; check min/max value in image
  ;;===========================
;  mxx = max(image0, min = mii)
;  IF mxx LT 1b THEN BEGIN
;    msg = 'Image maximum must be larger than 0 BYTE.' + string(10b) + $
;      "Try an option from General Tools: Preprocessing" + string(10b) + 'Returning...'
;    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
;    GOTO, fin
;  ENDIF 
;  IF mii NE 0b THEN BEGIN
;    msg = 'Image has no background (0 BYTE).' + string(10b) + $
;      "Try an option from General Tools: Preprocessing" + string(10b) + 'Returning...'
;    IF verbose EQ 1 THEN res = dialog_message(msg, / information)
;    GOTO, fin
;  ENDIF

  ;; if you arrive here the image is ok; has 0b for BG and other FG-classes
  result = 1

  ;;==================================================
  ;; end of check input compliance
  fin:
END

;;=======================================================================
;;=======================================================================
;;=======================================================================
;;;;       E N D  O F   C H E C K   I N P U T   C O M P L I A N C E
;;=======================================================================
;;======================================================================
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  calculate  simple statistics
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRO simplestats, image0, fconn, ttrans, tintext, cg, st
;; Purpose: calculate simple statistics of a given fullres image
;; INPUT:
;; - image0: the fullres MSPA-image
;; - fconn: foreground connectivity
;; - ttrans: transition value
;; - tintext: Intext value
;; - cg: distinguish core groups selected below viewport
;; 
;; OUTPUT
;; - st: strarr percentages wrt fg/data and count/BGarea
;;
;;==============================================================
;; 7-class: possible values are
;;==============================================================
;;      CLASS              COLOR           RGB         int   ext
;; 1a) Core (small)        green       000/130/000     116   16
;; 1b) Core (medium/normal green       000/200/000     117   17
;; 1c) Core (large)        green       000/255/000     118   18
;; 2)  Islet               brown       160/060/000     109   9
;; 3)  Perforation         blue        000/000/255     105   5
;; 4)  Edge                black       000/000/000     103   3
;; 5a) Loop                yellow      255/255/000     165   65
;; 5b)  in Edge            yellow      255/255/000     167   67
;; 5c)  in Perforation     yellow      255/255/000     169   69
;; 6a) Bridge              red         255/000/000     133   33
;; 6b)  in Edge            red         255/000/000     135   35
;; 6c)  in Perforation     red         255/000/000     137   37
;; 7)  Branch              orange      255/140/000     101   1
;;
;; Background              gray        220/220/220     100   0
;; Opening                 gray        220/220/220     0   (if intext=0)
;; CoreOpening           darkgrey      136/136/136     100 (if intext=1)
;; BorderOpening           gray        194/194/194     220 (if intext=1)
;;
;; Missing                 white       255/255/255     129   129
;;
;;
;; 1) the above color table is valid for transition = 1. If
;;    transition = 0 then 5b an 6b will be displayed in black
;;    and 5c and 6c will be displayed in blue.
;;    TRANSITION only changes the display
;;    color BUT NOT the image byte values!
;; 2) If INTERNAL = 1 then you will get a dual layer of
;;    class values where an offset of 100b is assigned to internal
;;    foreground pixels. Internal means that there is no access to
;;    any image borderline, or an object of connected background
;;    pixels completely enclosed by foreground pixels. If internal
;;    is on you can get byte values from both columns above beside
;;    for Perforation which by definition is an internal feature,
;;    so you can only have 105b and not 5b if internal = 1

sz = size(image0) & tt2 = bytarr(sz(1) + 6, sz(2) + 6)
;; initialize to set all frequencies to 0
freq_missing = 0 & freq_backg = 0 & freq_core = 0 & freq_islet = 0
freq_perforated = 0 & freq_edge = 0 & freq_loop = 0 & freq_bridge = 0
freq_branch = 0 & freq_core_small = 0 & freq_core_large = 0 & freq_opening = 0
freq_coreopen = 0 & freq_borderopen = 0

opening = 0 & core_opening = 0 & border_opening = 0 ;; areas of openings
fconn2 = 1-fconn ;; complement to the current FG-conncetivity rule

;; calculate the class percentages by data area (d_area) and
;; by foreground area (f_<class>)

;; data area
p = where(image0 NE 129b, d_area, /l64)
allmissing = sz[4] - d_area
tt = image0 * 0b + 1b & tt(p) = 0b
tt2(3:sz(1)+2, 3:sz(2)+2) = temporary(tt)
freq_missing = max(label_region(tt2, / ulong, all_neighbors = 1))

;; background area; use fconn2 neighborhood rule
p = where(image0 EQ 0b OR image0 EQ 100b OR image0 EQ 220b, allbackg, /l64)
tt = image0 * 0b & tt(p) = 1b
tt2 = tt2*0b & tt2(3:sz(1)+2, 3:sz(2)+2) = temporary(tt)
freq_backg = max(label_region(tt2, / ulong, all_neighbors = fconn2))

;; foreground area
foreg = d_area - allbackg ;; foreground pixels
;; conversion factor backg2foreg
byforeg = float(d_area) / foreg

;; openings
;;==================================================
;; do stats for core and border openings
d_core_opening = '--' & d_border_opening = '--'
freq_core_opening = 0 & freq_border_opening = 0
if tintext eq 1 then begin
  ;; border opening
  p = where(image0 EQ 220b, d_border_opening, /l64)
  IF d_border_opening NE 0 THEN BEGIN
    tt = image0 * 0b & tt(p) = 1b
    tt2 = tt2*0b & tt2(3:sz(1)+2, 3:sz(2)+2) = temporary(tt)
    freq_border_opening = max(label_region(tt2, / ulong, all_neighbors = fconn2)) ;;fconn2 because BG
  ENDIF
  d_border_opening = 100.0 / d_area * d_border_opening ;;% of data area
  d_border_opening = strtrim((round(d_border_opening * 100.0) / 100.0), 1)
  pos = strpos(d_border_opening, '.') & d_border_opening = strmid(d_border_opening, 0, pos + 3)
  IF strlen(d_border_opening) EQ 4 THEN d_border_opening = ' ' + d_border_opening

  ;; core opening
  p = where(image0 EQ 100b, d_core_opening, /l64)
  IF d_core_opening NE 0 THEN BEGIN
    tt = image0 * 0b & tt(p) = 1b
    tt2 = tt2*0b & tt2(3:sz(1)+2, 3:sz(2)+2) = temporary(tt)
    freq_core_opening = max(label_region(tt2, / ulong, all_neighbors = fconn2)) ;;fconn2 because BG
  ENDIF
  d_core_opening = 100.0 / d_area * d_core_opening ;;% of data area 
  d_core_opening = strtrim((round(d_core_opening * 100.0) / 100.0), 1)
  pos = strpos(d_core_opening, '.') & d_core_opening = strmid(d_core_opening, 0, pos + 3)
  IF strlen(d_core_opening) EQ 4 THEN d_core_opening = ' ' + d_core_opening  

endif 

;; count of all openings
freq_opening = freq_core_opening + freq_border_opening

;; area of all openings
border_opening = ulong64(total(image0 EQ 220b))
core_opening = ulong64(total(image0 EQ 100b))
opening = border_opening + core_opening

;; 1. core - green : data/foreground/frequency
p = where(image0 EQ 17b OR image0 EQ 117b, d_core, /l64) & core_pix = d_core
IF d_core NE 0 THEN BEGIN
   tt = image0 * 0b & tt(p) = 1b
   tt2 = tt2*0b & tt2(3:sz(1)+2, 3:sz(2)+2) = temporary(tt)
   freq_core = max(label_region(tt2, / ulong, all_neighbors = fconn))
ENDIF
d_core = 100.0 / d_area * d_core
f_core = d_core * byforeg

if cg eq 1 then begin
;;===============================================
;; additional stats for small and large cores  
  p = where(image0 EQ 16b OR image0 EQ 116b, d_core_small, /l64) & core_pix = core_pix + d_core_small
IF d_core_small NE 0 THEN BEGIN
  tt = image0 * 0b & tt(p) = 1b
  tt2 = tt2*0b & tt2(3:sz(1)+2, 3:sz(2)+2) = temporary(tt)
  freq_core_small = max(label_region(tt2, / ulong, all_neighbors = fconn))
ENDIF
d_core_small = 100.0 / d_area * d_core_small
f_core_small = d_core_small * byforeg

p = where(image0 EQ 18b OR image0 EQ 118b, d_core_large, /l64) & core_pix = core_pix + d_core_large
IF d_core_large NE 0 THEN BEGIN
  tt = image0 * 0b & tt(p) = 1b
  tt2 = tt2*0b & tt2(3:sz(1)+2, 3:sz(2)+2) = temporary(tt)
  freq_core_large = max(label_region(tt2, / ulong, all_neighbors = fconn))
ENDIF
d_core_large = 100.0 / d_area * d_core_large
f_core_large = d_core_large * byforeg

endif


;; 2. islet - brown
p = where(image0 EQ 9b OR image0 EQ 109b, d_islet, /l64)
IF d_islet NE 0 THEN BEGIN
   tt = image0 * 0b & tt(p) = 1b
   tt2 = tt2*0b & tt2(3:sz(1)+2, 3:sz(2)+2) = temporary(tt)
   freq_islet = max(label_region(tt2, / ulong, all_neighbors = fconn))
ENDIF
d_islet = 100.0 / d_area * d_islet
f_islet = d_islet * byforeg


;; 3. perforation - blue
p = where(image0 EQ 5b OR image0 EQ 105b, d_perforated, /l64)
p1 = where(image0 EQ 69b OR image0 EQ 169b, d_p1, /l64)
p2 = where(image0 EQ 37b OR image0 EQ 137b, d_p2, /l64)
d_perforated = d_perforated + d_p1 + d_p2 & perf_pix = d_perforated
IF d_perforated NE 0 THEN BEGIN ;; we have perforations
   tt = image0 * 0b & tt(p) = 1b
   IF d_p1 GT 0 THEN tt(p1) = 1b
   IF d_p2 GT 0 THEN tt(p2) = 1b
   tt2 = tt2*0b & tt2(3:sz(1)+2, 3:sz(2)+2) = temporary(tt)
   freq_perforated = max(label_region(tt2, / ulong, all_neighbors = fconn)) 
ENDIF
d_perforated = 100.0 / d_area * d_perforated
f_perforated = d_perforated * byforeg


;; 4. edge - black
p = where(image0 EQ 3b OR image0 EQ 103b, d_edge, /l64)
p1 = where(image0 EQ 67b OR image0 EQ 167b, d_e1, /l64)
p2 = where(image0 EQ 35b OR image0 EQ 135b, d_e2, /l64)
d_edge = d_edge + d_e1 + d_e2 & edge_pix = d_edge
IF d_edge NE 0 THEN BEGIN
   tt = image0 * 0b & tt(p) = 1b
   IF d_e1 GT 0 THEN tt(p1) = 1b
   IF d_e2 GT 0 THEN tt(p2) = 1b
   tt2 = tt2*0b & tt2(3:sz(1)+2, 3:sz(2)+2) = temporary(tt)
   freq_edge = max(label_region(tt2, / ulong, all_neighbors = fconn))
ENDIF
d_edge = 100.0 / d_area * d_edge
f_edge = d_edge * byforeg


;; 5. loop - yellow
p1 =  where(image0 EQ 65b OR image0 EQ 165b, d_loop, /l64)
d_loop = 100.0 / d_area * d_loop
f_loop = d_loop * byforeg
IF d_loop GT 0 THEN BEGIN
   tt = image0 * 0b
   tt(p1) = 1b
   tt2 = tt2*0b & tt2(3:sz(1)+2, 3:sz(2)+2) = temporary(tt)
   freq_loop = max(label_region(tt2, / ulong, all_neighbors = fconn))
ENDIF


;; 6. bridge - red
p1 =  where(image0 EQ 33b OR image0 EQ 133b, d_bridge, /l64)
d_bridge = 100.0 / d_area * d_bridge
f_bridge = d_bridge * byforeg
IF d_bridge GT 0 THEN BEGIN
   tt = image0 * 0b
   tt(p1) = 1b
   tt2 = tt2*0b & tt2(3:sz(1)+2, 3:sz(2)+2) = temporary(tt)
   freq_bridge = max(label_region(tt2, / ulong, all_neighbors = fconn))
ENDIF


;; 7. branch - orange
p = where(image0 EQ 1b OR image0 EQ 101b, d_branch, /l64)
IF d_branch NE 0 THEN BEGIN
   tt = image0 * 0b & tt(p) = 1b
   tt2 = tt2*0b & tt2(3:sz(1)+2, 3:sz(2)+2) = temporary(tt)
   freq_branch = max(label_region(tt2, / ulong, all_neighbors = fconn))
ENDIF
tt2 = 0
d_branch = 100.0 / d_area * d_branch
f_branch = d_branch * byforeg

;; background - grey
d_bg = 100.0 / d_area * allbackg

;; missing - white
missing = 100.0 / sz(4) * (sz(4) - d_area)

;; Porosity
area_contiguous = core_pix + edge_pix + perf_pix
area_internal = area_contiguous + core_opening
porosity = 100.0 - (double(area_contiguous) / area_internal * 100.0)

;; convert the numbers into suitable strings for the GUI
;;=======================================================
d_core = strtrim((round(d_core * 100.0) / 100.0), 1)
pos = strpos(d_core, '.') & d_core = strmid(d_core, 0, pos + 3)
IF strlen(d_core) EQ 4 THEN d_core = ' ' + d_core
f_core = strtrim((round(f_core * 100.0) / 100.0), 1)
pos = strpos(f_core, '.') & f_core = strmid(f_core, 0, pos + 3)
IF strlen(f_core) EQ 4 THEN f_core = ' ' + f_core

if cg eq 1 then begin
  d_core_small = strtrim((round(d_core_small * 100.0) / 100.0), 1)
  pos = strpos(d_core_small, '.') & d_core_small = strmid(d_core_small, 0, pos + 3)
  IF strlen(d_core_small) EQ 4 THEN d_core_small = ' ' + d_core_small
  f_core_small = strtrim((round(f_core_small * 100.0) / 100.0), 1)
  pos = strpos(f_core_small, '.') & f_core_small = strmid(f_core_small, 0, pos + 3)
  IF strlen(f_core_small) EQ 4 THEN f_core_small = ' ' + f_core_small

  d_core_large = strtrim((round(d_core_large * 100.0) / 100.0), 1)
  pos = strpos(d_core_large, '.') & d_core_large = strmid(d_core_large, 0, pos + 3)
  IF strlen(d_core_large) EQ 4 THEN d_core_large = ' ' + d_core_large
  f_core_large = strtrim((round(f_core_large * 100.0) / 100.0), 1)
  pos = strpos(f_core_large, '.') & f_core_large = strmid(f_core_large, 0, pos + 3)
  IF strlen(f_core_large) EQ 4 THEN f_core_large = ' ' + f_core_large
endif

d_islet = strtrim((round(d_islet * 100.0) / 100.0), 1)
pos = strpos(d_islet, '.') & d_islet = strmid(d_islet, 0, pos + 3)
IF strlen(d_islet) EQ 4 THEN d_islet = ' ' + d_islet
f_islet = strtrim((round(f_islet * 100.0) / 100.0), 1)
pos = strpos(f_islet, '.') & f_islet = strmid(f_islet, 0, pos + 3)
IF strlen(f_islet) EQ 4 THEN f_islet = ' ' + f_islet

d_perforated = strtrim((round(d_perforated * 100.0) / 100.0), 1)
pos = strpos(d_perforated, '.')
d_perforated = strmid(d_perforated, 0, pos + 3)
IF strlen(d_perforated) EQ 4 THEN d_perforated = ' ' + d_perforated
f_perforated = strtrim((round(f_perforated * 100.0) / 100.0), 1)
pos = strpos(f_perforated, '.')
f_perforated = strmid(f_perforated, 0, pos + 3)
IF strlen(f_perforated) EQ 4 THEN f_perforated = ' ' + f_perforated

d_edge = strtrim((round(d_edge * 100.0) / 100.0), 1)
pos = strpos(d_edge, '.') & d_edge = strmid(d_edge, 0, pos + 3)
IF strlen(d_edge) EQ 4 THEN d_edge = ' ' + d_edge
f_edge = strtrim((round(f_edge * 100.0) / 100.0), 1)
pos = strpos(f_edge, '.') & f_edge = strmid(f_edge, 0, pos + 3)
IF strlen(f_edge) EQ 4 THEN f_edge = ' ' + f_edge

d_loop = strtrim((round(d_loop * 100.0) / 100.0), 1)
pos = strpos(d_loop, '.') & d_loop = strmid(d_loop, 0, pos + 3)
IF strlen(d_loop) EQ 4 THEN d_loop = ' ' + d_loop
f_loop = strtrim((round(f_loop * 100.0) / 100.0), 1)
pos = strpos(f_loop, '.') & f_loop = strmid(f_loop, 0, pos + 3)
IF strlen(f_loop) EQ 4 THEN f_loop = ' ' + f_loop

d_bridge = strtrim((round(d_bridge * 100.0) / 100.0), 1)
pos = strpos(d_bridge, '.') & d_bridge = strmid(d_bridge, 0, pos + 3)
IF strlen(d_bridge) EQ 4 THEN d_bridge = ' ' + d_bridge
f_bridge = strtrim((round(f_bridge * 100.0) / 100.0), 1)
pos = strpos(f_bridge, '.') & f_bridge = strmid(f_bridge, 0, pos + 3)
IF strlen(f_bridge) EQ 4 THEN f_bridge = ' ' + f_bridge

d_branch = strtrim((round(d_branch * 100.0) / 100.0), 1)
pos = strpos(d_branch, '.') & d_branch = strmid(d_branch, 0, pos + 3)
IF strlen(d_branch) EQ 4 THEN d_branch = ' ' + d_branch
f_branch = strtrim((round(f_branch * 100.0) / 100.0), 1)
pos = strpos(f_branch, '.') & f_branch = strmid(f_branch, 0, pos + 3)
IF strlen(f_branch) EQ 4 THEN f_branch = ' ' + f_branch

d_bg = strtrim((round(d_bg * 100.0) / 100.0), 1)
pos = strpos(d_bg, '.') & d_bg = strmid(d_bg, 0, pos + 3)
IF strlen(d_bg) EQ 4 THEN d_bg = ' ' + d_bg

missing = strtrim((round(missing * 100.0) / 100.0), 1)
pos = strpos(missing, '.') & missing = strmid(missing, 0, pos + 3)
IF strlen(missing) EQ 4 THEN missing = ' ' + missing

porosity = strtrim((round(porosity * 100.0) / 100.0), 1)
pos = strpos(porosity, '.') & porosity = strmid(porosity, 0, pos + 3)
IF strlen(porosity) EQ 4 THEN porosity = ' ' + porosity

st = strarr(2, 14)
;; first data column:% FG /% Data area
;; z = the second column showing frequency/BG area where applicable
if cg eq 0 then begin
  st(0, * ) = ['--/--', f_core + '/' + d_core, '--/--', f_islet + '/' + d_islet, $
    f_perforated + '/' + d_perforated, f_edge + '/' + d_edge, $
    f_loop + '/' + d_loop, f_bridge + '/' + d_bridge, $
    f_branch + '/' + d_branch, ' --/' + d_bg, ' ' + missing + ' ', porosity + ' Porosity', $
    ' --/' + d_core_opening, ' --/' + d_border_opening]
  z = strtrim([0, freq_core, 0, freq_islet, freq_perforated, freq_edge, freq_loop, freq_bridge, freq_branch, $
    freq_backg, freq_missing, freq_opening, freq_core_opening, freq_border_opening],2)
endif else begin
  st(0, * ) = [f_core_small + '/' + d_core_small, f_core + '/' + d_core, $
    f_core_large + '/' + d_core_large, f_islet + '/' + d_islet, $
    f_perforated + '/' + d_perforated, f_edge + '/' + d_edge, $
    f_loop + '/' + d_loop, f_bridge + '/' + d_bridge, $
    f_branch + '/' + d_branch, ' --/' + d_bg, ' ' + missing + ' ', porosity + ' Porosity', $
    ' --/' + d_core_opening, ' --/' + d_border_opening]
  z = strtrim([freq_core_small, freq_core, freq_core_large, freq_islet, freq_perforated, freq_edge, $
    freq_loop, freq_bridge, freq_branch, freq_backg, freq_missing, $
    freq_opening, freq_core_opening, freq_border_opening],2)
endelse

IF tintext EQ 1 THEN BEGIN
  z[11] = z[11] + '/' + strtrim(opening, 2)
  z[12] = z[12] + '/' + strtrim(core_opening, 2)
  z[13] = z[13] + '/' + strtrim(border_opening, 2)
ENDIF ELSE BEGIN
  z[11] = '--/--'
  z[12] = '--/--'
  z[13] = '--/--'
  st[0,11] = z[11]
  st[0,12] = z[12]
  st[0,13] = z[13]
ENDELSE
z[9] = z[9] + '/' + strtrim(allbackg, 2) ;; add info on BG area
;; add info on missing
z[10] = z[10] + '/' + strtrim(allmissing, 2)
st(1, * ) = z

END

PRO heatmap, dir_tmp, dir_guidossub, my_os, kdim_str, ctmiss, im
;; Purpose: recode spatcon LM output to 19 classes and get heatmap+statistics for the 103 classes
;;
;; my_os: my_os
;; kdim_str: selected kernel size (string)
;;

;; im103 is the 103 classes byte output
;; remap this im103 to the old 19 colours classes
;; we need these 3 files in tmp-directory: recsize.txt, recode.txt, recinput (bsq-file) -> recoutput
;;
pushd, dir_tmp
;; 1) get the result from the 103 LM
file_move, 'scsize.txt', 'recsize.txt', /overwrite
;; get image dimensions
close, 1 & openr,1, 'recsize.txt' & q=''
readf,1,q & ydim = (strsplit(q,' ',/extract))[1]
readf,1,q & xdim = (strsplit(q,' ',/extract))[1]
close,1
im103 = bytarr(xdim,ydim)
openr, 1, 'scoutput' & readu,1, im103 & close,1

;; assign missing pixels if present before recoding
if ctmiss gt 0 then begin
  restore, dir_tmp + 'missing.sav' & im103[qmiss] = 0b
  openw, 1, 'recinput' & writeu,1, im103 & close,1
endif else begin
  file_move, 'scoutput', 'recinput', /overwrite
endelse

;; the recode table
file_copy, dir_guidossub + 'recodelm103.sav', 'recode.txt', /overwrite

;; setup recode
IF my_os EQ 'windows' THEN BEGIN
  recode='..\spatcon\recode64.exe' & file_copy, recode, 'recode.exe', /overwrite
ENDIF ELSE IF my_os EQ 'apple' THEN BEGIN
  recode='../spatcon/recode_mac' & file_copy, recode, 'recode', /overwrite
ENDIF ELSE BEGIN
  recode='../spatcon/recode_lin64' & file_copy, recode, 'recode', /overwrite
ENDELSE

;; do the recoding from 103 classes to the 19 lm-colors
IF my_os EQ 'windows' THEN spawn, 'recode.exe', log, / hide ELSE spawn, './recode', log

;; rename the 103 class image for later
file_move, 'recinput', 'lm103class', /overwrite

;; get result
im = im103 * 0b
openr, 1, 'recoutput' & readu,1, im & close,1
;; empty dir_tmp, do heatmap & statistics and go back
;list = file_search() & nl = n_elements(list)
;if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive

;; do the heatmap statistics
hist = histogram(im103) ;; the frequencies for each class
tot = total(hist[1:236]) & hn = hist/tot*100.0 & eps = 0.000005 & hmax = max(hn[1:*])
;; we are using the lm-colours!
;; white (0) no number if not present
;; black (20) if not hmax
;; invert black on white for hmax

a = FINDGEN(49) * (!PI*2/48.) & USERSYM, COS(A), SIN(A), /FILL ;; a circle use symsize=8

tri = read_png(dir_guidossub + 'triangle.png') & sz = size(tri,/dim)
window, 11, xsize=sz[1], ysize=sz[2], /pixmap, retain=2 & tv, tri, /true

;; row 1
y1 = 225 & y2 = 270
subt = hn[191] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 280,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 280,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[192] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 355,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 355,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[71] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 425,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 425,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[72] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 495,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 495,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[73] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 570,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 570,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[74] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 640,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 640,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[75] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 710,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 710,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[131] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 785,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 785,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[132] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 855,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 855,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[133] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 927,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 927,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[134] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1000,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1000,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[135] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1070,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1070,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[45] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1142,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1142,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[44] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1215,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1215,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[43] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1285,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1285,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[42] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1355,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1355,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[41] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1425,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1425,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[182] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1500,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1500,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[181] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1570,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1570,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device

;; row 2
y1 = 350 & y2 = 395
subt = hn[61] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 355,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 355,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[62] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 425,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 425,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[111] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 495,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 495,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[112] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 570,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 570,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[114] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 640,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 640,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[200] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 710,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 710,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[201] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 785,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 785,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[202] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 855,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 855,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[203] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 927,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 927,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[204] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1000,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1000,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[205] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1070,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1070,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[206] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1142,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1142,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[103] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1215,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1215,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[102] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1285,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1285,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[101] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1355,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1355,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[52] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1425,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1425,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[51] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1500,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1500,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device

;; row 3
y1 = 475 & y2 = 520
subt = hn[63] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 427,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 427,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[64] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 495,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 495,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[113] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 570,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 570,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[222] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 640,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 640,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[223] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 710,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 710,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[224] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 785,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 785,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[225] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 855,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 855,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[226] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 927,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 927,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[227] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1000,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1000,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[228] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1070,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1070,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[207] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1142,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1142,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[208] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1215,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1215,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[104] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1285,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1285,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[54] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1355,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1355,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[53] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1425,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1425,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device

;; row 4   delta:   125
y1 = 600 & y2 = 645
subt = hn[65] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 495,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 495,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[155] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 570,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 570,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[221] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 640,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 640,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[220] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 710,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 710,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[235] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 785,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 785,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[234] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 855,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 855,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[236] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 927,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 927,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[230] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1000,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1000,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[229] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1070,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1070,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[210] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1142,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1142,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[209] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1215,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1215,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[141] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1285,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1285,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[55] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1355,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1355,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device

;; row 5   delta:   125
y1 = 725 & y2 = 770
subt = hn[154] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 570,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 570,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[153] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 640,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 640,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[219] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 710,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 710,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[218] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 785,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 785,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[233] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 855,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 855,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[232] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 927,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 927,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[231] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1000,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1000,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[212] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1070,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1070,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[211] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1142,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1142,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[143] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1215,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1215,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[142] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1285,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1285,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device

;; row 6   delta:   125
y1 = 850 & y2 = 895
subt = hn[152] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 640,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 640,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[151] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 710,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 710,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[217] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 785,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 785,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[216] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 855,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 855,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[215] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 927,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 927,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[214] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1000,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1000,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[213] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1070,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1070,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[145] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1142,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1142,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[144] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1215,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1215,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device

;; row 7   delta:   125
y1 = 975 & y2 = 1020
subt = hn[95] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 710,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 710,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[94] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 785,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 785,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[124] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 855,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 855,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[122] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 927,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 927,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[123] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1000,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1000,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[84] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1070,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1070,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[85] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1142,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1142,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device

;; row 8   delta:   125
y1 = 1100 & y2 = 1145
subt = hn[93] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 785,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 785,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[92] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 855,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 855,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[121] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 927,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 927,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[82] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1000,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1000,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[83] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1070,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1070,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device

;; row 9   delta:   125
y1 = 1225 & y2 = 1270
subt = hn[91] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 855,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 855,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[172] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 927,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 927,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[81] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1000,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1000,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device

;; row 10   delta:   125
y1 = 1350
subt = hn[171] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 927,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 927,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device

;; the 3 extremes
y1 = 95 & y2 = 1582
subt = hn[190] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 87,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 87,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[180] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 1742,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 1742,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device
subt = hn[170] & cl = subt eq hmax & cl_circ = cl*20 & cl_nr = (1-cl)*20
plots, 925,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
if subt gt eps then xyouts, 925,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device

wset,11 & res = tvrd(/true) & wdelete, 11
write_png, 'heatmap.png', res

;; write sav-file for change analysis
hmap = fltarr(21,12)-1.0
hmap[10,0] = hn[170] & hmap[10,1] = hn[171]
hmap[9:11,2] = [hn[91],hn[172],hn[81]]
hmap[8:12,3] = [hn[93],hn[92],hn[121],hn[82],hn[83]]
hmap[7:13,4] = [hn[95],hn[94],hn[124],hn[122],hn[123],hn[84],hn[85]]
hmap[6:14,5] = [hn[152],hn[151],hn[217],hn[216],hn[215],hn[214],hn[213],hn[145],hn[144]]
hmap[5:15,6] = [hn[154],hn[153],hn[219],hn[218],hn[233],hn[232],hn[231],hn[212],hn[211],hn[143],hn[142]]
hmap[4:16,7] = [hn[65],hn[155],hn[221],hn[220],hn[235],hn[234],hn[236],hn[230],hn[229],hn[210],hn[209],hn[141],hn[55]]
hmap[3:17,8] = [hn[63],hn[64],hn[113],hn[222],hn[223],hn[224],hn[225],hn[226],hn[227],hn[228],hn[207],hn[208],hn[104],hn[54],hn[53]]
hmap[2:18,9] = [hn[61],hn[62],hn[111],hn[112],hn[114],hn[200],hn[201],hn[202],hn[203],hn[204],hn[205],hn[206],hn[103],hn[102],hn[101],hn[52],hn[51]]
hmap[1:19,10] = [hn[191],hn[192],hn[71],hn[72],hn[73],hn[74],hn[75],hn[131],hn[132],hn[133],hn[134],hn[135],hn[45],hn[44],hn[43],hn[42],hn[41],hn[182],hn[181]]
hmap[0,11] = [hn[190]] & hmap[20,11] = [hn[180]]
save, kdim_str, hn, hmap, filename = 'heatmap.sav'

;; write csv output
hns = round(hn*1000)/1000.0 & dot = strpos(hns,'.') & hnss = strarr(n_elements(hns))
for i = 0, n_elements(hns)-1 do hnss[i] = strmid(hns[i],0,dot[i]+4)

openw,12, 'heatmap.csv'
if kdim_str eq 'multiscale' then begin
  printf,12, 'Landscape Mosaic (multiscale)' + ', , , , , , , , , , , , , , , , , , , , ,'
endif else begin
  printf,12, 'Landscape Mosaic using Window size (' + kdim_str + 'x' + kdim_str +')' + ', , , , , , , , , , , , , , , , , , , , ,'
endelse
printf,12, ', , , , , , , , , , ,' +hnss[170]+ ', , , , , , , , , ,'
printf,12, ', , , , , , , , , , ,'+hnss[171]+ ', , , , , , , , , ,'
printf,12, ', , , , , , , , , ,'+hnss[91]+','+hnss[172]+','+hnss[81]+', , , , , , , , ,'
printf,12, ', , , , , , , , ,'+hnss[93]+','+hnss[92]+','+hnss[121]+','+hnss[82]+','+hnss[83]+', , , , , , , ,'
printf,12, ', , , , , , , ,'+hnss[95]+','+hnss[94]+','+hnss[124]+','+hnss[122]+','+hnss[123]+','+hnss[84]+','+hnss[85]+', , , , , , ,'
printf,12, ', , , , , , ,'+hnss[152]+','+hnss[151]+','+hnss[217]+','+hnss[216]+','+hnss[215]+','+hnss[214]+','+$
  hnss[213]+','+hnss[145]+','+hnss[144]+', , , , , ,'
printf,12, ', , , , , ,'+hnss[154]+','+hnss[153]+','+hnss[219]+','+hnss[218]+','+hnss[233]+','+hnss[232]+','+$
  hnss[231]+','+hnss[212]+','+hnss[211]+','+hnss[143]+','+hnss[142]+', , , , ,'
printf,12, ', , , , ,'+hnss[65]+','+hnss[155]+','+hnss[221]+','+hnss[220]+','+hnss[235]+','+hnss[234]+','+hnss[236]+','+$
  hnss[230]+','+hnss[229]+','+hnss[210]+','+hnss[209]+','+hnss[141]+','+hnss[55]+ ', , , ,'
printf,12, ', , , ,'+hnss[63]+','+hnss[64]+','+hnss[113]+','+hnss[222]+','+hnss[223]+','+hnss[224]+','+hnss[225]+','+$
  hnss[226]+','+hnss[227]+','+hnss[228]+','+hnss[207]+','+hnss[208]+','+hnss[104]+','+hnss[54]+','+hnss[53]+', , ,'
printf,12, ', , ,'+hnss[61]+','+hnss[62]+','+hnss[111]+','+hnss[112]+','+hnss[114]+','+hnss[200]+','+hnss[201]+','+$
  hnss[202]+','+hnss[203]+','+hnss[204]+','+hnss[205]+','+hnss[206]+','+hnss[103]+','+hnss[102]+','+$
  hnss[101]+','+hnss[52]+','+hnss[51]+', ,'
printf,12, ', ,'+hnss[191]+','+hnss[192]+','+hnss[71]+','+hnss[72]+','+hnss[73]+','+hnss[74]+','+hnss[75]+','+$
  hnss[131]+','+hnss[132]+','+hnss[133]+','+hnss[134]+','+hnss[135]+','+hnss[45]+','+hnss[44]+','+$
  hnss[43]+','+hnss[42]+','+hnss[41]+','+hnss[182]+','+hnss[181]+','
printf,12, ','+hnss[190]+', , , , , , , , , , , , , , , , , , , ,'+hnss[180]
close,12

;; leave tmp
popd

END


PRO spatcon, scinput, kdim, metric, dir_tmp, my_os, resfloat, scoutput
;; Spatial Convolution metrics by K.Riitters
;;
;; scinput: MSPA-compliant image
;; kdim: selected kernel size 
;; metric: selected metric (string)
;; dir_tmp: path to mspatmp
;; my_os: my_os
;; resfloat: output in float instead of default byte
;;
;; scoutput: output image

pushd, dir_tmp

case strlowCase(metric) of
 'p2':  mstr='81'
 'p22': mstr='77' 
 'p23': mstr='78' ;; pxy
 'sumd': mstr='74'
 'shannon': mstr='73'
 'lm': mstr='7'
 'lmms': mstr='7'  ; normally would be 6 but we fake a LM-run
endcase


;; we need these 3 files in tmp-directory: scsize.txt, scpars.txt, scinput (bsq-file) -> scoutput
sz=size(scinput,/dim) & kstr = strtrim(kdim,2)
;; for spatcon: rows first, then columns!
openw,1, 'scsize.txt'
printf,1,'nrows '+strtrim(sz[1],2)
printf,1,'ncols '+strtrim(sz[0],2)
close,1

openw,1, 'scpars.txt'
printf,1,'w ' + kstr
printf,1,'r ' + mstr
printf,1,'a 2'
printf,1,'h 1'
if mstr eq '78' then printf,1,'b 3' else printf,1,'b 0'
printf,1,'m 0'
if resfloat eq 1 then printf,1,'f 1' else printf,1,'f 0'
if metric eq 'lmms' then printf,1,'p 1'
if metric eq 'lm' then printf,1,'p 0'
;;printf,1,'z 0' z=0 is used as default
close,1

openw, 1, 'scinput' & writeu,1, scinput & close,1

;; setup spatcon
;; if lmms, we need to use the old spatcon (placed in the subdirectory 'orig'),
;; which outputs the three p2_x.bsq files that are needed by combinelpt
if metric eq 'lmms' then extra = 'orig' + path_sep() else extra = ''
IF my_os EQ 'windows' THEN BEGIN
  spatcon='..\spatcon\' + extra + 'spatcon64.exe' & file_copy, spatcon, 'spatcon.exe', /overwrite
ENDIF ELSE IF my_os EQ 'apple' THEN BEGIN
  spatcon='../spatcon/' + extra + 'spatcon_mac' & file_copy, spatcon, 'spatcon', /overwrite
ENDIF ELSE BEGIN
  spatcon='../spatcon/' + extra + 'spatcon_lin64' & file_copy, spatcon, 'spatcon', /overwrite
ENDELSE


;; run spatcon in tmp
IF my_os EQ 'windows' THEN spawn, 'spatcon.exe', log, / hide ELSE spawn, './spatcon', log

;; if NOT lm or lmms then get the result and clean up
;; when doing LM or LMMS (dominance) the intermediate files are processed further
if mstr ne '7' then begin
;;if metric ne 'lmms' then begin
  ;; get result
  scoutput = bytarr(sz(0),sz(1)) & scinput=0
  if resfloat eq 1 then scoutput=float(scoutput)
  openr, 1, 'scoutput' & readu,1, scoutput & close,1
    
endif 
popd

END

;########################################################################
;########################################################################
;########################################################################

;;=======================================================================
;;=======================================================================
;;;;        P R O C E S S I N G    E V E N T   H A N D L E R
;;=======================================================================
;;=======================================================================
PRO guidos_Processing, event
;; Purpose: handle the events selected in the Pre- and Processing menu
;; 
;; to find the related routine, search for ':  BEGIN
;;
;; ------------------ File menu -----------------------------------------
;; ------------------ Batch Process -------------------------------------
;;                   Objects
;; 'batch_accounting':   Batch accounting
;; 'batch_parcellation': Batch Fragmentation Parcellation
;;                  Pattern
;; 'batch_spa':          Batch SPA2/3/5/6
;; 'batch_mspa':         Batch MSPA
;; 'batch_lm':           Batch Spatcon LM
;; 'batch_p2':           Batch Spatcon P2
;; 'batch_p22':          Batch Spatcon P22
;; 'batch_p23':          Batch Spatcon P23
;; 'batch_shannon':      Batch Spatcon Shannon
;; 'batch_sumd':         Batch Spatcon SumD
;;                  Network
;; 'batch_mspanw':       Batch MSPA based NW: 'batch_mspaci', 'batch_nwcomp', 'batch_nlimp'
;; 'batch_ci':           Batch ConeforInputs
;;                 Fragmentation
;; 'batch_ent':          Batch Entropy (Index, Map)
;; 'batch_hmc':          Batch HMC (Index)
;; 'batch_cont':         Batch Contagion (Map)
;; 'batch_fos':          Batch FOS
;; 'batch_fad':          Batch FAD-Multiscale
;; 'batch_lmms':         Batch Dominance
;;                Distance
;; 'batch_eucldist':     Batch Euclidean Distance
;;                RP
;; 'batch_rss':          RP: Batch RSS
;;                Recode
;; 'batch_recode':       Batch Recode
;;
;;                Change
;; 'change':             Change: 'change_fos', 'change_fad', 'delta_lm', 'change_simple', 'change_morph' 
;; ----------------------------------------------------------------------
;; 'set_dd':               Set current data directory
;; 'compress_tif'          Search for and compress tif images
;;------------------ GUI switches ---------------------------------------
;; 'selsubregion':         zoom mode switch
;; 'disp_colors':          Select Colortable
;; 'mspa_param1':          mspa1 - FGconn
;; 'mspa_param2':          mspa2 - EdgeWidth
;; 'mspa_param3':          mspa3 - transition
;; 'mspa_param4':          mspa4 - intext
;; 'label_t1v':            division panel: threshold 1
;; 'label_t2v':            division panel: threshold 2
;; 'disp_range':           division panel: Divide switch
;; 'autostretch':          Autostretch switch
;; 'do_mspa_stats':      MSPA-statistics
;; 'do_label_groups':    Apply grouping of MSPA-core,fragmentation, distance, Cost range classes
;; ------------------ General Tools -------------------------------------
;; 'median':               Median
;; 'boxcar':               Boxcar
;; 'lee':                  Lee
;; 'sigma':                Sigma
;; 'hilbert':              Hilbert
;; 'user_def':             user-defined kernel
;; 'contrast':             Eq: Contrast 
;; 'histequal':            Eq: histogram Equalization
;; 'adapthistequal':       adaptive histequal
;; 'thresholding':         threshold
;; 'canny_gr':             Canny gradient
;; 'canny_df':             Canny difference
;; 'laplace':              Laplace
;; 'roberts':              Roberts
;; 'sobel':                Sobel
;; 'sharpen':              Sharpen
;; 'unsharp_mask':         unsharp_mask
;; 'skeleton':             Skeleton
;; 'morph':                Morphological playground
;; ---- General Tools -> Preprocessing ----------------------------------
;; 'mspainp_info':         Image Info button
;; 'mspainp_c2b':          Convert to Byte
;; 'mspainp_c2i':          Convert to Integer
;; 'mspainp_c2l':          Convert to LongInteger
;; 'mspainp_c2s':          Convert to single band
;; 'mspainp_c2ge':         Convert to GoogleEarth projection
;; 'mspainp_recode':       Recode image
;; 'mspainp_recodepixel':  Recode a given pixel
;; 'mspainp_recodeline':   Recode a line
;; 'mspainp_recoderoi':    Recode a ROI
;; 'mspainp_costmarker':   Setup costmarker image
;; 'mspainp_thresh':       Threshold for mspa
;; 'mspainp_group':        Grouping range for mspa 
;; 'mspainp_xset':         Set x to whatever for mspa
;; 'mspainp_invert21':     Invert 2->1 for mspa
;; 'mspainp_invert20':     Invert 2->0 for mspa
;; 'mspainp_invert10':     Invert 1->0 for mspa
;; 'mspainp_set20':        Set 2->0 for mspa
;; 'mspainp_set21':        Set 2->1 for mspa
;; 'mspainp_set10':        Set 1->0 for mspa
;; 'mspainp_set12':        Set 1->2 for mspa
;; 'mspainp_set01':        Set 0->1 for mspa
;; 'mspainp_set02':        Set 0->2 for mspa
;; 'mspainp_add1':         Add 1 byte  
;; 'mspainp_sub1':         Substract 1 byte
;;---------- General Tools -> GIS software ------------------------------
;; 'gdalterminal':         Start Gdal terminal
;; 'openev':               Start OpenEv
;; 'qgis':                 Start QGIS
;; 'original image':       Restore original image
;; 'switchcursor':         Switch the mouse cursor look
;;-------------- Image Analysis -----------------------------------------
;;                  Objects
;; 'accounting':           Accounting
;; 'frag_parcellation':    Fragmentation Parcellation
;; 'contortion':           Contortion
;;                  Pattern
;; 'spa':                  SP2/3/5/6
;; 'mspa':                 MSPA
;; 'mspatile':             MSPA-Tiling
;; 'kernel_lm':            Spatcon LM
;; 'kernel_p2':            Spatcon P2
;; 'kernel_p22':           Spatcon P22
;; 'kernel_p23':           Spatcon P23
;; 'kernel_shannon':       Spatcon Shannon
;; 'kernel_sumd':          Spatcon SumD
;;                  Network
;; 'nw_components':        Network components (MSPA core and bridges only)
;; 'nw_importance':        Importance of Nodes and Links
;; 'nw_nwconnect':         Component connectors
;; 'nw_cs22':              MSPA ConeforInputs
;;                 Fragmentation
;; 'frag_entropy':         Fragmentation Entropy (Index and Map)
;; 'frag_contagion':       Fragmentation Contagion (Map, Spatcon P22)
;; 'frag_hmc' -> 'distance_morph'
;; 'frag_fos':             FOS user-selected fragmentation scale
;; 'frag_fad':             FAD multiscale
;; 'lmms':                 Dominance = Multiscale LM
;;                 Distance
;; 'distance_morph':       Euclidean Distance map + HMC
;; 'distance_influence':   Influence zones, proximity and reconnect (also 'distance_proximity')
;;              Restoration Planner 
;; 'cost_fixed':           RP: Setup fixed BG-Resistance
;; 'cost_recode':          RP: Setup Resistance By Land Cover
;; 'cost_disres':          RP: Setup Resistance By Distance
;; 'cost_pixel':           RP: Setup Resistance By Pixel
;; 'cost_line':            RP: Setup Resistance By Line
;; 'cost_roi':             RP: Setup Resistance By ROI
;; 'cost_status':          RP: RSS - restoration status summary
;; 'change_rss':           RP: Change in RSS
;; 'cost_draw':            RP: draw a custom path
;; 'cost_reconnect':       RP: find optimum LCP
;; 'cost_restoration':     RP: find optimum Big 5
;; 'cost_map':             Cost Analysis A, AB
;;---------------  help menu --------------------------------------------
;; 'guidos_manual':      Start GTB manual 
;; 'mspa_guide':         Start MSPA guide
;; 'gt_changelog':       Show GTB changelog
;; 'gt_eula':            Show GTB EULA
;; 'news':               Show GTB-News
;; 'homepage':           Show GTB-homepage
;; 'check4updates':      Check for program/revision updates (also 'installgws')
;; 'productsheets':      Show GTB-Productsheets
;; 'about':              Show GTB summary info and 'about_system' for Bug Report
;;
;; get the info structure
Widget_Control, event.top, Get_UValue = info ;;;, / No_Copy

;; Set the undo button to UNDO and make it sensitive.
Widget_Control, info.w_undo, $
 Set_Value = 'Undo', Set_UValue = 'Redo', Sensitive = 1

;; Set the undo image to be the current process image.
* info.undo = * info.process
widget_control, / hourglass
* info.fr_undo = * info.fr_image
* info.undo_data_min = * info.data_min
* info.undo_data_max = * info.data_max
info.undo_datatype = info.datatype

;; get and store the color description before doing the next step
info.prev_disp_colors_id = info.disp_colors_id
info.prev_autostretch_id = info.autostretch_id
tvlct, r, g, b, / get
info.prev_r = r & info.prev_g = g & info.prev_b = b
info.prev_is_mspa = info.is_mspa
info.prev_is_fragm = info.is_fragm
info.prev_is_contort = info.is_contort
info.prev_is_cs22 = info.is_cs22
info.prev_is_cost = info.is_cost
info.prev_is_nw = info.is_nw
info.prev_is_nwconnect = info.is_nwconnect
info.prev_add_title = info.add_title
;;widget_control, info.w_lp12, sensitive = info.is_mspa


;; What kind of processing do you need?
Widget_Control, event.id, Get_UValue = eventValue
mev = 1  ;; motion events active; will be set to passive when tiling
eventValue2 = '' & ev = strlowCase(eventValue)

IF (ev eq 'batch_mspaci') OR (ev eq 'batch_nwcomp') OR (ev eq 'batch_nlimp') THEN BEGIN
  eventValue2 = ev & eventValue = 'batch_mspanw'
ENDIF

if strmid(ev,0,9) eq 'batch_spa' then begin
  eventValue2 = ev & eventValue = 'batch_spa'
ENDIF

if strmid(ev,0,6) eq 'median' then begin
  eventValue2 = ev & eventValue = 'median' 
endif

if strlen(ev) eq 7 and strmid(ev,0,6) eq 'boxcar' then begin
  eventValue2 = ev & eventValue = 'boxcar' 
endif

if strlen(ev) eq 4 and strmid(ev,0,3) eq 'lee' then begin
  eventValue2 = ev & eventValue = 'lee' 
endif

if strlen(ev) eq 13 and strmid(ev,0,12) eq 'unsharp_mask' then begin
  eventValue2 = ev & eventValue = 'unsharp_mask' 
endif

if strlen(ev) eq 11 and strmid(ev,0,10) eq 'contortion' then begin
  eventValue2 = ev & eventValue = 'contortion' 
endif

if strlen(ev) eq 18 and strmid(ev,0,18) eq 'distance_proximity' then begin
  eventValue2 = ev & eventValue = 'distance_influence'
endif

if ev eq 'frag_hmc' then begin
  eventValue2 = ev & eventValue = 'distance_morph'
endif

if strmid(ev,0,7) eq 'change_' then begin
  eventValue2 = ev & eventValue = 'change' 
endif

if strlen(ev) eq 15 and strmid(ev,0,12) eq 'frag_entropy' then begin
  eventValue2 = ev & eventValue = 'frag_entropy'
endif
if strlen(ev) eq 13 and strmid(ev,0,9) eq 'batch_ent' then begin
  eventValue2 = ev & eventValue = 'batch_ent'
endif

if strlen(ev) eq 11 and strmid(ev,0,8) eq 'cost_map' then begin
  eventValue2 = ev & eventValue = 'cost_map'
endif

if strlen(ev) eq 4 and strmid(ev,0,3) eq 'spa' then begin
  eventValue2 = ev & eventValue = 'spa'
endif

if strlen(ev) eq 12 and strmid(ev,0,8) eq 'homepage' then begin
  eventValue2 = ev & eventValue = 'homepage'
endif

if ev eq 'installgws' then begin
  eventValue2 = ev & eventValue = 'check4updates'
endif

if ev eq 'about_system' then begin
  eventValue2 = ev & eventValue = 'about'
endif
;;*****************************************************************************************************
;;*****************************************************************************************************
;;*****************************************************************************************************

CASE strlowCase(eventValue) OF
   'compress_tif':  BEGIN
      
      msg = 'Please select one, or more TIF-files for file compression:' + string(10b) + $
        'TIF-files, which are already compressed will be skipped.' + string(10b) + $
        'Uncompressed TIF-files will be: ' + string(10b) + $
        'a) renamed to: original filename + _orig.tif' + string(10b) + $
        'b) LZW-compressed with the original filename' + string(10b) + string(10b) + $
        'Note: GTB-generated files are always compressed.'
      res = dialog_message(msg, title = 'TIF-Compression tool', / information)

      ;; show file selector
      tit = 'Please select tif-file(s)'
      filters = [['*.tif;*.tiff', 'TIF', 'TIFF']]
      im_files = dialog_pickfile(Title = tit, get_path = path2file, $
        path = info.dir_data, default_extension = 'tif', / fix_filter, $
        / must_exist, / multiple_files, FILTER = filters)
      IF im_files[0] EQ '' THEN GOTO, fin ;; 'cancel' selected

      ;; test that the directory of the selected files has no sub-directories
      ;; this will also ensure no output file is opened in excel or thelike
      list = file_basename(im_files) & nr_im_files = n_elements(list)
      
      msg = 'Processing selected images for TIF-Compression, please wait...'
      progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
      progressBar -> Start
      okfile = 0

      for fidx = 0, nr_im_files-1 do begin
        
        counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
        ;; validate the input, if not skip it without message
        IF progressBar -> CheckCancel() THEN BEGIN
          res = Dialog_Message('TIF-Compression cancelled by user.')
          progressBar -> Destroy
          Obj_Destroy, progressBar
          GOTO, fin
        ENDIF

        ;; run gdalinfo; test if already compressed, then skip
        fname = im_files[fidx]
        IF info.my_os EQ 'windows' THEN BEGIN
          cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalinfo -noct "' + fname + '"'
        ENDIF ELSE BEGIN
          ;; test for/prefer sysgdal
          if info.sysgdal eq '' then begin
            cmd = info.dir_fwtools + 'gdalinfo -noct "' + fname + '"'
          endif else begin
            cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + fname + '"'
          endelse
        ENDELSE
        IF info.my_os EQ 'windows' THEN spawn, cmd, log, / hide ELSE spawn, cmd, log
        ;; find out if compress=lzw is present, if not then compress anyway
        log = strupcase(strtrim(log,2)) & q = where(strpos(log,'COMPRESSION=LZW') eq 0, ct)        
        IF ct GT 0 THEN GOTO, skipcompress ;; already LZW compressed, skip
        ;; a) backup/rename the original file 
        bname = file_basename(fname) ;; the original full file name
        extdot = strpos(bname,'.',/reverse_search)
        bnamesuffix = strmid(bname, extdot)
        fbckup = file_dirname(fname,/mark) + strmid(bname,0,extdot)+'_orig'+bnamesuffix
        file_move, fname, fbckup, /overwrite ;; write the backup file
 
        ;; b) compress the backupfile to the original filename
        ;; define gdal_translate
        IF info.my_os EQ 'windows' THEN BEGIN
          gtrans = info.windrive + ' & cd "' + info.dir_fwtools + '" & setfw.bat & gdal_translate -co ' + '"COMPRESS=LZW" '
        ENDIF ELSE BEGIN ;; linux/apple
          if strlen(info.sysgdal) gt 0 then $
            gtrans = 'unset LD_LIBRARY_PATH; gdal_translate -co ' + '"COMPRESS=LZW" ' else $
          gtrans = info.dir_fwtools + 'gdal_translate -co ' + '"COMPRESS=LZW" '
        ENDELSE
        gtrans = gtrans + '"' + fbckup + '" "'+ fname + '"'
        IF info.my_os EQ 'windows' THEN spawn, gtrans, log, / hide ELSE spawn, gtrans, log  
        okfile = okfile + 1       
        
        skipcompress:
        stepn = (fidx + 1.0)/nr_im_files * 100.0
        progressBar -> Update, stepn

      endfor
      progressBar -> Destroy
      Obj_Destroy, progressBar
      msg = 'TIF-Compression finished.' + string(10b) + $
        'Compressed files: ' + strtrim(okfile,2) + '/' + strtrim(nr_im_files,2)
      res = dialog_message(msg, title = 'TIF-Compression tool', / information)
      GOTO, fin

   END
   ;;*****************************************************************************************************

   ;; set current data directory
   'set_dd': BEGIN
     
     msg = 'Please select:' + string(10b) + $
       'Yes: to define a new default data directory' + string(10b) + $
       'No: to restore the default GTB data directory' + string(10b) + string(10b)
     res = dialog_message(msg, title = 'Set default data directory', / question)
     
     IF res EQ 'No' THEN BEGIN 
       ;; restore default GTB data dir
       dir_data = info.gtbdd_def ;; reset to the GTB standard data directory
       ;; assign and store the new data dir path
       save, dir_data, filename = info.dir_guidossub + 'gtbdd.sav'
       info.dir_data = dir_data
       info.add_title = ' - Default data directory: ' + dir_data      
     ENDIF ELSE BEGIN
       ;; define a new default data dir
       datapath = info.dir_data
       dir_data = dialog_pickfile(/directory, get_path = path2file, path = datapath, /must_exist, title = 'Select default data directory')
       IF dir_data EQ '' THEN GOTO, fin ;; cancel selected
       ;; assign and store the new data dir path
       save, dir_data, filename = info.dir_guidossub + 'gtbdd.sav'
       info.dir_data = dir_data
       info.add_title = ' - Default data directory: ' + dir_data
     ENDELSE
     
   END
   ;;*****************************************************************************************************


   ;;-----------------------------------------------------------------------
   ;;--------------  preprocessing menu ------------------------------------
   ;;-----------------------------------------------------------------------
   ;;*****************************************************************************************************
    
   'selsubregion':  BEGIN
      widget_control, info.w_selsubregion, get_value = ssr
      ;; user clicked on 'Zoom mode'
      ;; enable zoom specific settings and set button label to 'Quit zoom'
      IF ssr EQ 'Zoom Mode' THEN BEGIN
         info.selsubregion_id = 1
         ;; activate zoomfactor selector when in quicklook mode
         widget_control, info.w_zoomfac, sensitive = 1 - info.fullres
         widget_control, info.w_selsubregion, set_value = 'Quit Zoom'
         ;; disable motion events and enable button_events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 0
         widget_control, info.w_draw, Draw_Button_Events = 1
         ;; activate the set_zoom switch to inform that
         ;; we define a subregion
         info.set_zoom = 1 & info.scroll_x = 0 & info.scroll_y = 0
         ;;widget_control, info.w_lp12, sensitive = info.is_mspa
         ;; temporary set custom path switch to off to allow zooming
         if info.is_cost eq 3 then info.is_cost = 7
         if info.is_cost eq 9 then info.is_cost = 79
         widget_control, / hourglass
        GOTO, fin
      ENDIF ELSE BEGIN ;; set button label from 'Quit' back to 'Zoom mode'
         info.selsubregion_id = 0
         ;; deactivate zoomfactor selector
         widget_control, info.w_zoomfac, sensitive = 1
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode'
         ;; restore the prezoomed process image
         * info.process = * info.prezoomprocess
         ;; disable button and enable motion events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 1
         widget_control, info.w_draw, Draw_Button_Events = 0
         info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
         widget_control, / hourglass
      ENDELSE
   END
;;*****************************************************************************************************

   'disp_colors':  BEGIN
      clcl_set = event.index
      ctbl_old = info.disp_colors_id
      info.disp_colors_id = clcl_set

      CASE clcl_set OF

         0:BEGIN ;; grey
            info.ctbl = 0
         END
         1:BEGIN ;; rainbow
            info.ctbl = 39
         END
         2:BEGIN ;; temperature
            info.ctbl = 3
         END
         3:BEGIN ;; classification
            IF info.mspa_param3_id EQ 1b THEN $
             restore, info.dir_guidossub + 'mspacolorston.sav' ELSE $
             restore, info.dir_guidossub + 'mspacolorstoff.sav'
            tvlct, r, g, b
            info.ctbl = - 1 & info.autostretch_id = 0
         END
         4:BEGIN ;; distance
            restore, info.dir_guidossub + 'distcolors.sav'
            tvlct, r, g, b
            info.ctbl = - 1 & info.autostretch_id = 0
         END
         5:BEGIN ;; entropy
         restore, info.dir_guidossub + 'entropycolors.sav'
         tvlct, r, g, b
         info.ctbl = - 1 & info.autostretch_id = 0
         END
         6:BEGIN ;; contortion
         restore, info.dir_guidossub + 'contcolors.sav'
         tvlct, r, g, b
         info.ctbl = - 1 & info.autostretch_id = 0
         END
         7:BEGIN ;; LM
         restore, info.dir_guidossub + 'lmcolors.sav'
         tvlct, r, g, b
         info.ctbl = - 1 & info.autostretch_id = 0
         END
         8:BEGIN ;; FAD 6-class
           restore, info.dir_guidossub + 'fadcolors.sav'
           tvlct, r, g, b
           info.ctbl = - 1 & info.autostretch_id = 0
           ;; change add-title if needed
           pos = strpos(info.add_title,'(FOS-APP 2-class: ')
           IF pos EQ 1 THEN info.add_title = ' (FOS-APP 5-class: ' + strmid(info.add_title, 12)
           pos = strpos(info.add_title,'(FAD-APP 2-class: MultiScale summary)')
           IF pos EQ 1 THEN info.add_title = ' (FAD-APP 5-class: MultiScale summary)'           
         END       
         9:BEGIN ;; FAD 5-class
           restore, info.dir_guidossub + 'fadcolors5.sav'
           tvlct, r, g, b
           info.ctbl = - 1 & info.autostretch_id = 0
         END
         10:BEGIN ;; FAD-2class
           restore, info.dir_guidossub + 'fe47colors.sav'
           tvlct, r, g, b
           info.ctbl = - 1 & info.autostretch_id = 0
           pos = strpos(info.add_title,'(FOS-APP 5-class: ')
           IF pos EQ 1 THEN info.add_title = ' (FOS-APP 2-class: ' + strmid(info.add_title, 12)
           pos = strpos(info.add_title,'(FAD-APP 5-class: MultiScale summary)')
           IF pos EQ 1 THEN info.add_title = ' (FAD-APP 2-class: MultiScale summary)'
         END
         11:BEGIN ;; Resistance
           restore, info.dir_guidossub + 'resistcolors.sav'
           tvlct, r, g, b
           info.ctbl = - 1 & info.autostretch_id = 0                
         END
         12:BEGIN ;; user-defined
            ;; minimize Tlb and switch off interfering motion events
            widget_control, info.w_draw, Draw_Motion_Events = 0
            Widget_Control, Info.tlb, Iconify = 1

            tvlct, r_old, g_old, b_old, / get
            xpalette,  / block ;group = event.top, / block
            tvlct, r, g, b, /get
            tvlct, r, g, b
            ;; test if nothing was changed
            q = total(r_old-r) + total(g_old-g) + total(b_old-b)
            IF abs(q) LT 0.000001 THEN BEGIN
               ;; reset to the previous color setting in the panel
               widget_control, info.w_disp_colors, $
                 set_combobox_select = ctbl_old
               ;; bring Tlb back and motion events back
               Widget_Control, Info.tlb, Iconify = 0
               widget_control, info.w_draw, Draw_Motion_Events = 1
               GOTO, fin
            ENDIF
            info.ctbl = - 1 & info.autostretch_id = 0
            ;; bring Tlb back and motion events back
            Widget_Control, Info.tlb, Iconify = 0
            widget_control, info.w_draw, Draw_Motion_Events = 1
         END
         13:BEGIN ;; Save/Restore option
           msg = ['Please select:', '', 'Yes: save the current colortable (Note: the prefix ', $
            "       'GTBcolors_' will be added automatically)", '',$
            'No: load a GTB-generated colortable (GTBcolors_*.sav)','',$
            'Cancel: quit this interface']
           res = dialog_message(msg, title='Save/Restore a GTB-generated colortable (GTBcolors_*.sav)', /question, /cancel, /center)

           IF res EQ 'Yes' THEN BEGIN
             ;; save current colortable, use notion x_gtb to be GTB-specific
             ctbl_file = dialog_pickfile(Title = tit, get_path = path2file, file = 'GTBcolors_mycolors.sav', $
               path = info.dir_data, default_extension = 'sav', /fix_filter, $
               /write, /overwrite_prompt, filter = ['GTBcolors_*.sav'])
             ;; reset to the previous colortable
             info.disp_colors_id = ctbl_old
             widget_control, info.w_disp_colors, set_combobox_select = ctbl_old
             IF ctbl_file EQ '' THEN GOTO, fin ;; 'cancel' selected
             ;; verify the correct naming scheme
             fbn = file_basename(ctbl_file) & prefix = strmid(fbn,0,10)
             IF prefix NE 'GTBcolors_' THEN ctbl_file = file_dirname(ctbl_file) + info.os_sep + 'GTBcolors_' + fbn 
             tvlct, r_gtb, g_gtb, b_gtb, /get          
             save, r_gtb, g_gtb, b_gtb, filename = ctbl_file 
             msg = 'The colortable was saved as:' +string(10b) + ctbl_file    
             q = dialog_message(msg,/information) 
             GOTO, fin
           
           ENDIF ELSE IF res EQ 'No' THEN BEGIN
            ;; restore existing colortable           
            ctbl_file = dialog_pickfile(Title = tit, get_path = path2file, $
              path = info.dir_data, default_extension = 'sav', /fix_filter, $
              /must_exist, /read, filter = ['GTBcolors_*.sav'])
            IF ctbl_file EQ '' THEN BEGIN ;; 'cancel' selected
              ;; reset to the previously used colortable
              info.disp_colors_id = ctbl_old
              widget_control, info.w_disp_colors, set_combobox_select = ctbl_old
              GOTO, fin 
            ENDIF
            ;; add a test to see if the selected file has in fact the required .sav extension
            ;; if not it is not valid
            suffix = strmid(ctbl_file,3,/reverse)
            IF suffix NE '.sav' THEN BEGIN
              msg = 'Wrong file selected. Please select a ' +string(10b) + $
                'GTB-generated colortable (GTBcolors_*.sav)'
              res = dialog_message(msg,/error)             
              goto, fin
            ENDIF                     
            restore, ctbl_file
            ;; verify that the three exist and are valid
            q = total(size(r_gtb))+total(size(g_gtb))+total(size(b_gtb)) & q = fix(q)
            IF q NE 1542 THEN BEGIN
              ;; reset to the previously used colortable
              info.disp_colors_id = ctbl_old
              widget_control, info.w_disp_colors, set_combobox_select = ctbl_old
              msg = 'Invalid colortable detected. Please select a ' +string(10b) + $
                'GTB-generated colortable (GTBcolors_*.sav)'
              res = dialog_message(msg,/error)
              GOTO, fin
            ENDIF
            ;; all ok, now load the custom colors
            tvlct, r_gtb, g_gtb, b_gtb           
            ;; set to be in custom colortable
            info.disp_colors_id = 12
            info.ctbl = - 1 & info.autostretch_id = 0
            widget_control, info.w_disp_colors, set_combobox_select = info.disp_colors_id
            ;; set notification switch
            colorreset=1

           ENDIF ELSE BEGIN
             ;; Cancel selected, reset to the previously used colortable
             info.disp_colors_id = ctbl_old
             widget_control, info.w_disp_colors, set_combobox_select = ctbl_old
             GOTO, fin
           ENDELSE           
         END
      ENDCASE
      GOTO, redisplay
   END

;;*****************************************************************************************************

   ;; MSPA-Foreground Connectivity
   ;;======================
   'mspa_param1':  BEGIN 
      if info.is_dist or info.is_influ or info.is_cost GE 2 then begin ;; enforce 8-conn for dist, influence zone and proximity
        info.mspa_param1_id = 1
        widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id
               
        IF strpos(info.add_title,'%; tick FGConn to reset)') GT 0 THEN BEGIN 
          ;; reset to image for customLCP test
          * info.process = * info.nw_conns
          * info.fr_image = * info.process
          ;; verify that sav-file exists
          res = file_info(info.dir_tmp + 'customLCP.sav')
          IF res.exists EQ 0b THEN BEGIN
            msg = "Please first setup your image via either:" + string(10b) + $
                "'Add Custom Path' or 'Find Optimum Path'"
            res = dialog_message(msg, / error)
            GOTO, fin           
          ENDIF        
          restore, info.dir_tmp + 'customLCP.sav'
          info.add_title = inatit
          ;; reset custom path setup
          if info.is_cost eq 4 then info.is_cost = 3
          GOTO, contnormal
        
        ENDIF ELSE IF strpos(info.add_title,'FGConn for Path setup') GT 0 THEN BEGIN                       
            ;; test if marker image is defined already AND if label_groups is active
            testfile = info.dir_tmp + 'marker.sav' & res=file_info(testfile)
            ;;IF res.exists GT 0 AND info.do_label_groups_id EQ 1 THEN BEGIN
            IF res.exists GT 0 THEN BEGIN
              
              msg = 'Processing Restoration Path, please wait...'
              tit = 'Optimum Path'
              progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=tit)
              progressBar -> Start
              
              restore, testfile ;; the marker image
              res = file_info(info.dir_tmp + 'customLCP.sav')
              IF res.exists EQ 0b THEN BEGIN
                msg = "Please first setup your image via either:" + string(10b) + $
                  "'Add Custom Path' or 'Find Optimum Path'"
                res = dialog_message(msg, / error)
                GOTO, fin
              ENDIF
              restore, info.dir_tmp + 'customLCP.sav'
              ;; assign resistance image: FG-1, BG- BG-resist, missing=blocking! image0 = resistance map
              image0 = *info.extra & sz = size(image0)
              qm = where(image0 EQ 0b, ctqm, /l64) ;; missing pixels in original dimensions
              image0 = (image0 EQ 2b) * 150b ;; set FG-objects to gray
                            
              resist = *info.extra 
              ;; reassign resistance image: FG-1 for cost analysis
              q = where(resist eq 2b, /l64) & resist[q] = 1b & q = 0
                           
              tenlinkslength = intarr(2)
              progressBar -> Update, 3
                          
              pushd, info.dir_tmp                  
              ;; a) write out resistance mask with extended frame of 0b
              eew = 2  & eew2 = eew * 2
              ext = bytarr(sz[1] + eew2, sz[2] + eew2)
              ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = resist
              write_tiff,'mask.tif',ext, compression=1
              
              IF info.my_os EQ 'windows' THEN BEGIN
                ggeo='..\spatcon\ggeo64.exe'
                file_copy, ggeo, info.dir_tmp + 'ggeo.exe', /overwrite
              ENDIF ELSE IF info.my_os EQ 'apple' THEN BEGIN
                ggeo='../spatcon/ggeo_mac'
                file_copy, ggeo, info.dir_tmp + 'ggeo', /overwrite
              ENDIF ELSE BEGIN
                ggeo='../spatcon/ggeo_lin64'
                file_copy, ggeo, info.dir_tmp + 'ggeo', /overwrite
              ENDELSE             
              desc = 'GTB_RES, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
              desc2 = 'GTB_ISO, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'

              ;; prepare temporary output
              expense_t = 'EXP_' + c_size & statsfiletxt = 'restoration_' + c_size + '.txt'
              close, 11 & openw, 11, statsfiletxt 
              IF info.my_os EQ 'windows' THEN BEGIN
                printf, 11, format='(3x,4(a16), 2x,8(a18))', 'SIZE_A', 'SIZE_B', 'REST_PIX', $
                  'AVDIST_RP', expense_t, 'EFFIC', 'ECA_ORIG', 'ECA_NEW', 'DELTA_ECA', 'COH_ORIG', 'COH_NEW', 'DELTA_COH'
              ENDIF ELSE BEGIN
                printf, 11, format='(3x,4(a16), 2x,8(a17))', 'SIZE_A', 'SIZE_B', 'REST_PIX', $
                  'AVDIST_RP', expense_t, 'EFFIC', 'ECA_ORIG', 'ECA_NEW', 'DELTA_ECA', 'COH_ORIG', 'COH_NEW', 'DELTA_COH'
              ENDELSE              
              statsfile = 'restoration_' + c_size + '.csv'
              close,1 & openw, 1, statsfile, error=error
              IF (error NE 0) then begin
                msg = 'Please close your spreadsheet application, then try again.' + $
                  string(10b) + 'Returning...'
                res = dialog_message(msg, /information)
                close,1
                goto,fin
              ENDIF

              printf, 1, 'SIZE_A, SIZE_B, REST_PIX, AVDIST_RP,' + expense_t + $
                ', EFFIC, ECA_ORIG, ECA_NEW, DELTA_ECA, COH_ORIG, COH_NEW, DELTA_COH' 

              widget_control, / hourglass
              ;; setup marker maps
              ;; b) marker1 with extended frame of missing (3b)
              ext = temporary(ext)*0b + 3b
              ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = marker
              ;; use start object only
              q2b = where(ext eq 2b, ct_q2b, /l64)
              if ct_q2b gt 0 then ext(q2b) = 0b
              write_tiff,'marker1.tif', ext, compression=1

              ;; c) marker2 with extended frame of missing (3b)
              ext = temporary(ext)*0b + 3b
              ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = marker
              ;; use target object only
              q1b = where(ext eq 1b,ct_q1b, /l64)
              if ct_q1b gt 0 then ext(q1b) = 0b
              if ct_q2b gt 0 then ext(q2b) = 1b
              write_tiff,'marker2.tif', ext, compression=1
              
              ;; write out extended markers without missing
              ext = temporary(ext)*0b
              ext[q1b] = 1b & ext[q2b] = 1b
              write_tiff,'markers.tif', ext, compression=1 & ext = 0

              
              ;; get markers in normal dimensions
              q1b = where(marker eq 1b, /l64) & q2b = where(marker eq 2b, /l64) & marker = 0            
              progressBar -> Update, 10
             
              IF info.my_os EQ 'windows' THEN spawn, 'ggeo.exe', log, / hide ELSE spawn, './ggeo', log
               progressBar -> Update, 90

              ;; get cost map
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              cost = read_tiff('out.tif')
              cost = cost[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]
              ;; long 32
              micost = min(cost)
              mincost = round(micost/2.0)  ;, /l64)
              maxcost = max(cost)
              if ctqm gt 0 then maxcost=round((max((cost lt maxcost)*cost))/2.0) else maxcost=round(maxcost/2.0)
              ;; test if image is too large for long 32 processing
              if maxcost lt 0 then begin
                msg = 'Image is too large for current implementation.' + string(10b) + 'Returning.'
                res = dialog_message(msg, / information) & popd 
                progressBar -> Destroy
                Obj_Destroy, progressBar
                GOTO, fin
              endif

;              ;; get markers and least cost path
;              ;; 1) mark LCP in black
              lcp = read_tiff('lcp.tif')
              lcp = lcp[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]
              ;; get location of restore pixels
              lcp = where(lcp gt 0b, ct_lcp, /l64)
              
              ;; set up cost image for display, range 0-100 cost, objects 101, missing 102, lcp 103
              ;; convert ulong to long 32
              cost = round(temporary(cost)/2.0) ;, /l64)
              cost = BytScl(cost, min = mincost, max = maxcost, Top = 100)
              cost[q1b] = 101b & cost[q2b] = 101b
              cost[lcp] = 103b & if ctqm gt 0 then cost[qm] = 102b
              ;; save the image, use normalised colortable
              restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
              fname = 'restoration_' + c_size + '_AB_isochrone.tif'
              if info.is_geotiff eq 1 then begin
                write_tiff,fname, rotate(cost,7), description = desc2, geotiff = * info.geotiffinfo, red = r, green = g, blue = b, compression = 1
              endif else begin
                write_tiff,fname, rotate(cost,7), description = desc2, red = r, green = g, blue = b, compression=1
              endelse
              ;; back to MSPA-colors
              restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b
              ;; end cost
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              ;; get LCP total length restore pixels
              ;; total length is 2 pixels less because it starts/ends in the targets
              tenlinkslength[0] = ct_lcp - 2
              
              lbl_comp= * info.nw_ids
              h_comp_area = * info.nw_hnw             
              path = lbl_comp[lcp] & rp = where(path eq 0, restpix, /l64) & tenlinkslength[1] = restpix

              ;; get accumulated cost of those restore pixels
              ;; use the sum of the resitance values of the restore pixels along the LCP
              ;; cost image is the sum of A and B, so build the average to get the actual cost for the path
              expense = resist[lcp] & expense = long64(total(expense[rp]))

              ;; LCP starts in linka and ends in linkb
              ;; 2) find out if this path passes through other components
              ;; test for and add intermediate components
              h = histogram(path) & qintcomp = where(h GT 0)
              ;; remove background (0) and start/end comnponent
              linka = lbl_comp[q1b[0]] & linkb = lbl_comp[q2b[0]]
              q = where(qintcomp eq linka) & qintcomp[q] = 0
              q = where(qintcomp eq linkb) & qintcomp[q] = 0
              q = where(qintcomp gt 0, ct_qintcomp)
              if ct_qintcomp gt 0 then qintcomp = qintcomp[q]
              
              ;; overplot intermediate components, beige
              IF ct_qintcomp GT 0 THEN BEGIN
                FOR i = 0, ct_qintcomp - 1 DO BEGIN
                  q = where(lbl_comp EQ qintcomp(i), ct)
                  if ct gt 0 then image0[q] = 58b
                ENDFOR
              ENDIF             
              image0[q1b] = 105b & image0[q2b] = 176b ;; start (blue) / target (lightblue) component
              image0[lcp[rp]] = 33b  ;; overplot restore pixels in red in display image
              if ctqm gt 0 then image0[qm] = 129b ;; missing

              ;; save the image
              fname = 'restoration_' + c_size + '_AB.tif'
              if info.is_geotiff eq 1 then begin
                write_tiff,fname, rotate(image0,7), description = desc, geotiff = * info.geotiffinfo, red = r, green = g, blue = b, compression = 1
              endif else begin
                write_tiff,fname, rotate(image0,7), description = desc, red = r, green = g, blue = b, compression=1
              endelse
              
              ;; build average distance of restore pixels
              q = *info.morphdist & quality = mean(q[lcp[rp]]) & q = 0
              
              
              fg = image0 GT 0b & IF ctqm GT 0 THEN fg[qm] = 0b
              eew = 2  & eew2 = eew * 2
              ext = bytarr(sz[1] + eew2, sz[2] + eew2)
              ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = temporary(fg)
              lbl_comp = label_region(ext, / all, / ulong) & ext = 0
              hca = histogram(lbl_comp, / l64) & lbl_comp = 0
              pcnum = total(hca(1: * )^2, / double)

              ;;%-increase in DOC/Coherence
              ECA = sqrt(pcnum) & ECA_maxnew = ECA_max + restpix & delta_eca = ECA - ECA_orig
              DOC = ECA/ECA_maxnew*100.0
              gain = doc - doc_orig
              tenlinksimp = gain
              effic = delta_eca/float(expense)

              ;; calculate RAC
              data_area = float(sz[4]) - ctqm
              ;rac = ECA_maxnew / data_area * 100.0
              ;delta_rac = rac - RAC_orig       

              rowstr = strtrim(h_comp_area(linka), 2) + ',' + strtrim(h_comp_area(linkb), 2) + ',' + $
                strtrim(tenlinkslength(1), 2) + ',' + strtrim(quality,2) + ',' + strtrim(expense,2) + ',' + strtrim(effic,2)+ ',' + $
                strtrim(eca_orig,2) + ',' + strtrim(eca,2) + ',' + strtrim(delta_eca,2) + ',' + $
                strtrim(doc_orig,2) + ',' + strtrim(doc,2) + ',' + strtrim(tenlinksimp, 2)
              printf, 1, rowstr

              ;; add output for xdisplayfile
              IF info.my_os EQ 'windows' THEN BEGIN
                printf, 11, format = '(12(a20))', strtrim(h_comp_area(linka), 2), + strtrim(h_comp_area(linkb), 2), $
                  strtrim(tenlinkslength(1), 2), strtrim(quality,2), strtrim(expense,2), strtrim(effic,2), $
                  strtrim(eca_orig,2), strtrim(eca,2), strtrim(delta_eca,2), $
                  strtrim(doc_orig,2), strtrim(doc,2), strtrim(tenlinksimp, 2)                
              ENDIF ELSE BEGIN
                printf, 11, format = '(12(a17))', strtrim(h_comp_area(linka), 2), + strtrim(h_comp_area(linkb), 2), $
                  strtrim(tenlinkslength(1), 2), strtrim(quality,2), strtrim(expense,2), strtrim(effic,2), $
                  strtrim(eca_orig,2), strtrim(eca,2), strtrim(delta_eca,2), $
                  strtrim(doc_orig,2), strtrim(doc,2), strtrim(tenlinksimp, 2)              
              ENDELSE
              printf, 11, ''
              printf, 11, 'Note: '
              printf, 11, 'The analysis may include alternative, parallel pathways and bifurcations in the Background having the same isochrone value.'
              printf, 11, 'These features may lead to an increased number of: restore pixels (REST_PIX) and expense (' + expense_t + '), resulting in'
              printf, 11, 'a decrease in Efficiency (EFFIC), meaning the actual Efficiency may be higher.'
              printf, 11, 'Please verify the individual paths after saving the result.'
              close, 1, 11
             
             progressBar -> Destroy
             Obj_Destroy, progressBar

             tit = 'Reconnect object: ' + strtrim(linka, 2) + ' <-> ' + strtrim(linkb, 2)
             xdisplayfile, info.dir_tmp + statsfiletxt, title = tit, width = 230
             
             ;; delete intermediate LCP stuff no longer needed and potentially conflicting with
             ;; a subsequent analysis
             file_delete, 'marker.sav',/ allow_nonexistent, / quiet
             popd

             ;; add to title
             info.add_title = ' (' + tit + ', DELTA_COH: ' + strtrim(gain,2) + '%; tick FGConn to reset)'


             ;; reset zoom
             IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
               info.selsubregion_id = 0
               ;; deactivate zoomfactor selector
               widget_control, info.w_zoomfac, sensitive = 1
               widget_control, info.w_selsubregion, set_value = 'Zoom Mode'
               ;; restore the prezoomed process image
               * info.process = * info.prezoomprocess
               ;; disable button and enable motion events in w_draw
               widget_control, info.w_draw, Draw_Motion_Events = 1
               widget_control, info.w_draw, Draw_Button_Events = 0
               info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
             ENDIF


             ;; store stuff in the info structure
             info.autostretch_id = 0
             * info.process = temporary(image0)
             * info.fr_image = * info.process

             GOTO, contnormal

           
            ENDIF ELSE BEGIN
              ;; no marker image is defined right now
              ;; test if a LCP was done earlier
              testfile = info.dir_tmp + 'lcp_orig.sav' & res=file_info(testfile)
              IF res.exists GT 0 THEN BEGIN
                ;; restore the original proximity image
                restore, testfile
                im = * info.fr_image
                im[lcp] = lcp_orig
                * info.process = temporary(im)
                * info.fr_image = * info.process  
                file_delete,testfile,/quiet
                ;; Restore info.add_title
                z = info.add_title
                q = strpos(z,', RestorePixels')
                if q gt 0 then info.add_title = strmid(z,0,q)+')'
              ENDIF              
              
              if info.is_cost eq 2 then begin 
                ;; setup the marker image
                msg = 'The Reconnect Marker Image requires a 2-step setup: ' + string(10b) + $
                  'Step 1: define start object A (polygon)' + string(10b) + $
                  'Step 2: define target object B (polygon)' + string(10b) + string(10b) +$
                  'Note: ' + string(10b) + $
                  'move mouse pointer in and follow the instructions' + string(10b) + $
                  'below the viewport; zoom in if needed' + string(10b) + string(10b) + $
                'Please select: ' + string(10b) + $
                  'Yes: to setup the Reconnect Marker Image, or' + string(10b) + $
                  'No: to quit.'
                goto, markstart                              
              endif else if info.is_cost eq 3 or info.is_cost eq 9 then begin 
                msg = 'Draw the reconnect path using either:' + string(10b) + $
                  '- Left mouse button pressed (free-hand line), or' + string(10b) + $
                  '- Right mouse button pressed (straight line).'
                res = dialog_message(msg, title='Custom Path setup',/ information)
                widget_control, info.w_draw, Draw_Button_Events = 1 ;; enable click button events
                goto, fin            
              endif
              
            ENDELSE
                                    
        ENDIF ;; end of LCP call
      endif

      ;; get the currently selected option
      info.mspa_param1_id = (event.select EQ 1)

      ;; reset the statistics because they change with fgconn
      widget_control, info.w_mspa_stats, set_value = transpose(replicate('n/a', 14, 2))
      info.do_mspa_stats_id = 0b
      widget_control, info.w_do_mspa_stats, set_value = info.do_mspa_stats_id
      ;; check for change in FGconn when doing parcellation
      IF strpos(info.add_title,'Classes/Parcellation:' ) GT 0 THEN goto, redo_parc
      info.do_label_groups_id = 0b
      widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id
      if info.is_mspa eq 1b then goto, set2original else goto,fin
   END

   ;;*****************************************************************************************************


   ;; MSPA-Size
   ;;======================
   'mspa_param2':  BEGIN     
        ;; quit the zoom mode
        IF info.selsubregion_id EQ 1 THEN BEGIN 
         info.selsubregion_id = 0
         ;; deactivate zoomfactor selector
         widget_control, info.w_zoomfac, sensitive = 1
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode'
         ;; restore the prezoomed process image
         * info.process = * info.prezoomprocess
         ;; disable button and enable motion events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 1
         widget_control, info.w_draw, Draw_Button_Events = 0
         info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
       ENDIF
 
      if info.is_dist then begin
        widget_control, info.w_mspa_param2, set_combobox_select = 1
        goto,fin
      endif
      if event.index le 0 then begin ;; user-specified value, correct for wrong input and limit to 100 for mspa/contort
         x = ulong(abs(event.str)) & if x eq 0 then x = 1
         if info.is_mspa then x = x < 100 else x = x < 10000001
         newsize = strtrim(x,2)
         widget_control, info.w_mspa_param2, set_value = [newsize,'1','2','3','4','5','6','7','8','9','10']
      endif else begin ; user-selected value
         widget_control, event.id, get_value = val
         newsize = val(event.index)
      endelse

      ;; only do the following if the new size is different from the old size
      IF info.mspa_size_current EQ newsize THEN GOTO, skipnewsize
      
      ;; assign new old & current mspa_param2 value
      info.mspa_size_old = newsize & info.mspa_size_current = newsize & info.small_lt_old = newsize
      ;; reset the statistics because they change with size
      widget_control, info.w_mspa_stats, set_value = transpose(replicate('n/a', 14, 2))
      info.do_mspa_stats_id = 0b
      widget_control, info.w_do_mspa_stats, set_value = info.do_mspa_stats_id
      if info.is_influ then begin
        ;; unset checkmark after a change
        info.do_label_groups_id = 0
        widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id
        GOTO, influ_cont
      endif
      info.do_label_groups_id = 0b
      widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id
            
      ;; reload the original image
      ;if info.is_mspa eq 1b then goto, set2original else goto,fin
      if info.is_mspa or info.is_contort gt 0 then goto, set2original else goto,fin
      skipnewsize:
   END

   ;;*****************************************************************************************************


   ;; MSPA - transition
   ;;======================
   'mspa_param3':  BEGIN
      if info.is_dist or info.is_influ gt 0 then begin ;; enforce 8-conn for dist, influence zone and proximity
        info.mspa_param3_id = 1
        widget_control, info.w_mspa_param3, set_value = info.mspa_param3_id
        GOTO, fin
      endif
      ;; get the currently selected option
      info.mspa_param3_id = (event.select EQ 1)
      ;; skip if not MSPA
      if info.is_mspa eq 0b then goto,fin
      ;; set to correct colortable and re-display

      IF info.disp_colors_id EQ 3 THEN BEGIN
         IF info.mspa_param3_id EQ 1b THEN $
          restore, info.dir_guidossub + 'mspacolorston.sav' ELSE $
          restore, info.dir_guidossub + 'mspacolorstoff.sav'
         tvlct, r, g, b
         info.ctbl = - 1 & info.disp_colors_id = 3
      ENDIF

      ;; reset the statistics because they change with transition
;      widget_control, info.w_mspa_stats, set_value = transpose(replicate('n/a', 14, 2))
;      info.do_mspa_stats_id = 0b
;      widget_control, info.w_do_mspa_stats, set_value = info.do_mspa_stats_id

      ;; update the title line if necessary
      IF info.is_mspa EQ 1 THEN BEGIN
         tmp4conn = ['8', '4']
         c_FGconn = tmp4conn(1 - info.mspa_param1_id)
         eew = info.mspa_size_current
         c_trans = strtrim(fix(info.mspa_param3_id), 2) & c_intext = strtrim(fix(info.mspa_param4_id), 2)
         z = info.add_title & z = strpos(z, ', FG_area: ')
         c_FG = strmid(info.add_title,z)
         info.add_title = ' (MSPA: ' + c_FGconn + '_' + eew + '_' + c_trans + '_' + c_intext + c_FG
      ENDIF
      GOTO, redisplay
   END

   ;;*****************************************************************************************************


   ;; MSPA - intext
   ;;===================
   'mspa_param4':  BEGIN
      ;; test for P2, P22, P23
      if (info.is_fragm GT 1 and info.is_fragm LT 3) then begin
        ;; switch off label groups so we start from the original spatcon image
        if info.do_label_groups_id eq 1 then begin
          info.do_label_groups_id = 0b
          widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id
        endif        
        ;; test the currently selected Intext option
        info.mspa_param4_id = (event.select EQ 1)
        if info.mspa_param4_id EQ 0 then begin ;; remove FG mask/restore original spatcon image
          restore, info.dir_tmp + 'mask.sav' & * info.nw_ids = im
        endif else begin ;; apply FG mask
          restore, info.dir_tmp + 'mask.sav'
          im[BGmask] = 101b 
          if ctmiss gt 0 then im[qmiss] = 102b
          xx = * info.nw_ids & xx[BGmask] = 101b & if ctmiss gt 0 then xx[qmiss] = 102b & * info.nw_ids = temporary(xx)                   
          ;; if in zoom mode, quit zoom mode
        endelse

        IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
          info.selsubregion_id = 0
          ;; deactivate zoomfactor selector
          widget_control, info.w_zoomfac, sensitive = 1
          widget_control, info.w_selsubregion, set_value = 'Zoom Mode'
          ;; restore the prezoomed process image
          * info.process = * info.prezoomprocess
          ;; disable button and enable motion events in w_draw
          widget_control, info.w_draw, Draw_Motion_Events = 1
          widget_control, info.w_draw, Draw_Button_Events = 0
          info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
        ENDIF

        ;; re-assign all images
        * info.process = temporary(im)
        * info.fr_image = * info.process     
        GOTO, contnormal
      ENDIF

      
      
      if info.is_dist or info.is_influ gt 0 then begin 
        info.mspa_param4_id = 1 ;; enforce 8-conn for dist, influence zone and proximity
        widget_control, info.w_mspa_param4, set_value = info.mspa_param4_id
        ;; test for barplot call
        IF strpos(info.add_title,'Intext for barplot') GT 0 THEN BEGIN
          testfile='srgdeiwhgfdsckfldw'
          IF info.is_influ GT 0 THEN testfile=info.dir_tmp+'proxws.sav'
          res=file_info(testfile)
          IF res.exists GT 0 THEN BEGIN
            restore, testfile
            IF info.is_influ GT 0 THEN BEGIN
              ;; maximum proximity range to show is either xmax or the selected max range (yellow) 
              if proxmax eq 0 then dmax = xmax*1.1 else dmax = proxmax+2 
              
              a = barplot(duniq,yarr1,bottom_values=yarr0, fill_color='green', ytitle='CAG (min/max)', $
                xtitle='connector length [pixels]',window_title='Proximity: CAG range/distance',$
                yrange=[ymin,ymax*1.1], xrange=[0, dmax], title=tit,histogram=0,width=0.5)
                
              ;; overplot the median in yellow
              a = plot(duniq[1:*],yarr2[1:*],symbol='*',color='Yellow', linestyle='none',/overplot)
                         
              ;; overplot the maximum with a red star symbol so we can see also the distance values 
              ;; which are encountered only once along the watershed (if they are encountered only 
              ;; once then the barplot is not visible at this location because max and min are the same              
              a = plot(duniq[1:*],yarr1[1:*],symbol='+',color='Red', linestyle='none',/overplot)
;              a = text(xmax*0.7,ymax*0.9,'*: Median',/data,/current,color='gold')
              a = text(1,ymax*0.85,'*: Median',/data,/current,color='gold')
              a = text(1,ymax*0.95,maxstr,/data,/current,color='red')
              
              ;; make a new plot showing how often each distance value exists
              b = plot(duniq[1:*],yarr3[1:*],xrange=[0, dmax],ytitle='Frequency',$
                xtitle='connector length [pixels]',window_title='Proximity: Frequency/distance',$
                symbol='*',color='Blue',linestyle='none', $
                title='Number of times a given connector length exists on the watershed')                                          
              ;; provide info on how to view the proximity table
              fx2 = info.dir_tmp2 + file_basename(fx)             
              IF (file_info(fx2)).exists EQ 1b THEN BEGIN
                close, 9 & openu, 9, fx2, error = error & close,9
              ENDIF ELSE BEGIN ;; file does not exist
                error = 0
              ENDELSE
              if error ne 0 then begin  ;; file is blocked
                msg = 'The result can not be saved because your ' + string(10b) + $
                  'spreadsheet application is showing the file:' + string(10b) + file_basename(fx2) + string(10b) + string(10b) +$
                  'Please close your spreadsheet application' + string(10b) + 'Then run the process again.'
                res = dialog_message(msg, / error)
                GOTO, fin
              endif else begin
                file_copy, fx, fx2,/allow, /overwrite
              endelse
              msg = 'For further information please save the image ' + $
               'and then open the resulting comma-separated file in a spreadsheet application '  + $
               '(MS-Excel, LibreOffice, Numbers...).'
              res = dialog_message(msg, / information)                                                            
            ENDIF                                 
          ENDIF          
          
          IF info.is_dist GT 0 THEN BEGIN
            ;; open barplot images, already done in the EUCLdist section
            IF info.my_os EQ 'apple' THEN BEGIN
              spawn, 'open ' + info.dir_tmp + 'barplot_dist.png'
              spawn, 'open ' + info.dir_tmp + 'barplot_hmc.png'
            ENDIF ELSE IF info.my_os EQ 'windows' THEN BEGIN
              pushd, info.dir_tmp
              spawn, 'start barplot_dist.png', / nowait
              spawn, 'start barplot_hmc.png', / nowait
              popd
            ENDIF ELSE BEGIN ;; Linux
              IF strlen(info.xdgop) EQ 0 THEN BEGIN
                st = "Please install xdg-open to automatically" + $
                  "display barplots within GuidosToolbox."
                result = dialog_message(st, / information)
              ENDIF ELSE BEGIN
                spawn, info.xdgop + ' "' + info.dir_tmp + 'barplot_dist.png' + '"'
                spawn, info.xdgop + ' "' + info.dir_tmp + 'barplot_hmc.png' + '"'
              ENDELSE
            ENDELSE
          ENDIF         
          
        ENDIF        
             
        GOTO, fin
      ENDIF
      ;; get the currently selected option
      info.mspa_param4_id = (event.select EQ 1)
      info.do_label_groups_id = 0b
      widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id
      if info.is_mspa eq 1b then goto, set2original else goto,fin
   END

   ;;*****************************************************************************************************


   ;; Core groups, t1, t2
   ;;=======================
   'label_t1v':  BEGIN
      ;; the purpose of this event handler is to set the value for label_t1.
      if event.index le 0 then begin ;; user-specified value, correct for wrong input
        x = ulong(abs(event.str)) 
        if info.is_influ eq 0 then if x eq 0 then x = info.label_t2
        ;; constrain to meaningful maximum value for t1
        if info.is_mspa then x = x < 100000
        if info.is_contort then x = x < 500
        if info.is_fragm or info.is_dist or info.is_influ then x = x < 99
        info.label_t1 = x & newval = strtrim(info.label_t1,2)
        if info.is_mspa then widget_control, info.w_label_t1, set_value = [newval,'1000', '4500','10000']
        if info.is_cost eq 1 then begin
          t1 = info.costrange & t1=strtrim(t1[0:2],2)
          widget_control, info.w_label_t1, set_value = [newval,t1]
        endif
        if info.is_fragm then widget_control, info.w_label_t1, set_value = [newval,'10', '30','50']
        if info.is_contort eq 1 then widget_control, info.w_label_t1, set_value = [newval,'25', '50','100']
        if info.is_dist then widget_control, info.w_label_t1, set_value = [newval,'5', '10','15']
        if info.is_influ eq 1 then widget_control, info.w_label_t1, set_value = [newval,'0', '1','2', '3', '5']
        if info.is_influ eq 3 then widget_control, info.w_label_t1, set_value = [newval,'0', '1','2', '3', '5']
      endif else begin ; user-selected value
        widget_control, event.id, get_value = val
        info.label_t1 = val(event.index)
      endelse    
      if info.is_influ then begin
        ;; unset checkmark after a change and delete any potential marker.sav
        info.do_label_groups_id = 0
        widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id
        testfile = info.dir_tmp + 'marker.sav' & res=file_info(testfile)
        IF res.exists GT 0 THEN file_delete, testfile, / quiet
        GOTO, influ_cont  ;; no crosscheck needed for influence zone/proximity
      endif
      ;; cross-check with t2, ensure t1 < t2
      if info.label_t1 gt info.label_t2 then begin
        info.label_t1 = info.label_t2 & newval = strtrim(info.label_t1,2)
        if info.is_mspa then widget_control, info.w_label_t1, set_value = [newval,'1000', '4500','10000']
        if info.is_cost eq 1 then begin
          t1 = info.costrange & t1=strtrim(t1[0:2],2)
          widget_control, info.w_label_t1, set_value = [newval,t1]
        endif
        if info.is_fragm then widget_control, info.w_label_t1, set_value = [newval,'10', '30','50']
        if info.is_contort eq 1 then widget_control, info.w_label_t1, set_value = [newval,'25', '50','100']
        if info.is_dist then widget_control, info.w_label_t1, set_value = [newval,'5', '10','15']
      endif

      ;; if threshold has changed and label-groups is active: disable label-groups
      ;; we must reset to original in order to apply the new labels to the original image!
      if info.do_label_groups_id eq 1b then begin
        info.do_label_groups_id = 0
        widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id
        GOTO, label_group_reset        
      endif else goto,fin
   END

   ;;*****************************************************************************************************


   'label_t2v':  BEGIN
   ;; the purpose of this event handler is to set the label t2 value.
   if event.index le 0 then begin ;; user-specified value
     x = ulong(abs(event.str)) 
     if info.is_influ eq 0 then if x le 1 then x = info.label_t1 
     ;; constrain to meaningful maximum value
     if info.is_mspa then x = x < 500000
     if info.is_fragm then x = x < 99
     if info.is_contort then x = x < 10000
     if info.is_dist then x = x < 5000
     if info.is_influ eq 1 then x = x < 500
     if info.is_influ eq 3 then x = x < 1000
     IF strpos(info.add_title,'(Reconnect: ') GT 0 THEN x = 1 > x < 100
     info.label_t2 = x & newval = strtrim(info.label_t2,2)
     if info.is_mspa then widget_control, info.w_label_t2, set_value = [newval,'4600', '11000','25000']
     if info.is_fragm then widget_control, info.w_label_t2, set_value = [newval,'60', '70', '80']
     if info.is_cost eq 1 then begin
      t2 = info.costrange & t2=strtrim(t2[3:5],2)
      widget_control, info.w_label_t2, set_value = [newval,t2]
     endif
     if info.is_contort eq 1 then widget_control, info.w_label_t2, set_value = [newval,'300', '800', '2000']
     if info.is_dist then widget_control, info.w_label_t2, set_value = [newval,'20', '30', '50']
     if info.is_influ eq 1 then widget_control, info.w_label_t2, set_value = [newval,'0','5','10','15','20']
     if info.is_influ eq 3 then widget_control, info.w_label_t2, set_value = [newval,'0','5','10','20','50']
     IF strpos(info.add_title,'(Reconnect: ') GT 0 THEN widget_control, info.w_label_t2, set_value = [newval,'2','3','5','10','20']

   endif else begin
     widget_control, event.id, get_value = val
     info.label_t2 = val(event.index)
   endelse
   if info.is_influ then begin
     ;; unset checkmark after a change and delete any potential marker.sav file
     info.do_label_groups_id = 0
     widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id
     testfile = info.dir_tmp + 'marker.sav' & res=file_info(testfile)
     IF res.exists GT 0 THEN file_delete, testfile, / quiet
     GOTO, influ_cont  ;; no crosscheck needed for influence zone/proximity
   endif

   ;; cross-check with t1, ensure t1 < t2
   if info.label_t2 lt info.label_t1 then begin
     info.label_t2 = info.label_t1 & newval = strtrim(info.label_t2,2)
     if info.is_mspa then widget_control, info.w_label_t2, set_value = [newval,'4600', '11000','25000']
     if info.is_fragm then widget_control, info.w_label_t2, set_value = [newval,'60', '70', '80']
     if info.is_cost eq 1 then begin
      t2 = info.costrange & t2=strtrim(t2[3:5],2)
      widget_control, info.w_label_t2, set_value = [newval,t2]
     endif
     if info.is_contort eq 1 then widget_control, info.w_label_t2, set_value = [newval,'300', '800', '2000']
     if info.is_dist then widget_control, info.w_label_t2, set_value = [newval,'20', '30', '50']
   endif
   ;; if threshold has changed and label-groups is active: disable label-groups and reset to unlabeled
   ;; we must reset to original in order to apply the new labels to the original image!
   if info.do_label_groups_id eq 1b then begin
      info.do_label_groups_id = 0
      widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id
      GOTO, label_group_reset        
    endif else goto,fin
  END

  ;;*****************************************************************************************************


   ;; DATA DISPLAY RANGE
   ;;===================
   'disp_range':  BEGIN
      ;; get the currently selected option
;      widget_control, info.w_disp_range, get_value = range_set
;      IF info.disp_range_id EQ range_set THEN GOTO, fin ELSE $
;       info.disp_range_id = range_set
      temp = (event.select EQ 1)
      info.prev_disp_range_id = info.disp_range_id
      info.disp_range_id = temp
      norm = 100.0 / ( * info.data_max - * info.data_min)
      CASE info.disp_range_id OF
         1:BEGIN   ;; normalize the image data range
            ;; store the datatype before doing the normalization
            info.app_dtype = info.dtypes(size( * info.fr_image, / type))
            * info.fr_image = ( * info.fr_image - * info.data_min) * norm
            * info.process = ( * info.process - * info.data_min) * norm
         END

         0:BEGIN  ;; apparent values
            * info.fr_image = * info.fr_image / norm + * info.data_min
            * info.process = * info.process / norm + * info.data_min
            ;; reset to the datatype before the normalization

            CASE info.app_dtype OF
               'byte':BEGIN
                  * info.fr_image = byte(round( * info.fr_image))
                  * info.process = byte(round( * info.process))
               END
               'integer':BEGIN
                  * info.fr_image = fix(round( * info.fr_image))
                  * info.process = fix(round( * info.process))
               END
               'long integer':BEGIN
                  * info.fr_image = round( * info.fr_image)
                  * info.process = round( * info.process)
               END
               'unsigned integer':BEGIN
                  * info.fr_image = uint(round( * info.fr_image))
                  * info.process = uint(round( * info.process))
               END
               'unsigned long integer':BEGIN
                  * info.fr_image = ulong(round( * info.fr_image))
                  * info.process = ulong(round( * info.process))
               END
               ELSE: * info.fr_image = * info.fr_image
            ENDCASE
         END
      ENDCASE

      GOTO, redisplay
   END

   ;;*****************************************************************************************************


   ;; AUTOSTRETCH DATA
   ;;===================
   'autostretch':  BEGIN
      ;; store the previous and get the currently selected option
      temp = (event.select EQ 1)
      info.prev_autostretch_id = info.autostretch_id
      info.autostretch_id = temp
      GOTO, redisplay
   END



;;-----------------------------------------------------------------------
;;---------   tools menu ------------------------------------------------
;;-----------------------------------------------------------------------

   ;; *************  CONVOLUTION  *********************
   ;;--------------------------------------------------------------------
   ;;=============  MEDIAN  =============================
   'median':  BEGIN
      qqstr = strmid(eventValue2,6,2) & qq = fix(qqstr)
      widget_control, / hourglass
      * info.fr_image = Median( * info.fr_image, qq)
      info.add_title = ' (Median, Box ' + qqstr + ')'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
      info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END


   ;;=============  BOXCAR  =============================
   'boxcar':  BEGIN
      qqstr = strmid(eventValue2,6,1) & qq = fix(qqstr)
      widget_control, / hourglass
      * info.fr_image = smooth( * info.fr_image, qq, / Edge_Truncate)
      info.add_title = ' (Boxcar, Box ' + qqstr + ')'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
      info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0   
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;=============  LEE  =============================
   'lee':  BEGIN
      qqstr = strmid(eventValue2,3,1) & qq = fix(qqstr)
      widget_control, / hourglass
      * info.fr_image = leefilt( * info.fr_image, qq)
      info.add_title = ' (Lee, Box ' + qqstr + ')'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
      info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;=============  SIGMA  =============================
   'sigma':  BEGIN
     widget_control, / hourglass
      * info.fr_image = $
       sigma_filter( * info.fr_image, n_sigma = 1, radius = 2, / all)
      info.add_title = ' (Sigma)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
      info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive      
   END


   ;;=============  HILBERT  =============================
   'hilbert':  BEGIN
     widget_control, / hourglass
      * info.fr_image =  bytscl(hilbert( * info.fr_image, 1))
      info.add_title = ' (Hilbert)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
      info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;=============  USER-DEFINED  =============================
   'user_def':  BEGIN
      ;; define a pointer to the default kernel, 3x3
      kdim = 3 & def_kernel = replicate( - 1, kdim, kdim)
      def_kernel(kdim / 2, kdim / 2) = - (fix(total(def_kernel)) + 1)
      cancel = ptr_new(1b)
      selected_kernel = ptr_new(def_kernel)
      ;; get the kernel settings
      get_kernel, selected_kernel = selected_kernel, $
       cancel = cancel, Group_Leader = event.top
      ;; check if cancel was selected then do nothing else apply the
      ;; default or new kernel
      IF * cancel EQ 0b THEN BEGIN
         sk = size(*selected_kernel,/dim) & skmax = sk[0] > sk[1]
         sim = size(* info.fr_image,/dim) & simax = sim[0] < sim[1]
         if skmax gt simax then begin
           msg = 'Kernel dimension larger than x or y image dimension.' + string(10b) + 'Returning...'
           res = dialog_message(msg, / information)
           ptr_free, cancel & cancel = 0b
           ptr_free, selected_kernel & selected_kernel = 0b
           GOTO, fin
         endif
         widget_control, / hourglass
         * info.fr_image = $
          convol( * info.fr_image, * selected_kernel, / NAN, / center, $
                  / edge_truncate)
          
         info.add_title = ' (User-defined, kdim: ' + strtrim(sk[0],2) + 'x' + strtrim(sk[1],2) + ')'
         ;; reset the MSPA
         info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
         info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
         info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      ENDIF ELSE BEGIN  ;; cancel was selected
         ptr_free, cancel & cancel = 0b
         ptr_free, selected_kernel & selected_kernel = 0b
         GOTO, fin
      ENDELSE
      ;; free and delete the temporary pointers
      ptr_free, cancel & cancel = 0b
      ptr_free, selected_kernel & selected_kernel = 0b
   END



   ;; *************  EQUALIZATION  *********************
   ;;--------------------------------------------------------------------
   ;;=============  CONTRAST  =============================
   'contrast':  BEGIN
      ;; minimize Tlb and switch off interfering motion events
      widget_control, info.w_draw, Draw_Motion_Events = 0
      Widget_Control, Info.tlb, Iconify = 1
      ;; get the current colors cause this applet will use its own colortable
      tvlct, r, g, b, / get

      xcontrast_roi, * info.process, / block
      ;; get the result
      IF (file_info('x_result.sav')).exists EQ 1b THEN $
       restore, 'x_result.sav'
      file_delete, 'x_result.sav', / quiet
      IF n_elements(result) GT 1 THEN BEGIN
         * info.process = temporary(result)
         tmp = * info.fr_image
         ;; apply the stretching to fullres
         * info.fr_image = $
          BytScl(tmp, Top = xc_top, Max = xc_max, Min = xc_min)
         info.autostretch_id = 0 & tmp = 0
         info.add_title = ' (Contrast)'
         ;; reset to default greyscale settings
         loadct, 0 & info.ctbl = 0 & info.disp_colors_id = 0
         info.disp_range_id = 0
         ;; reset the MSPA
         info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
         info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
         info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      ENDIF ELSE BEGIN
         ;; put back the colors we were using
         tvlct, r, g, b
      ENDELSE

      ;; bring Tlb back and motion events back
      Widget_Control, Info.tlb, Iconify = 0
      widget_control, info.w_draw, Draw_Motion_Events = 1
   END

   ;;*****************************************************************************************************

   'histequal':  BEGIN
      * info.fr_image = hist_equal( * info.fr_image)
      info.add_title = ' (Histogram equalization)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
      info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'adapthistequal': BEGIN
      * info.fr_image = adapt_hist_equal( * info.fr_image)
      info.add_title = ' (Adaptive histogram equalization)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
      info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'thresholding':  BEGIN
      image0 = * info.fr_image
      ;; check if threshold has already been applied before
      q = where(image0 gt 0b and image0 lt 255b, ct, /l64)
      IF ct EQ 0 THEN BEGIN
         mess = 'Thresholding was already applied and can only '
         mess = mess + 'be performed once.' + string(10b) + $
                'Do you want to reload and threshold the original image?'
         res = $
          dialog_message(mess, / question)
         IF strlowcase(res) EQ 'yes' THEN BEGIN
            * info.fr_image = * info.orig_image
         ENDIF ELSE BEGIN
            GOTO, fin
         ENDELSE
      ENDIF

      ;; minimize Tlb and switch off interfering motion events
      widget_control, info.w_draw, Draw_Motion_Events = 0
      Widget_Control, Info.tlb, Iconify = 1
      ;; get the current colors cause this applet will use its own colortable
      tvlct, r, g, b, / get

      xthreshold_roi, * info.process, / block
      ;; get the result
      IF (file_info('x_result.sav')).exists EQ 1b THEN $
       restore, 'x_result.sav'
      file_delete, 'x_result.sav', / quiet
      IF n_elements(result) GT 1 THEN BEGIN
         * info.process = temporary(result)
         ;; apply the treshold to fullres
         tmp = * info.fr_image
         tmp = BytScl(tmp GE xt_min, Top = xt_top)
         * info.fr_image = temporary(tmp gt 0b)
         info.add_title =  ' (Threshold: ' + strtrim(xt_min,2) + " < FG)"
         ;; reset to default greyscale settings
         loadct, 0 & info.ctbl = 0 & info.disp_colors_id = 0
         info.autostretch_id = 1 & info.disp_range_id = 0
         ;; reset the MSPA
         info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
         info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
         info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      ENDIF ELSE BEGIN
         ;; put back the colors we were using
         tvlct, r, g, b
      ENDELSE

      ;; bring Tlb back and motion events back
      Widget_Control, Info.tlb, Iconify = 0
      widget_control, info.w_draw, Draw_Motion_Events = 1
   END

   ;; edge enhance options
   ;;--------------------------------------------------------------------
   'canny_gr':  BEGIN
      canny, * info.fr_image, 10, 10, 10, 10, 1, 1, 1, 1, gr, df
      * info.fr_image = temporary(gr)
      info.add_title = ' (Canny gradient)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
      info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'canny_df':  BEGIN
      canny, * info.fr_image, 10, 10, 10, 10, 1, 1, 1, 1, gr, df
      * info.fr_image = temporary(df)
      info.add_title = ' (Canny difference)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
      info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'laplace':  BEGIN
      * info.fr_image = laplace( * info.fr_image)
      info.add_title = ' (Laplace)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
      info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'roberts':  BEGIN
      * info.fr_image = roberts( * info.fr_image)
      info.add_title = ' (Roberts)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
      info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'sobel':  BEGIN
      * info.fr_image = sobel( * info.fr_image)
      info.add_title = ' (Sobel)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
      info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'sharpen':  BEGIN
      ;; define a pointer to the default kernel, 3x3
      kdim = 3 & def_kernel = replicate( - 1, kdim, kdim)
      def_kernel(kdim / 2, kdim / 2) = - (fix(total(def_kernel)) + 1)
      cancel = ptr_new(1b)
      selected_kernel = ptr_new(def_kernel)
      ;; get the kernel settings
      get_kernel, selected_kernel = selected_kernel, $
       cancel = cancel, Group_Leader = event.top
      ;; check if cancel was selected then do nothing else apply the
      ;; default or new kernel
      IF * cancel EQ 0b THEN BEGIN
         * info.fr_image = $
          sharpen( bytscl( * info.fr_image), kernel = * selected_kernel)
         info.add_title = ' (Sharpen)'
         ;; reset to default greyscale settings
         loadct, 0 & info.ctbl = 0 & info.disp_colors_id = 0
         info.autostretch_id = 1 & info.disp_range_id = 0
         ;; reset the MSPA
         info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
         info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
         info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      ENDIF ELSE BEGIN  ;; cancel was selected
         ptr_free, cancel & cancel = 0b
         ptr_free, selected_kernel & selected_kernel = 0b
         GOTO, fin
      ENDELSE

      ;; free and delete the temporary pointers
      ptr_free, cancel & cancel = 0b
      ptr_free, selected_kernel & selected_kernel = 0b
   END

   ;;*****************************************************************************************************

   'unsharp_mask':  BEGIN
      qqstr = strmid(eventValue2,12,1) & qq = fix(qqstr)
      * info.fr_image = Smooth( * info.fr_image, qq) - * info.fr_image
      info.add_title = ' (Unsharp, Box ' + qqstr +')'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
      info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'skeleton':  BEGIN
      * info.fr_image = bytscl(sobel( bytscl( * info.fr_image)) GE 254b)
      info.add_title = ' (Skeleton)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 
      info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;; morphological filters
   ;;--------------------------------------------------------------------
   'morph':  BEGIN
      ;; minimize Tlb and switch off interfering motion events
      widget_control, info.w_draw, Draw_Motion_Events = 0
      Widget_Control, Info.tlb, Iconify = 1
      ;; get the current colors cause this applet will use its own colortable
      tvlct, r, g, b, / get

      Xmorph_roi, * info.process, * info.fr_image, / binary, / block
      ;; check if morph was applied and get the result
      IF (file_info('x_result.sav')).exists EQ 1b THEN restore, 'x_result.sav'
      file_delete, 'x_result.sav', / quiet

      IF n_elements(result) GT 1 THEN BEGIN
         * info.process = temporary(result)
         ;; apply the treshold to fullres
         * info.fr_image = temporary(resultfr)
         info.add_title = ' (Morphological)'
         ;; reset to default greyscale settings
         loadct, 0 & info.ctbl = 0 & info.disp_colors_id = 0
         info.autostretch_id = 1 & info.disp_range_id = 0
         ;; reset the MSPA
         info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
         info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
         info.is_nw = 0 & info.is_cost = 0 & info.is_nwconnect = 0 & info.is_cs22 = 0 & info.is_fragm = 0
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      ENDIF ELSE BEGIN
         ;; put back the colors we were using
         tvlct, r, g, b
      ENDELSE

      ;; bring Tlb back and motion events back
      Widget_Control, Info.tlb, Iconify = 0
      widget_control, info.w_draw, Draw_Motion_Events = 1
   END

   ;;============================================================
   ;; prepare input image menu
   ;;============================================================
   'mspainp_info':  BEGIN
      sysinfofile:
      ;; show useful info: datatype, dimension, uniq image values, projection
      widget_control, info.w_draw, Draw_Motion_Events = 0
      fname = info.fname_input
      ;; use the guidos.png icon if no image has been loaded yet
      IF fname EQ '' THEN fname = info.dir_guidossub + 'guidos.jpg'
      fsuffix = strlowcase(strmid(fname, strlen(fname)-3))

      ;; we need upv (uniq pixel values) and dtype (datatype)
      if info.is_contort gt 0 then begin
        arr = * info.contort
      endif else if info.is_dist eq 1 then begin
        arr = * info.morphdist
      endif else if info.is_nw eq 1 or info.is_cost eq 1 or info.is_influ gt 0 then begin ;; info.is_influ eq 1
        arr = * info.nw_ids ;; nw_hnw,  nw_hnwb
      endif else if info.is_cs22 eq 1 then begin
        arr = * info.cs22_nodes
      endif else begin
        arr = * info.fr_image
      endelse
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

      mi = min(arr, / nan) & dtype = info.dtypes(size(arr, / type)) & nr_upv = 'n/a'
;      if info.is_cost gt 0 then begin
;        upv = 'not available for cost analysis'
;      endif else begin
        q = where(histogram( arr, /l64, min=mi) GT 0, nr_upv)
        upv = strtrim(q(0)+mi, 2)
        IF nr_upv GT 0 THEN FOR i = 1, n_elements(q) - 1 DO $
          upv = upv + ', ' + strtrim(q(i)+mi, 2)
        nr_upv = strtrim(nr_upv,2)
;      endelse
        
      zz = 'The *currently* loaded image has these attributes: '
      IF info.is_geotiff then begin
        projinfo = 'Projection name (EPSG code): ' + info.epsgname + ' (EPSG: ' + info.epsg + ')'
        zz = 'The *currently* loaded GeoTiff image has these attributes: '
      ENDIF
             
      ;; check for IDL or Envi file for which we can not provide gdalinfo
      IF fsuffix EQ 'sav' OR fsuffix EQ 'hdr' THEN BEGIN
         msg = $
          'A MSPA-compliant input image must be of datatype BYTE' + string(10b) + $
          'and must have only the following pixel values: ' + string(10b) + $
          'MANDATORY: Foreground: 2 byte, Background: 1 byte' + string(10b) + $
          ' OPTIONAL: Missing data: 0 byte' + string(10b) + ' ' + string(10b) + $
          zz + string(10b) + $
          '======================================================' + string(10b) + $
          'Datatype: ' + dtype + string(10b) + $
          'Number of bands: ' + strtrim(info.datalayers, 2) + string(10b) + $
          'Number of classes: ' + nr_upv + string(10b) + $
          'Unique pixel values: ' + upv
          IF info.is_geotiff then msg = msg + projinfo
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF

      ;; run gdalinfo
      IF info.my_os EQ 'windows' THEN BEGIN
         cmd = 'cd "' + info.dir_fwtools + $
               '" & setfw.bat & gdalinfo -noct "' + fname + '"'
      ENDIF ELSE BEGIN
         ;; test for/prefer sysgdal
         if info.sysgdal eq '' then begin
           cmd = info.dir_fwtools + 'gdalinfo -noct "' + fname + '"'
         endif else begin
           cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + fname + '"'
         endelse
      ENDELSE
      IF info.my_os EQ 'windows' THEN $
       spawn, cmd, log, / hide ELSE spawn, cmd, log

      ;; write all info to a text file and then display that
      tmp = info.dir_tmp + 'iminfo.txt'
      openw, 1, tmp
      printf, 1, 'A MSPA-compliant input image must be of datatype BYTE'
      printf, 1, 'and must have only the following pixel values: '
      printf, 1, 'MANDATORY: Foreground: 2 byte, Background: 1 byte'
      printf, 1, ' OPTIONAL: Missing data: 0 byte'
      printf, 1, ''
      printf, 1, zz
      printf, 1, '========================================================='
      printf, 1, 'Datatype: ' + dtype
      printf, 1, 'Number of bands: ' + strtrim(info.datalayers, 2)
      printf, 1, 'Number of classes: ' + nr_upv
      printf, 1, 'Unique pixel values: ' + upv
      IF info.is_geotiff then printf, 1, projinfo
      printf, 1, ''
      IF info.is_geotiff then begin
        printf, 1, 'Details of the *initially loaded* GeoTiff image (gdalinfo -noct): '
      ENDIF ELSE BEGIN
        printf, 1, 'Details of the *initially loaded* image (gdalinfo -noct): '
      ENDELSE
      printf, 1, '========================================================='
      FOR i = 0, n_elements(log) - 1 DO printf, 1, log(i)
      close, 1
      if eventValue2 eq 'about_system' then goto, sysinfofiledone
      
      xdisplayfile, tmp, title = 'Detailed image information (gdalinfo -noct): ', $
                    done_button = 'Close', / block, / modal, group = event.top
      file_delete, tmp, / quiet
      widget_control, info.w_draw, Draw_Motion_Events = 1
      GOTO, fin
   END

   ;;*****************************************************************************************************

   'mspainp_c2b':  BEGIN
     ;; get max-value of image and warn if larger than 255 or negative
     IF (* info.data_max gt 255.0) OR (* info.data_min lt 0.0) THEN BEGIN
       msg = "Image has negative values or larger than 255, Byte conversion aborted," + $
         string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     * info.fr_image = byte(* info.fr_image) & info.add_title = ' (Byte)'
     ;; reset the MSPA
     info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
     info.is_nw = 0 & info.is_nwconnect = 0 & info.is_cost = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
     widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'mspainp_c2i':  BEGIN
     ;; get max-value of image and warn if larger or smaller than 32768
     IF (* info.data_max gt 32768.0) OR (* info.data_min lt -32768.0) THEN BEGIN
       msg = "Image has values outside of [-32768, 32768]. Integer conversion aborted," + $
         string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     * info.fr_image = fix(round(* info.fr_image)) & info.add_title = ' (Integer)'
     ;; reset the MSPA
     info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
     info.is_nw = 0 & info.is_nwconnect = 0 & info.is_cost = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
     widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'mspainp_c2l':  BEGIN
     ;; get max-value of image and warn if larger or smaller than 32768
     IF (* info.data_max le 32768.0) AND (* info.data_min ge -32768.0) THEN BEGIN
       msg = "Image has values within [-32768, 32768]. Use Integer conversion instead," + $
         string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     * info.fr_image = round(* info.fr_image) & info.add_title = ' (Long)'
     ;; reset the MSPA
     info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
     info.is_nw = 0 & info.is_nwconnect = 0 & info.is_cost = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
     widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'mspainp_c2s':  BEGIN
      image0 = * info.fr_image & s = size(image0)
      IF s[0] EQ 3 THEN BEGIN ;; 3-dim image
         IF s[1] EQ 3 THEN BEGIN ;; 3 band image
            dim_pos = where(s EQ 3, /l64) & dim_pos = dim_pos(1)
            ;;remap true color images
            image0 = color_quan(image0, dim_pos, r, g, b, / map_all)
            tvlct, r, g, b & info.disp_colors_id = 12 & info.ctbl = - 1
         ENDIF ELSE BEGIN
            msg = 'Please provide a single-band image.' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information)
            GOTO, fin
         ENDELSE
      ENDIF ELSE IF s[0] EQ 2 THEN BEGIN
         info.ctbl = 0 & info.disp_colors_id = 0
      ENDIF ELSE BEGIN
         msg = 'Please provide a single-band image.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDELSE
      * info.fr_image = temporary(image0) & info.add_title = " (RGB -> Single Band)"
      info.autostretch_id = 0 & info.disp_range_id = 0
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
      info.is_nw = 0 & info.is_nwconnect = 0 & info.is_cost = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'mspainp_c2ge':  BEGIN   
     finp = info.fname_input    
     foutp = strpos(finp, '.', / reverse_search) & foutp = strmid(finp, 0, foutp) + '_EPSG4326.tif'
     ;; the output file must not exist and we must specify the s_srs, at least for this old version of gdalwarp...
     IF (file_info(foutp)).exists EQ 1b THEN file_delete, foutp, / quiet
     
     msg = "This option will try to reproject the geotiff image file:" + string(10b) + $
       finp + string(10b) + 'to EPSG 4326 (WGS84) to be compatible with Google Earth.' 
     res = dialog_message(msg, / information)
     widget_control, / hourglass
     
     IF info.my_os EQ 'windows' THEN BEGIN
       cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalwarp -t_srs EPSG:4326 -co "COMPRESS=LZW" "' + finp + '" "' + foutp + '"'
       spawn, cmd, / hide, /log_output, result, error_result
     ENDIF ELSE BEGIN ;; 
       cmd = info.dir_fwtools + 'gdalwarp -t_srs EPSG:4326 -co "COMPRESS=LZW" ' + finp + ' ' + foutp
       spawn, cmd, result, error_result
     ENDELSE
     
     IF (file_info(foutp)).exists EQ 1b THEN BEGIN
       msg = "The reprojected image was saved to the directory:" + string(10b) + $
         file_dirname(finp) + string(10b) + $
         'with the name: ' + string(10b) + $
         file_basename(foutp)+ string(10b) + string(10b) + $
         'You can now read it (File -> Read Image -> GeoTiff)' + string(10b) + $
         'for further processing and/or exporting the image as a' + string(10b) + $
         'Google Earth image overlay (File -> Save Image -> KML)' + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
     ENDIF ELSE BEGIN
        ;; something went wrong
        msg = 'Reprojecting to EPSG:4326 failed with this error: ' + string(10b)
        for i=0, n_elements(error_result)-1 do msg = msg + error_result[i] + string(10b)
        msg =  msg + 'Returning...'
        res = dialog_message(msg, / information)
     ENDELSE
     GOTO, fin

   END

   ;;*****************************************************************************************************

   'mspainp_recode':  BEGIN
      ;; open a table to allow re=assigning of byte values
      ;; this option is only available if the data is in byte format
      
      lc_recode:
      tmp = * info.fr_image
      q = where(histogram(tmp, /l64) GT 0, ct) & upv = byte(transpose([[q],[q]]))
      cancel = ptr_new(1b) & seltab = ptr_new(1b)
      IF eventValue EQ 'cost_recode' THEN tit = 'Recode: Class -> resistance' else tit = "Recode class values"
      ;; get the selected mapping
      pushd,info.dir_data
      get_xrecode, upv = upv, batch = 0, tit = tit, cancel = cancel, seltab=seltab, Group_Leader = event.top
      popd
      ;; check if cancel was selected then do nothing else apply the recoding table
      IF * cancel NE 0b THEN BEGIN
        ptr_free, cancel & cancel = 0b
        ptr_free, seltab & seltab = 0b
        GOTO, fin
      ENDIF
        
      psel = * seltab & ptr_free, seltab & seltab = 0b
      ptr_free, cancel & cancel = 0b
      
      ;; check if settings are ok for lc_recode
      IF eventValue EQ 'cost_recode' THEN BEGIN
        tt = reform(psel[0,*]) & msg = ''
        q = where(tt eq 1b, ctq1, /l64) & q = where(tt eq 2b, ctq2, /l64) & q = where(tt GT 100b, ctq3, /l64)
        tit = 'Restoration Planner Setup: assign land cover class specific resistance'
        IF ctq1 GT 0 AND ctq3 GT 0 THEN BEGIN
          msg = 'Resistance values of 1 or larger than 100 are not allowed.'
        ENDIF ELSE IF ctq1 GT 0 THEN BEGIN
          msg = 'Resistance values of 1 are not allowed.'
        ENDIF ELSE IF ctq3 GT 0 THEN BEGIN
          msg = 'Resistance values larger than 100 are not allowed.'
        ENDIF ELSE IF ctq2 EQ 0 THEN msg = 'Mandatory FG-objects with resistance = 2% are missing'
        
        If msg ne '' THEN BEGIN ;; incorrect setup
          msg = msg + string(10b) + string(10b) + $
          'Please assign the following resistance values:' + string(10b) + $
          '0: Blocking, can not be traversed (optional)' + string(10b) + $
          '2: Foreground (FG) objects, fixed at 2%' + string(10b) + $
          '[3, 100]: land cover specific Background (BG) resistance' + string(10b) + string(10b) + $
          'Note: resistance values of 1 or > 100 are not allowed.'
          res = dialog_message(msg, title=tit,/ error)
          GOTO, fin      
        ENDIF 
        info.is_cost = 0
      ENDIF ;; end of lc_recode

      ;; do the recoding
      pushd, info.dir_tmp
      ;; we need these 3 files in tmp-directory: recsize.txt, recode.txt, recinput (bsq-file) -> recoutput
      sz=size(tmp,/dim) & psel=rotate(psel,5)
      ;; for recode: rows first, then columns!
      openw,1, 'recsize.txt'
      printf,1,'nrows '+strtrim(sz[1],2)
      printf,1,'ncols '+strtrim(sz[0],2)
      close,1
      openw,1, 'recode.txt' & printf,1,psel & close,1
      openw, 1, 'recinput' & writeu,1, tmp & close,1

      ;; setup recode
      IF info.my_os EQ 'windows' THEN BEGIN
        recode='..\spatcon\recode64.exe' & file_copy, recode, 'recode.exe', /overwrite
      ENDIF ELSE IF info.my_os EQ 'apple' THEN BEGIN
        recode='../spatcon/recode_mac' & file_copy, recode, 'recode', /overwrite
      ENDIF ELSE BEGIN
        recode='../spatcon/recode_lin64' & file_copy, recode, 'recode', /overwrite
      ENDELSE


      ;; run recode in tmp
      IF info.my_os EQ 'windows' THEN spawn, 'recode.exe', log, / hide ELSE spawn, './recode', log

      ;; get result
      recoutput = temporary(tmp) * 0b
      openr, 1, 'recoutput' & readu,1, recoutput & close,1

      ;; empty dir_tmp and go back
      list = file_search() & nl = n_elements(list)
      if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
      popd

      * info.fr_image = temporary(recoutput) & info.add_title = ' (recode)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
      info.is_nw = 0 & info.is_nwconnect = 0 & info.is_cost = 0 & info.disp_range_id = 0 & info.is_dist = 0 & info.is_fragm = 0
      info.is_influ = 0 & info.selsubregion_id = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'mspainp_recodepixel':  BEGIN
     ;; this option is only available if the data is in byte format
     tit = 'Recode pixel setup:'
     IF info.datatype NE 'byte' THEN BEGIN
       msg = 'This option is only applicable for images with data type Byte.' + string(10b) + 'Returning...'
       res = dialog_message(msg, title = tit, / information)    
       GOTO, fin     
     ENDIF
     q = size(* info.fr_image,/dim) & xdim = q[0] & ydim = q[1]
     
     ;; if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF
     
     cancel = ptr_new(1b) & selx = ptr_new('orig') & sely = ptr_new('orig') & selval = ptr_new('orig')
     ;; get the location settings
     get_locset, title = tit, xdim = xdim, ydim = ydim, selx = selx, sely = sely, $
       selval = selval, cancel = cancel, Group_Leader = event.top
     ;; check if cancel was selected then do nothing else apply the selected settings
     IF * cancel EQ 1b THEN BEGIN ;; cancel was selected
       ptr_free, cancel & cancel = 0b
       ptr_free, selx & selx = 0b
       ptr_free, sely & sely = 0b
       ptr_free, selval & selval = 0b
       GOTO, fin
     ENDIF
     x = *selx & y = *sely & val = *selval
     ptr_free, cancel & cancel = 0b
     ptr_free, selx & selx = 0b
     ptr_free, sely & sely = 0b
     ptr_free, selval & selval = 0b
     ;; check if they were modified
     IF (x EQ 'orig') OR (y EQ 'orig') OR (val EQ 'orig') THEN BEGIN
       msg = '             *** Operation cancelled ***  ' + string(10b) + string(10b) + $
         'Please insert, and *** press the Enter key*** in each of the three fields for a given pixel:' + string(10b) +$
         'x-location;   y-location;   class value' + $
       string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, title = tit, / error)
       GOTO, fin
     ENDIF

     ;; convert coordinates to match the upside down display
     x = x - 1
     y = ydim - y
     val = byte(val + 0)

     ; assign
     image0 = * info.fr_image
     image0[x,y] = val

     * info.process = image0
     * info.fr_image = temporary(image0)
     
     ;; when big fullres image update accordingly
     IF info.bigim THEN BEGIN
       s = size( * info.process,/dim)
       * info.process = congrid(temporary( * info.process), s[0] / info.resfac, s[1] / info.resfac)
     ENDIF
     
     info.add_title = ' (recode pixel)'

   END


   ;;*****************************************************************************************************

   'mspainp_recodeline':  BEGIN
     ;; this option is only available if the data is in byte format
     tit = 'Recode line setup:'
     IF info.datatype NE 'byte' THEN BEGIN
       msg = 'This option is only applicable for images with data type Byte.' + string(10b) + 'Returning...'
       res = dialog_message(msg, title = tit, / information)
       GOTO, fin
     ENDIF
     q = size(* info.fr_image,/dim) & xdim = q[0] & ydim = q[1]

     ;; if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF
     
     info.is_cost = 9 & info.add_title = ' (recode line; tick FGConn for Path setup)'
     info.recline = 1

   END


   ;;*****************************************************************************************************

   'mspainp_recoderoi':  BEGIN
     ;; this option is only available if the data is in byte format
     IF info.datatype NE 'byte' THEN BEGIN
       tit = 'Recode ROI setup:'
       msg = 'This option is only applicable for images with data type Byte.' + string(10b) + 'Returning...'
       res = dialog_message(msg, title = tit, / information)
       GOTO, fin
     ENDIF
         
     ;; check if we are in zoom mode
     if info.selsubregion_id eq 1 then begin ;; we are in zoom mode
       ;;-------------------------------------------------------------------------
       ;; get the subset of the image without zoomfactor
       ;; constrain to be within the image dimensions
       z = * info.fr_image & zdim = size(z,/dim)
       x = info.x * info.resfac & y = info.y * info.resfac
       x01 = (x(1) + 1) < zdim[0] - 1 & y01 = (y(1) + 1) < zdim[1] - 1
       imageSubset = z[x(0):x01, y(0):y01]

       IF info.autostretch_id eq 1b THEN image0 = bytscl(imageSubset) ELSE image0 = imageSubset
       q = Size(image0, /Dimensions) & ydim = strtrim(q[1],2)
       tit = 'Define ROIs & quit window when done. NOTE: area/length measures are approximate.'
       mask = ROIMask(image0, title=tit, Indices=roiIndices)
       roi = where(mask eq 1b, ct_roi, /l64)
       if ct_roi eq 0 then GOTO, fin ;; nothing defined

       ;; let the user assign a resistance value for all those rois defined earlier
       image0 = imageSubset
       target = strtrim(indgen(256),2) & seltarg = target[0]
       cancel = ptr_new(1b) & seltarg = ptr_new(seltarg)
       ;; get the selected mapping
       get_roires, title = 'ROI -> new value', target = target, seltarg = seltarg, $
         cancel = cancel, Group_Leader = event.top

       ;; check if cancel was selected then do nothing else apply the selected settings
       IF * cancel EQ 0b THEN BEGIN
         * info.undo = * info.process
         * info.fr_undo = * info.fr_image
         * info.undo_data_min = * info.data_min
         * info.undo_data_max = * info.data_max
         info.undo_datatype = info.datatype

         selresist = * seltarg & ptr_free, seltarg & seltarg = 0b
         ptr_free, cancel & cancel = 0b
         ;; assign the selected value
         tt = strsplit(selresist,' - ',/extract) & tt = byte(tt[0]+0)
         image0[roi] = tt
         ;; put back into the full resolution image
         tt = * info.fr_image
         tt[x(0):x01, y(0):y01] = image0
         * info.fr_image = tt
       ENDIF ELSE BEGIN  ;; cancel was selected
         ptr_free, cancel & cancel = 0b
         ptr_free, seltarg & seltarg = 0b
         GOTO, fin
       ENDELSE

       ;; reset zoom
       IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
         info.selsubregion_id = 0
         ;; deactivate zoomfactor selector
         widget_control, info.w_zoomfac, sensitive = 1
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode'
         * info.process = * info.fr_image
         IF info.bigim THEN BEGIN
           s = size( * info.process,/dim)
           * info.process = congrid(temporary( * info.process), s[0] / info.resfac, s[1] / info.resfac)
         ENDIF
         ;; disable button and enable motion events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 1
         widget_control, info.w_draw, Draw_Button_Events = 0
         info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
       ENDIF

     ENDIF ELSE BEGIN ;; we are NOT in zoom mode
       ;;-------------------------------------------------------------------------
       IF info.autostretch_id eq 1b THEN image0 = bytscl(* info.fr_image) ELSE image0 = * info.fr_image
       q = Size(image0, /Dimensions) & ydim = strtrim(q[1],2)
       tit = 'Define ROIs & quit window when done. NOTE: area/length measures are approximate.'
       mask = ROIMask(image0, title=tit, Indices=roiIndices)
       roi = where(mask eq 1b, ct_roi, /l64)
       if ct_roi eq 0 then GOTO, fin ;; nothing defined

       ;; let the user assign a new value for all those rois defined earlier
       image0 = * info.fr_image
       target = strtrim(indgen(256),2) & seltarg = target[0]
       cancel = ptr_new(1b) & seltarg = ptr_new(seltarg)
       ;; get the selected mapping
       get_roires, title = 'ROI -> new value', target = target, seltarg = seltarg, $
         cancel = cancel, Group_Leader = event.top

       ;; check if cancel was selected then do nothing else apply the selected settings
       IF * cancel EQ 0b THEN BEGIN
         * info.undo = * info.process
         * info.fr_undo = * info.fr_image
         * info.undo_data_min = * info.data_min
         * info.undo_data_max = * info.data_max
         info.undo_datatype = info.datatype
         selresist = * seltarg & ptr_free, seltarg & seltarg = 0b
         ptr_free, cancel & cancel = 0b
         ;; assign the selected value
         tt = strsplit(selresist,' - ',/extract) & tt = byte(tt[0]+0)
         image0[roi] = tt
         * info.fr_image  = image0
       ENDIF ELSE BEGIN  ;; cancel was selected
         ptr_free, cancel & cancel = 0b
         ptr_free, seltarg & seltarg = 0b
         GOTO, fin
       ENDELSE
       ;; reset zoom
       IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
         info.selsubregion_id = 0
         ;; deactivate zoomfactor selector
         widget_control, info.w_zoomfac, sensitive = 1
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode'
         ;; restore the prezoomed process image
         * info.process = * info.prezoomprocess
         ;; disable button and enable motion events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 1
         widget_control, info.w_draw, Draw_Button_Events = 0
         info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
       ENDIF
     ENDELSE     
     info.add_title = ' (recode ROI)'
   END

   ;;*****************************************************************************************************

  'mspainp_costmarker':  BEGIN
     msg = 'The marker image requires a 3-step setup: ' + string(10b) + $
      'Step 1: define start object A (polygon/point, 1 byte)' + string(10b) + $
      'Step 2: define target object B (polygon/point, 2 byte)' + string(10b) + $
      'Step 3: define missing data (pixels, 3 byte)' + string(10b) + string(10b) + $
      'Note: ' + string(10b) + $
      '- move mouse pointer in and follow the instructions' + string(10b) + $
      '  below the viewport; zoom in if needed' + string(10b) + $
      '- step 1 is mandatory, step 2 and step 3 are optional' + string(10b) + $
      '- use Recode to merge different classes of missing data' + string(10b) + $
      '- the marker image will be saved to the default data directory' + string(10b) + string(10b) + $
      'Please select: ' + string(10b) + $
      'Yes: to setup marker image via this interface, or' + string(10b) + $
      'No: to quit: first recode or setup marker image in a different way'  
     markstart:    
     res = dialog_message(msg, title='Setup Marker Image: general information',/ question)
     IF res eq 'No' then GOTO, fin
     
     ;; if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF
     
     IF info.datatype NE 'byte' THEN BEGIN
       msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     
     ;; ok, let's start
     info.def_marker = 1

   END

   
  ;;*****************************************************************************************************

   'mspainp_thresh':  BEGIN
      IF info.datatype NE 'byte' THEN BEGIN
         msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      ;; we need at least pixels > 2 byte else there is no point doing this
      ct = total((* info.fr_image) GT 2b)
      IF ct LT 0.5 THEN BEGIN
         mess = 'No pixel values larger than 2 byte (= FG) found.' + string(10b) + $
                'Please proceed with the other Preprocessing options.' + string(10b) + 'Returning...'
         res = dialog_message(mess, / information)
         GOTO, fin
      ENDIF
      ;; we need at least 3 different values else there is no point doing this
      q = where(histogram( * info.fr_image, /l64) GT 0, ct)
      IF n_elements(q) LT 3 THEN BEGIN
         mess = 'Image has less than 3 uniq values.' + string(10b) + $
                'Please proceed with the other Preprocessing options.' + string(10b) + 'Returning...'
         res = dialog_message(mess, / information)
         GOTO, fin
      ENDIF

      ;; minimize Tlb and switch off interfering motion events
      widget_control, info.w_draw, Draw_Motion_Events = 0
      Widget_Control, Info.tlb, Iconify = 1
      ;; get the current colors cause this applet will use its own colortable
      tvlct, r, g, b, / get

      xthreshold_roi, * info.process, / block, $
                      title = "[BG -> threshold, FG: > threshold]"
      ;; get the result
      IF (file_info('x_result.sav')).exists EQ 1b THEN $
       restore, 'x_result.sav'
      file_delete, 'x_result.sav', / quiet
      IF n_elements(result) GT 1 THEN BEGIN
         ;; after thresholding pixels values are [0,255], set to fg/bg
         * info.process = (result EQ 255b) + 1b & result = 0b
         ;; apply the threshold to fullres
         tmp = * info.fr_image
         * info.fr_image = $
          ((BytScl(tmp GE xt_min, Top = xt_top)) EQ 255b) + 1b
         tt = strtrim(fix(xt_min), 2)
         info.add_title = ' (Threshold: ' + tt + "b < FG)" & tmp = 0
         ;; reset to default greyscale settings
         loadct, 0 & info.ctbl = 0 & info.disp_colors_id = 0
         info.autostretch_id = 1 & info.disp_range_id = 0
         ;; reset the MSPA
         info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b
         info.do_mspa_stats_id = 0 & info.is_nw = 0 & info.is_cost = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      ENDIF ELSE BEGIN
         ;; put back the colors we were using
         tvlct, r, g, b
      ENDELSE

      ;; bring Tlb and motion events back
      Widget_Control, Info.tlb, Iconify = 0
      widget_control, info.w_draw, Draw_Motion_Events = 1
   END

   ;;*****************************************************************************************************

   'mspainp_group':  BEGIN
      IF info.datatype NE 'byte' THEN BEGIN
         msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      ;; we need at least pixels values > 2 byte else there is no point doing this
      ct = total((* info.fr_image) GT 2b)
      IF ct LT 0.5 THEN BEGIN
         mess = 'No pixel values larger than 2 byte (= FG) found.' + string(10b) + $
                'Please proceed with the other Preprocessing options.' + string(10b) + 'Returning...'
         res = dialog_message(mess, / information)
         GOTO, fin
      ENDIF
      ;; we need at least 3 different values else there is no point doing this
      q = where(histogram( * info.fr_image, /l64) GT 0, ct)
      IF n_elements(q) LT 3 THEN BEGIN
         mess = 'Image has less than 3 uniq values.' + string(10b) + $
                'Please proceed with the other Preprocessing options.' + string(10b) + 'Returning...'
         res = dialog_message(mess, / information)
         GOTO, fin
      ENDIF

      ;; minimize Tlb and switch off interfering motion events
      widget_control, info.w_draw, Draw_Motion_Events = 0
      Widget_Control, Info.tlb, Iconify = 1
      ;; get the current colors cause this applet will use its own colortable
      tvlct, r, g, b, / get & xc_min='a'
      xcontrast_roi, * info.process, / block, mspagroup = 1, $
                     title = "Set [min -> ]max+1 to FG/BG/Missing"
      ;; get the result
      IF (file_info('x_result.sav')).exists EQ 1b THEN $
       restore, 'x_result.sav'
      file_delete, 'x_result.sav', / quiet
      IF size(xc_min, / type) NE 7 AND strtrim(xc_min,2) NE 'a' THEN BEGIN ;; apply was pressed
         ;; get the selected range and apply the mask
         mi = byte(xc_min) & str_mi = strtrim(fix(xc_min),2)
         ma = byte(xc_max) & str_ma = strtrim(fix(xc_max) - 1, 2)
         tt = ['Missing (0b)', 'BG (1b)', 'FG (2b)'] & tt = tt(mask)
         tmp = * info.process & q = where(tmp GE mi AND tmp LT ma, ct, /l64)
         IF ct GT 0 THEN BEGIN
            tmp(q) = mask & * info.process = temporary(tmp)
         ENDIF
         ;; apply to fullres
         tmp = * info.fr_image & q = where(tmp GE mi AND tmp LT ma, ct, /l64)
         IF ct GT 0 THEN BEGIN
            tmp(q) = mask & * info.fr_image = temporary(tmp)
            info.autostretch_id = 1
            info.add_title = ' ([' + str_mi + 'b, ' + str_ma + "b] -> " + tt + ')'
            ;; reset to default greyscale settings
            loadct, 0 & info.ctbl = 0 & info.disp_colors_id = 0
            info.disp_range_id = 0
            ;; reset the MSPA
            info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b
            info.do_mspa_stats_id = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
            widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
         ENDIF
         tmp = 0
      ENDIF ELSE BEGIN
         ;; put back the colors we were using
         tvlct, r, g, b
      ENDELSE

      ;; bring Tlb and motion events back
      Widget_Control, Info.tlb, Iconify = 0
      widget_control, info.w_draw, Draw_Motion_Events = 1
   END

   ;;*****************************************************************************************************

   'mspainp_xset':  BEGIN
      IF info.datatype NE 'byte' THEN BEGIN
         msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      ;; we need at least pixels values > 2 byte else there is no point doing this
      ct = total((* info.fr_image) GT 2b)
      IF ct LT 0.5 THEN BEGIN
         mess = 'No pixel values larger than 2 byte (= FG) found.' + string(10b) + $
                'Please proceed with the other Preprocessing options.' + string(10b) + 'Returning...'
         res = dialog_message(mess, / information)
         GOTO, fin
      ENDIF
      tmp = * info.fr_image
      q = where(histogram(tmp, /l64) GT 0, ct) & upv = strtrim(q, 2) & selpix = upv(0)
      target = ['Foreground (2b)', 'Background (1b)', 'Missing (0b)'] & seltarg = target(0)
      cancel = ptr_new(1b) & selpix = ptr_new(selpix) & seltarg = ptr_new(seltarg)
      ;; get the selected mapping
      get_xset, upv = upv, target = target, selpix = selpix, seltarg = seltarg, $
                cancel = cancel, Group_Leader = event.top
      ;; check if cancel was selected then do nothing else apply the
      ;; default or new kernel
      IF * cancel EQ 0b THEN BEGIN
         psel = * selpix & ptr_free, selpix & selpix = 0b
         ptar = * seltarg & ptr_free, seltarg & seltarg = 0b
         ptr_free, cancel & cancel = 0b
         info.add_title = ' (' + psel + "b -> " + ptar + ')'
         psel = byte(fix(psel)) & ptar = byte((2 - where(ptar eq target))[0])
         q = where(tmp EQ psel) & tmp(q) = ptar & * info.fr_image = temporary(tmp)
         ;; reset the MSPA
         info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
         info.is_nw = 0 & info.is_cost = 0 & info.disp_range_id = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      ENDIF ELSE BEGIN  ;; cancel was selected
         ptr_free, cancel & cancel = 0b
         ptr_free, selpix & selpix = 0b
         ptr_free, seltarg & seltarg = 0b
         GOTO, fin
      ENDELSE
   END


   ;;*****************************************************************************************************

   'mspainp_invert21':  BEGIN
      IF info.datatype NE 'byte' THEN BEGIN
         msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      tmp = * info.fr_image
      q2 = where(tmp EQ 2b, ct2, /l64) & q1 = where(tmp EQ 1b, ct1, /l64)
      IF ct2 GT 0 THEN tmp(q2) = 1b & q2 = 0b
      IF ct1 GT 0 THEN tmp(q1) = 2b & q1 = 0b
      * info.fr_image = temporary(tmp) & info.add_title = ' (Invert FG/BG)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
      info.is_nw = 0 & info.is_nwconnect = 0 & info.is_cost = 0 & info.autostretch_id = 1 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END
   
   ;;*****************************************************************************************************

   'mspainp_invert20':  BEGIN
      IF info.datatype NE 'byte' THEN BEGIN
         msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      tmp = * info.fr_image
      q2 = where(tmp EQ 2b, ct2, /l64) & q0 = where(tmp EQ 0b, ct0, /l64)
      IF ct2 GT 0 THEN tmp(q2) = 0b & q2 = 0b
      IF ct0 GT 0 THEN tmp(q0) = 2b & q0 = 0b
      * info.fr_image = temporary(tmp) & info.add_title = ' (Invert FG/Missing)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
      info.is_nw = 0 & info.is_nwconnect = 0 & info.is_cost = 0 & info.autostretch_id = 1 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END
   
   ;;*****************************************************************************************************

   'mspainp_invert10':  BEGIN
      IF info.datatype NE 'byte' THEN BEGIN
         msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      tmp = * info.fr_image
      q1 = where(tmp EQ 1b, ct1, /l64) & q0 = where(tmp EQ 0b, ct0, /l64)
      IF ct1 GT 0 THEN tmp(q1) = 0b & q1 = 0b
      IF ct0 GT 0 THEN tmp(q0) = 1b & q0 = 0b
      * info.fr_image = temporary(tmp) & info.add_title = ' (Invert BG/Missing)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
      info.is_nw = 0 & info.is_nwconnect = 0 & info.is_cost = 0 & info.autostretch_id = 1 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'mspainp_set20':  BEGIN
      IF info.datatype NE 'byte' THEN BEGIN
         msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      tmp = * info.fr_image
      q = where(tmp EQ 2b, ctq, /l64)
      IF ctq GT 0 THEN BEGIN
         tmp(q) = 0b & * info.fr_image = temporary(tmp)
         info.add_title = ' (2b -> Missing (0b))'
         ;; reset the MSPA
         info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
         info.is_nw = 0 & info.is_cost = 0 & info.autostretch_id = 1 & info.disp_range_id = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      ENDIF ELSE BEGIN
         msg = "No pixels values with 2 byte found." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         tmp = 0b
         GOTO, fin
      ENDELSE
   END
   
   ;;*****************************************************************************************************

   'mspainp_set21':  BEGIN
      IF info.datatype NE 'byte' THEN BEGIN
         msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      tmp = * info.fr_image
      q = where(tmp EQ 2b, ctq, /l64)
      IF ctq GT 0 THEN BEGIN
         tmp(q) = 1b & * info.fr_image = temporary(tmp)
         info.add_title = ' (2b -> BG (1b))'
         ;; reset the MSPA
         info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
         info.is_nw = 0 & info.is_cost = 0 & info.autostretch_id = 1 & info.disp_range_id = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      ENDIF ELSE BEGIN
         msg = "No pixels values with 2 byte found." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         tmp = 0b
         GOTO, fin
      ENDELSE
   END

   ;;*****************************************************************************************************

   'mspainp_set10':  BEGIN
      IF info.datatype NE 'byte' THEN BEGIN
         msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      tmp = * info.fr_image
      q = where(tmp EQ 1b, ctq, /l64)
      IF ctq GT 0 THEN BEGIN
         tmp(q) = 0b & * info.fr_image = temporary(tmp)
         info.add_title = ' (1b -> Missing (0b))'
         ;; reset the MSPA
         info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
         info.is_nw = 0 & info.is_cost = 0 & info.autostretch_id = 1 & info.disp_range_id = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      ENDIF ELSE BEGIN
         msg = "No pixels values with 1 byte found." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         tmp = 0b
         GOTO, fin
      ENDELSE
   END
   
   ;;*****************************************************************************************************

   'mspainp_set12':  BEGIN
      IF info.datatype NE 'byte' THEN BEGIN
         msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      tmp = * info.fr_image
      q = where(tmp EQ 1b, ctq, /l64)
      IF ctq GT 0 THEN BEGIN
         tmp(q) = 2b & * info.fr_image = temporary(tmp)
         info.add_title = ' (1b -> FG (2b))'
         ;; reset the MSPA
         info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
         info.is_nw = 0 & info.is_cost = 0 & info.autostretch_id = 1 & info.disp_range_id = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      ENDIF ELSE BEGIN
         msg = "No pixels values with 1 byte found." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         tmp = 0b
         GOTO, fin
      ENDELSE
   END

   ;;*****************************************************************************************************

   'mspainp_set01':  BEGIN
      IF info.datatype NE 'byte' THEN BEGIN
         msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      tmp = * info.fr_image
      q = where(tmp EQ 0b, ctq, /l64)
      IF ctq GT 0 THEN BEGIN
         tmp(q) = 1b & * info.fr_image = temporary(tmp)
         info.add_title = ' (0b -> BG (1b))'
         ;; reset the MSPA
         info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
         info.is_nw = 0 & info.is_cost = 0 & info.autostretch_id = 1 & info.disp_range_id = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      ENDIF ELSE BEGIN
         msg = "No pixels values with 0 byte found." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         tmp = 0b
         GOTO, fin
      ENDELSE
   END
   
   ;;*****************************************************************************************************

   'mspainp_set02':  BEGIN
      IF info.datatype NE 'byte' THEN BEGIN
         msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      tmp = * info.fr_image
      q = where(tmp EQ 0b, ctq, /l64)
      IF ctq GT 0 THEN BEGIN
         tmp(q) = 2b & * info.fr_image = temporary(tmp)
         info.add_title = ' (0b -> FG (2b))'
         ;; reset the MSPA
         info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
         info.is_nw = 0 & info.is_cost = 0 & info.autostretch_id = 1 & info.disp_range_id = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      ENDIF ELSE BEGIN
         msg = "No pixels values with 0 byte found." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         tmp = 0b
         GOTO, fin
      ENDELSE
   END

   ;;*****************************************************************************************************

   'mspainp_add1':  BEGIN
      IF info.datatype NE 'byte' THEN BEGIN
         msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      * info.fr_image = temporary( * info.fr_image) + 1b
      info.add_title = ' (Add 1 Byte)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
      info.is_nw = 0 & info.is_nwconnect = 0 & info.is_cost = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END

   ;;*****************************************************************************************************

   'mspainp_sub1':  BEGIN
      IF info.datatype NE 'byte' THEN BEGIN
         msg = "Please convert image datatype to 'byte'." + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      * info.fr_image = temporary( * info.fr_image) - 1b
      info.add_title = ' (Subtract 1 Byte)'
      ;; reset the MSPA
      info.is_mspa = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
      info.is_nw = 0 & info.is_nwconnect = 0 & info.is_cost = 0 & info.is_dist = 0 & info.is_influ = 0 & info.selsubregion_id = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
   END


   ;;============================================================
   ;; gis software menu
   ;;============================================================
   ;; gdal terminal
   'gdalterminal':  BEGIN
      IF info.my_os EQ 'windows' THEN BEGIN
         pushd, info.dir_fwtools       
         ;;spawn, '%WINDIR%\system32\cmd.exe /K setfw.bat'
         spawn, 'start_GTBterminal.bat'
         ;;spawn, 'startOSGeo4W.lnk'
         popd

      ENDIF ELSE IF info.my_os EQ 'linux' THEN BEGIN         
        ;;===================================================
         zz=file_basename(info.linterm)
         case zz of
          'konsole': begin
              pushd, info.dir_data              
              cmd = 'unset LD_LIBRARY_PATH; dbus-launch '+ info.linterm + ' -e sh -c "cd ' + info.dir_data + $
              ' echo; echo system gdal version: `gdalinfo --version`;echo available gdal-commands and more information at:;' + $
              'echo https://gdal.org/programs/index.html;' + $
              "echo; echo current directory: $PWD ;$SHELL" + '"&'
              spawn, cmd
              popd
            end
                        
          'xterm': begin            
              pushd, info.dir_data
              cmd = 'unset LD_LIBRARY_PATH; ' + info.linterm + ' -j -sb -sl 5000 -title ' + $
                '"https://gdal.org/programs/index.html" -e "' + $
                'echo ;echo system gdal version: `gdalinfo --version`;' + $
              'echo available gdal-commands and more information at:;' + $
              'echo https://gdal.org/programs/index.html; ' + $
              'echo; echo current directory: $PWD  ;$SHELL" &'
              spawn, cmd
              popd
            end
            
            else: begin             
              if zz eq 'gnome-terminal' or zz eq 'mate-terminal' then st=' -x sh -c "' else st=' -e sh -c "'
              pushd, info.dir_data
              cmd = 'unset LD_LIBRARY_PATH; ' + info.linterm + st + $
                'echo; echo system gdal version: `gdalinfo --version`;echo available gdal-commands and more information at:;' + $
                'echo https://gdal.org/programs/index.html;' + $
                "echo; echo current directory: $PWD  ;$SHELL" + '"&'
                spawn, cmd
              popd
            end          
         endcase
        

      ENDIF ELSE BEGIN ;; apple
      ;;===================================================
         pushd, info.dir_data
         spawn, info.dir_guidossub + 'startGTBterminal_mac.sh &'         
         popd
      ENDELSE

      GOTO, fin
   END

   ;;*****************************************************************************************************

   ;; Openev
   'openev':  BEGIN
      pushd, info.dir_guidos
      spawn, 'startOpenEV.lnk'
      popd
      GOTO, fin
   END

   ;;*****************************************************************************************************

   ;; QGIS
   'qgis':  BEGIN
      IF info.my_os EQ 'windows' THEN BEGIN
        pushd, file_dirname(info.qgis_exe)
        spawn, 'qgis.bat'
        popd
      ENDIF ELSE IF info.my_os EQ 'apple' THEN BEGIN
        pushd, info.dir_data
        spawn, 'open '+info.qgis_exe
        popd
      ENDIF ELSE BEGIN ;; linux
        IF strlen(info.qgis_exe) LT 2 THEN BEGIN
          msg = "Please start your Linux package manager. "  +  string(10b) + $
            "Then search for and install 'qgis' in order"  +  string(10b) + $
            "to use this versatile GIS program." +  string(10b) + 'Returning...'
          res = dialog_message(msg, / information)
          GOTO, fin
        ENDIF
        ;; first go to the data directory to open QGIS there
        pushd, info.dir_data
        spawn, info.qgis_exe + '&'
        popd
      ENDELSE
      GOTO, fin
   END
   
   ;;*****************************************************************************************************

   ;; original image
   'original image':  BEGIN
      set2original:
      ;; reset the image and the title
      * info.fr_image = * info.orig_image
      info.title = info.orig_image_title & info.add_title = ' '
      s = size(* info.orig_image)
      IF info.bigim THEN BEGIN
         * info.image0 = congrid( * info.fr_image, s(1) / info.resfac, s(2) / info.resfac)
         s = size( * info.image0)
      ENDIF ELSE * info.image0 = * info.fr_image

      * info.process = * info.image0
      ;; region
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      info.selsubregion_id = 0
      ;; colors
      info.ctbl = 0 & loadct, 0 & info.disp_colors_id = 0 & info.autostretch_id = 1
      ;; data range
      info.disp_range_id = 0

      ;; test for original MSPA image
      IF info.my_os EQ 'windows' THEN BEGIN
        cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalinfo -noct "' + $
          info.fname_input + '"'
      ENDIF ELSE BEGIN
        if strlen(info.sysgdal) gt 0 then $
          cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + info.fname_input + '"' else $
          cmd = info.dir_fwtools + 'gdalinfo -noct "' + info.fname_input + '"'
      ENDELSE
      IF info.my_os EQ 'windows' THEN spawn, cmd, log, / hide ELSE spawn, cmd, log & q = log[0]

      ;; test for watermark
      ;; the old way up to 2.701
      q=where(strmid(log,0,27) eq "  TIFFTAG_SOFTWARE=JRC MSPA") & q=q[0]
      if q gt 0 then begin
        q=log(q) & res=strsplit(q,' ',/extract,count=nx)
        if nx eq 4 then newimis_mspa=res(nx-1)
      endif
      ;; the new way from 2.702
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_MSP") & q=q[0] 
      if q gt 0 then begin
        q=log(q) & res=strsplit(q,' ',/extract,count=nx)
        if nx eq 3 then newimis_mspa=res(nx-1)
      endif
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_FAD") & q=q[0] & if q gt 0 then newimis_fad = 1
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_FOS") & q=q[0] & if q gt 0 then newimis_fos = 1
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_SPA") & q=q[0] & if q gt 0 then newimis_spa = 1
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_ACC") & q=q[0] & if q gt 0 then newimis_acc = 1
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_LM,") & q=q[0] & if q gt 0 then newimis_lm = 1
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_EUC") & q=q[0] & if q gt 0 then newimis_dist = 1
      q=where(strmid(log,0,33) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_P2") & q=q[0] & if q gt 0 then newimis_P222 = 1
      q=where(strmid(log,0,35) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_DRES") & q=q[0] & if q gt 0 then newimis_disres = 1
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_RES") & q=q[0] & if q gt 0 then newimis_res = 1
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_ISO") & q=q[0] & if q gt 0 then newimis_cos = 1

      * info.prezoomprocess = * info.image0
      * info.subimage = * info.image0
      info.xsize = s(1)
      info.ysize = s(2)

      widget_control, info.TLB, tlb_set_title = info.title
      info.set_zoom = 0
      info.add_title = ' '

      ;; reset the MSPA
      info.is_nw = 0 & info.is_nwconnect = 0 & info.is_cost = 0 & info.is_cs22 = 0 & * info.cs22_nodes = * info.image0
      * info.cs22_conn = * info.image0 & * info.nw_ids = * info.image0     
      widget_control, info.w_mspa_param1, / sensitive       
      if info.is_contort eq 0 and n_elements(do_influ) eq 0 then info.small_lt_old = -1
      info.is_mspa = 0 & info.is_fragm = 0 & info.is_dist = 0 & info.is_influ = 0
      if info.is_contort gt 0 then begin
        do_contort=1
        info.is_contort = 0
      endif
           
      zn = 0
      info.mspa_stats_show = 0b 
      info.do_mspa_stats_id = 0 & info.cs22_nr_core = 0 & info.do_label_groups_id = 0
      widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id
      if eventValue eq 'Original Image' then begin
        info.mspa_param1_id = 1b & widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id
        ;; set edgewidth to 1
        info.mspa_size_current = '1'
        widget_control, info.w_mspa_param2, set_value = ['x','1','2','3','4','5','6','7','8','9','10']
        widget_control, info.w_mspa_param2, set_combobox_select = 1
        info.autostretch_id = 0

        ;; when restoring a MSPA image
        if (size(newimis_mspa))[2] eq 1 then begin
          ;; extract and set MSPA settings
          z=strsplit(newimis_mspa, '_', /extract, count=zn)
          if zn eq 4 then begin
            m4=fix(z[zn-1]) & m3=fix(z[zn-2]) & m2=z[zn-3] & m1=fix(z[zn-4])
            info.mspa_param1_id = (m1 eq 8) & info.mspa_param3_id = m3 & info.mspa_param4_id = m4
            widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id, sensitive = 1
            widget_control, info.w_mspa_param3, set_value = info.mspa_param3_id, sensitive = 1
            widget_control, info.w_mspa_param4, set_value = info.mspa_param4_id, sensitive = 1
            widget_control, info.w_mspa_param2, set_combobox_select = 0, sensitive = 1
            widget_control, info.w_mspa_param2, set_value = [m2,'1','2','3','4','5','6','7','8','9','10']
            info.mspa_stats_show = 1b & info.is_mspa = 1 & info.mspa_size_current = m2
            
            info.disp_colors_id = 3 & info.ctbl = - 1
            IF info.mspa_param3_id EQ 1b THEN $
              restore, info.dir_guidossub + 'mspacolorston.sav' ELSE $
              restore, info.dir_guidossub + 'mspacolorstoff.sav'
            tvlct, r, g, b                       
          endif
        endif
        if (size(newimis_acc))[2] eq 1 OR (size(newimis_spa))[2] eq 1 OR (size(newimis_res))[2] eq 1 then begin
          info.disp_colors_id = 3 & info.ctbl = - 1
        endif
        if (size(newimis_dist))[2] eq 1 then begin
          info.disp_colors_id = 4 & info.ctbl = - 1
          restore, info.dir_guidossub + 'distcolors.sav' & tvlct, r, g, b
        endif
        if (size(newimis_disres))[2] eq 1 then begin
          info.disp_colors_id = 10 & info.ctbl = - 1 
          restore, info.dir_guidossub + 'resistcolors.sav' & tvlct, r, g, b
        endif
        if (size(newimis_p222))[2] eq 1  eq 1 OR (size(newimis_cos))[2] eq 1 then begin
          info.disp_colors_id = 5 & info.ctbl = - 1 
          restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
        endif
        if (size(newimis_fad))[2] eq 1 OR (size(newimis_fos))[2] eq 1 then begin
          info.disp_colors_id = 8 & info.ctbl = - 1 
          restore, info.dir_guidossub + 'fadcolors.sav' & tvlct, r, g, b
        endif
        if (size(newimis_lm))[2] eq 1 then begin
          info.disp_colors_id = 7 & info.ctbl = - 1
          restore, info.dir_guidossub + 'lmcolors.sav' & tvlct, r, g, b
        endif
        res = file_info(info.dir_tmp2 + 'origcolors.sav')
        IF res.exists EQ 1b THEN BEGIN
          restore, info.dir_tmp2 + 'origcolors.sav' & tvlct, r, g, b
          info.autostretch_id = origstretch
          widget_control, info.w_autostretch, sensitive = 1, set_value = origstretch          
        ENDIF
      ENDIF
      
      if n_elements(do_influ) eq 0 then begin
        widget_control, info.w_labelstr1, set_value = 'small < '
        widget_control, info.w_labelstr2, set_value = ' medium '
        widget_control, info.w_labelstr3, set_value = ' > large'
        widget_control, info.w_labelstr, set_value = 'MSPA-Core pixels: '
        widget_control, info.w_label_t1, set_value = ['X','1000', '4500','10000']
        widget_control, info.w_label_t2, set_value = ['X','4600', '11000','25000']
        widget_control, info.w_label_t1, set_combobox_select = 1 & info.label_t1 = 1000
        widget_control, info.w_label_t2, set_combobox_select = 1 & info.label_t2 = 4600
      endif

      ;; empty dir_tmp
      close, /all
      pushd, info.dir_tmp
      list = file_search() & nl = n_elements(list)
      if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
      popd
      ;; clean up potential tmp sav-files
      file_delete, info.dir_guidossub + 'contorttmp.sav', / allow_nonexistent, / quiet
      file_delete, info.dir_guidossub + 'fragmtmp.sav', / allow_nonexistent, / quiet
      file_delete, info.dir_guidossub + 'influ.sav', / allow_nonexistent, / quiet

      ;; check if do_contort is in use, meaning defined
      if n_elements(do_contort) gt 0 and eventvalue ne 'Original Image' then goto, contort_cont

      ;; check if do_influ is in use, meaning defined
      if n_elements(do_influ) gt 0  and eventvalue ne 'Original Image' then begin
        info.do_label_groups_id = 1 & info.is_influ = 1
        widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id
        influ_t_old = fix(info.mspa_size_current) 
        save, influ_t_old, filename=info.dir_guidossub + 'influ.sav'
        goto, influ_cont
      endif else begin
        file_delete, info.dir_guidossub + 'influ.sav', / allow_nonexistent, / quiet
        if zn ne 4 then begin ;; when restoring a non-MSPA image
          info.mspa_size_old = 'x' & info.small_lt_old = -1
          if info.mspa_size_current eq '1' then begin
            widget_control, info.w_mspa_param2, set_value = ['x','1','2','3','4','5','6','7','8','9','10']
            widget_control, info.w_mspa_param2, set_combobox_select = 1
          endif else begin
            z = info.mspa_size_current
            widget_control, info.w_mspa_param2, set_value = [z,'1','2','3','4','5','6','7','8','9','10']
            widget_control, info.w_mspa_param2, set_combobox_select = 0
          endelse    
        endif
      endelse

    END

    'switchcursor':  BEGIN
      ;; switch between cursor types Help and Crosshair
      IF info.cursor eq 'help' THEN BEGIN ;; set to CrossHair
        IF info.my_os NE 'windows' THEN DEVICE, CURSOR_STANDARD = 52 ELSE DEVICE, CURSOR_STANDARD = 32649
        info.cursor = 'cross'
      ENDIF ELSE BEGIN ;; set to Help
        IF info.my_os NE 'windows' THEN DEVICE, CURSOR_STANDARD = 92 ELSE DEVICE, CURSOR_STANDARD = 32651
        info.cursor = 'help'
      ENDELSE
      GOTO, fin
    END

;;-----------------------------------------------------------------------
;;-----------------------  Image Analysis -----------------------------
;;-----------------------------------------------------------------------
   'frag_fad':  BEGIN
      ;; check for input compliance:
      ;; 1) if already a mspa image then quit
      IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_contort GT 0 OR info.is_nw EQ 1 OR info.is_cost EQ 1 THEN BEGIN
        res = dialog_message(info.wronginput, / information)
        GOTO, fin
      ENDIF

      ;; 2) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
        info.selsubregion_id = 0
        ;; deactivate zoomfactor selector
        widget_control, info.w_zoomfac, sensitive = 1
        widget_control, info.w_selsubregion, set_value = 'Zoom Mode'
        ;; restore the prezoomed process image
        * info.process = * info.prezoomprocess
        ;; disable button and enable motion events in w_draw
        widget_control, info.w_draw, Draw_Motion_Events = 1
        widget_control, info.w_draw, Draw_Button_Events = 0
        info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF

      ;; 3) check input compliance
      fname = info.fname_input & image0 = * info.fr_image
      LM_Compliance, fname, image0, 'fad', info.immaxsizeg, 1, result
      IF result EQ 0 THEN GOTO, fin  ;; invalid input
      
      sz = size(image0,/dim) & xdim=sz[0] & ydim=sz[1] & imgminsize=(xdim<ydim)
      IF imgminsize LT 250 THEN BEGIN
        res = dialog_message('FAD requires a minimum image dimension of 250 pixels in x and y image dimension.' + $
          string(10b) + 'Returning...', / information)
        GOTO, fin
      ENDIF
      
      ;; define required pointers for FAD
      cancel = ptr_new(1b)
      IF info.mspa_param1_id EQ 1b THEN conn = ptr_new('8') ELSE conn = ptr_new('4')  ;; fg-conn      
      ftype = ptr_new('')
      ;; get the fad settings
      get_fad, ftype = ftype, conn = conn, cancel = cancel, Group_Leader = event.top, $
        title = 'Select: FAD or FAD-APP'

      ;; check if cancel was selected then do nothing else apply the
      ;; default or new kernel
      IF * cancel NE 0b THEN BEGIN
        ptr_free, cancel & cancel = 0b
        ptr_free, conn & conn = 0b
        ptr_free, ftype & ftype = 0b
        GOTO, fin
      ENDIF
      fadclass = * ftype
      fgconn_str = * conn
      ;; show selected FG-conn in GUI
      info.mspa_param1_id = fgconn_str eq '8'
      widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id
     
      if fadclass eq 'FAD 6-class' then fadtype = 'FAD'
      if fadclass eq 'FAD-APP 2-class' then fadtype = 'FAD-APP2'
      if fadclass eq 'FAD-APP 5-class' then fadtype = 'FAD-APP5'
      if fadtype eq 'FAD' then fadg = 'FAD' else fadg = 'FAD-APP'

      ;; free and delete the temporary pointers
      ptr_free, cancel & cancel = 0b
      ptr_free, conn & conn = 0b
      ptr_free, ftype & ftype = 0b
      
      widget_control, / hourglass
      ;; image properties
      qmiss = where(image0 eq 0b,ctmiss, /l64) & q3b = where(image0 eq 3b, ct3b, /l64) & q4b = where(image0 eq 4b, ct4b, /l64) 
      BGmask = where(image0 EQ 1b, /l64) & FGmask = where(image0 eq 2b, /l64, fgarea)
      
      ;; get average patch size and # of patches
      ext1 = lonarr(sz[0] + 2, sz[1] + 2)
      ext1[1:sz[0], 1:sz[1]] = long(image0 eq 2b)
      IF fgconn_str eq '8' THEN conn8 = 1 ELSE conn8 = 0
      ;; label FG only
      ext1 = label_region(ext1, all_neighbors=conn8, / ulong)
      if fadg eq 'FAD-APP' then obj_area = histogram(ext1, reverse_indices = rev, /l64) else obj_area = histogram(ext1, / l64)
      obj_last=max(ext1) & ext1=0
      aps = total(obj_area[1:*]) / obj_last & z81 = strtrim(aps,2) & obj_area = 0 & z80 = strtrim(obj_last,2)
      z20 = '# Patches: ' + z80 & z22 = 'APS: ' + z81 
         
      ;; loop over 5 observation scales
      kdim = [7, 13, 27, 81, 243] & mscale = bytarr(5, xdim, ydim)
      kdim_str = ['7', '13', '27', '81', '243']
      ;; define arrays for cummulative values in summary barplot in popup window
      intact = fltarr(6) & interior = intact & dominant = intact & transitional = intact
      patchy = intact & rare = intact & separated = intact & continuous = intact & fad_av = intact
      
      ;; calculate FAD for each of the 5 observation scales
      imdisp = image0 * 0 ;;; the sum of classes over observation scales image to be shown in the viewport     
      for isc = 0,4 do begin
        image0 = * info.fr_image
        IF ct4b GT 0 THEN image0[q4b] = 0b
        ;; run spatcon P2
        spatcon, image0, kdim[isc], 'p2', info.dir_tmp, info.my_os, info.resfloat, im
        ;; rescale to normalized byte range
        if info.resfloat eq 0 then begin
          ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
          ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
          ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels
          q = where(im eq 255b, ct, /l64)
          im = (temporary(im) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
          im = byte(round(temporary(im) * 100.0))
          if ct gt 0 then im[q] = 100b
        endif else begin
          im = byte(round(im*100.0))
        endelse
        fad_av(isc) = mean(im(FGmask))
        
        ;; do we want APP?
        if fadg eq 'FAD-APP' then begin
          extim = bytarr(sz[0] + 2, sz[1] + 2)
          extim[1:sz[0], 1:sz[1]] = im
          FOR i = 1l, obj_last DO BEGIN
            av = byte(round(mean(extim[rev[rev[i]:rev[i + 1] - 1]])))
            extim[rev[rev[i]:rev[i + 1] - 1]] = av
          ENDFOR
          im = extim[1:sz[0], 1:sz[1]] & extim=0
        endif
      
        ;; add specialBG (105b), specialBG-Nf (106b), Missing (102b), background (101b)
        if ct3b gt 0 then im[q3b] = 105b
        if ct4b gt 0 then im[q4b] = 106b
        if ctmiss gt 0 then im[qmiss] = 102b 
        im[BGmask] = 101b
        
        if fadg eq 'FAD' then begin
          ;; get the 5 fragmentation proportions (the 6th, rare, is always 100.0%)
          zz = (im EQ 100b) & intact(isc) = total(zz)/fgarea*100.0
          zz = (im GE 90b) AND (im LT 100b) & interior(isc) = total(zz)/fgarea*100.0
          zz = (im GE 60b) AND (im LT 90b) & dominant(isc) = total(zz)/fgarea*100.0
          zz = (im GE 40b) AND (im LT 60b) & transitional(isc) = total(zz)/fgarea*100.0
          zz = (im GE 10b) AND (im LT 40b) & patchy(isc) = total(zz)/fgarea*100.0
          zz = (im LT 10b) & rare(isc) = total(zz)/fgarea*100.0 & zz = 0
        endif else begin ;; output 5-class as well as 2-class
          zz = (im GE 90b) AND (im LE 100b) & interior(isc) = total(zz)/fgarea*100.0
          zz = (im GE 60b) AND (im LT 90b) & dominant(isc) = total(zz)/fgarea*100.0
          zz = (im GE 40b) AND (im LT 60b) & transitional(isc) = total(zz)/fgarea*100.0
          zz = (im GE 10b) AND (im LT 40b) & patchy(isc) = total(zz)/fgarea*100.0
          zz = (im LT 10b) & rare(isc) = total(zz)/fgarea*100.0
          zz = (im GE 40b) AND (im LE 100b) & continuous(isc) = total(zz)/fgarea*100.0
          zz = (im LT 40b) & separated(isc) = total(zz)/fgarea*100.0 & zz = 0
        endelse

        ;; add to data cube
        imdisp = imdisp + im
        mscale[isc,*,*] = temporary(im)
      endfor
      
      ;; average over the 5 scales in byte values
      im = byte(round(temporary(imdisp)/5.0))
      ;; add specialBG (105b), specialBG-Nf (106b), Missing (102b), background (101b) for display image: im = average across scales
      if ct3b gt 0 then im[q3b] = 105b
      if ct4b gt 0 then im[q4b] = 106b
      if ctmiss gt 0 then im[qmiss] = 102b
      im[BGmask] = 101b & BGmask = 0 & qmiss = 0 & q3b = 0 & q4b = 0
      fad_av(5) = mean(im(FGmask)) & FGmask = 0
      
      if fadg eq 'FAD' then begin
        zz = (im EQ 100b) & intact(5) = total(zz)/fgarea*100.0
        zz = (im GE 90b) AND (im LT 100b) & interior(5) = total(zz)/fgarea*100.0
        zz = (im GE 60b) AND (im LT 90b) & dominant(5) = total(zz)/fgarea*100.0
        zz = (im GE 40b) AND (im LT 60b) & transitional(5) = total(zz)/fgarea*100.0
        zz = (im GE 10b) AND (im LT 40b) & patchy(5) = total(zz)/fgarea*100.0
        zz = (im LT 10b) & rare(5) = total(zz)/fgarea*100.0 & zz = 0        
      endif else begin ;; output 5-class as well as 2-class
        zz = (im GE 90b) AND (im LE 100b) & interior(5) = total(zz)/fgarea*100.0
        zz = (im GE 60b) AND (im LT 90b) & dominant(5) = total(zz)/fgarea*100.0
        zz = (im GE 40b) AND (im LT 60b) & transitional(5) = total(zz)/fgarea*100.0
        zz = (im GE 10b) AND (im LT 40b) & patchy(5) = total(zz)/fgarea*100.0
        zz = (im LT 10b) & rare(5) = total(zz)/fgarea*100.0
        zz = (im GE 40b) AND (im LE 100b) & continuous(5) = total(zz)/fgarea*100.0
        zz = (im LT 40b) & separated(5) = total(zz)/fgarea*100.0 & zz = 0
      endelse
      
      ;; the barplot popup window    
      scales = indgen(6)+1  
      ;; normal barplot
      ;;==============================================================
      b1 = BARPLOT(scales, intact, Fill_Color=[0,120,0], yrange=[-4,104], xrange=[0.2, 9.5], /buffer, $
        ytitle='Foreground proportion [%]', xtitle='         Observation scale | MultiScale | Legend', $
        xticklen=0.02,yticklen=0.02,xminor=1, xtickv=[1,2,3,4,5]) 
      if fadtype eq 'FAD-APP2' then begin
        y2 = continuous & y1 = intact
        b2 = BARPLOT(scales,y2, BOTTOM_values=y1, Fill_Color=[140,200,101],/overplot)
        y1=y2 & y2 = separated+y2
        b3 = BARPLOT(scales,y2, BOTTOM_values=y1, Fill_Color=[0,120,0],/overplot)
      endif else begin
        y2 = interior+intact & y1 = intact
        b2 = BARPLOT(scales,y2, BOTTOM_values=y1, Fill_Color=[0,175,0],/overplot) & y1=y2 & y2 = dominant+y2
        b3 = BARPLOT(scales,y2, BOTTOM_values=y1, Fill_Color=[140,200,100],/overplot) & y1=y2 & y2 = transitional+y2
        b4 = BARPLOT(scales,y2, BOTTOM_values=y1, Fill_Color=[255,200,0],/overplot) & y1=y2 & y2 = patchy+y2
        b5 = BARPLOT(scales,y2, BOTTOM_values=y1, Fill_Color=[250,140,90],/overplot) & y1=y2 & y2 = rare+y2
        b6 = BARPLOT(scales,y2, BOTTOM_values=y1, Fill_Color=[215,50,40],/overplot)
      endelse
      
      ;; separator lines
      a = plot([5.5, 5.5],[-4, 104], /data, color='Black',/overplot, thick=3)
      a = plot([6.5, 6.5],[-4, 104], /data, color='Black',/overplot, thick=3)
      a = text(6.7,95, fadtype, /data,/current)
      a = text(6.7,90,'Fragmentation class: ',/data,/current)
      
      ;; legend
      if fadtype eq 'FAD-APP2' then begin
        c = symbol(6.9,85,'square',/data, /sym_filled, sym_color=[0,120,0],sym_size=2,LABEL_STRING='Separated')
        c = symbol(6.9,78,'square',/data, /sym_filled, sym_color=[140,200,101],sym_size=2,LABEL_STRING='Continuous')
      endif else begin
        c = symbol(6.9,85,'square',/data, /sym_filled, sym_color=[215,50,40],sym_size=2,LABEL_STRING='Rare')
        c = symbol(6.9,78,'square',/data, /sym_filled, sym_color=[250,140,90],sym_size=2,LABEL_STRING='Patchy')
        c = symbol(6.9,71,'square',/data, /sym_filled, sym_color=[255,200,0],sym_size=2,LABEL_STRING='Transitional')
        c = symbol(6.9,64,'square',/data, /sym_filled, sym_color=[140,200,100],sym_size=2,LABEL_STRING='Dominant')
        c = symbol(6.9,57,'square',/data, /sym_filled, sym_color=[0,175,0],sym_size=2,LABEL_STRING='Interior')
        if fadg eq 'FAD' then c = symbol(6.9,50,'square',/data, /sym_filled, sym_color=[0,120,0],sym_size=2,LABEL_STRING='Intact')
      endelse

      ;; info on special pixels
      IF (ct4b GT 0) THEN BEGIN
        a = text(6.7,40, 'Non-fragmenting',/data,/current)
        a = text(6.7,35, 'BG pixels present',/data,/current)
      ENDIF     
      IF fgconn_str eq '8' THEN str = '8-conn FG [pixels]:' ELSE str = '4-conn FG [pixels]:'     
      a = text(6.7,20,str,/data,/current)
      z = strtrim(fgarea,2) & q = strmid(z,0,1,/reverse)
      ;; remove the dot at the end if it exists
      if q eq '.' then z = strmid(z,0,strlen(z)-1)
      a = text(6.7,15,'Area: '+z,/data,/current)
      a = text(6.7,10,z20,/data,/current)
      a = text(6.7,5,z22,/data,/current)     
      b1.save,info.dir_tmp + 'barplot.png', resolution=300      
      ;; open barplot image
      IF info.my_os EQ 'apple' THEN BEGIN
        spawn, 'open ' + info.dir_tmp + 'barplot.png'
      ENDIF ELSE IF info.my_os EQ 'windows' THEN BEGIN
        pushd, info.dir_tmp
        spawn, 'start barplot.png', / nowait
        popd
      ENDIF ELSE BEGIN ;; Linux
        IF strlen(info.xdgop) EQ 0 THEN BEGIN
          st = "Please install xdg-open to automatically" + $
            "display barplots within GuidosToolbox."
          result = dialog_message(st, / information)
        ENDIF ELSE BEGIN
          spawn, info.xdgop + ' "' + info.dir_tmp + 'barplot.png' + '"'
        ENDELSE
      ENDELSE
      
      ;; write table out to disk in tmp to be copied later if files are saved
      fx = info.dir_tmp + 'fadtable.txt' & file_delete,fx,/allow_nonexistent,/quiet
      openw,12,fx
      printf, 12, fadg + ': Foreground Area Density summary analysis for image: '
      printf, 12, fname
      printf, 12, '================================================================================'
      IF fgconn_str eq '8' THEN str = '8-conn FG: ' ELSE str = '4-conn FG: '
      printf, 12, str + 'area, # patches, aps [pixels]: ', z, ', ', z80,', ', z81
      IF ct4b GT 0 THEN printf, 12, 'Non-fragmenting background pixels [4b] in input image'
      printf, 12, 'Fragmentation class: foreground proportion at observation scale/area: '
      printf, 12, 'Observation scale:    1         2          3          4          5        mscale'   
      printf, 12, 'Neighborhood area:   7x7      13x13      27x27      81x81     243x243'
      printf, 12, '================================================================================'
      if fadg eq 'FAD' then begin
        printf, 12, format='(a14,6(f11.4))', 'Rare: ', rare
        printf, 12, format='(a14,6(f11.4))', 'Patchy: ', patchy
        printf, 12, format='(a14,6(f11.4))', 'Transitional: ', transitional
        printf, 12, format='(a14,6(f11.4))', 'Dominant: ', dominant
        printf, 12, format='(a14,6(f11.4))', 'Interior: ', interior
        printf, 12, format='(a14,6(f11.4))', 'Intact: ', intact       
      endif else begin
        printf, 12, 'FAD-APP 5-class:'
        printf, 12, format='(a14,6(f11.4))', 'Rare: ', rare
        printf, 12, format='(a14,6(f11.4))', 'Patchy: ', patchy
        printf, 12, format='(a14,6(f11.4))', 'Transitional: ', transitional
        printf, 12, format='(a14,6(f11.4))', 'Dominant: ', dominant
        printf, 12, format='(a14,6(f11.4))', 'Interior: ', interior
        printf, 12, 'FAD-APP 2-class:'
        printf, 12, format='(a14,6(f11.4))', 'Separated: ', separated
        printf, 12, format='(a14,6(f11.4))', 'Continuous: ', continuous
      endelse
      printf, 12, '================================================================================'
      printf, 12, format='(a14,6(f11.4))', 'FAD_av: ', fad_av
      close, 12
      
      ;; write csv output
      fx = info.dir_tmp + 'fadtable.csv' & file_delete,fx,/allow_nonexistent,/quiet
      openw,12,fx 
      printf,12, fadg + ': FragmClass\ObsScale:, 1, 2, 3, 4, 5, Summary' & z = strtrim(rare,2)
      if fadg eq 'FAD' then begin
        printf,12, 'Rare:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]  & z = strtrim(patchy,2)
        printf,12, 'Patchy:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]  & z = strtrim(transitional,2)
        printf,12, 'Transitional:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]  & z = strtrim(dominant,2)
        printf,12, 'Dominant:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]  & z = strtrim(interior,2)
        printf,12, 'Interior:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]  & z = strtrim(intact,2)
        printf,12, 'Intact:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]       
      endif else begin
        printf, 12, 'FAD-APP 5-class:' & z = strtrim(rare,2)
        printf, 12, 'Rare:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]  & z = strtrim(patchy,2)
        printf, 12, 'Patchy:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]  & z = strtrim(transitional,2)
        printf, 12, 'Transitional:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5] & z = strtrim(dominant,2)
        printf, 12, 'Dominant:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5] & z = strtrim(interior,2)
        printf, 12, 'Interior:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]
        printf, 12, 'FAD-APP 2-class:' & z = strtrim(separated,2)
        printf, 12, 'Separated:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5] & z = strtrim(continuous,2)
        printf, 12, 'Continuous:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5] & z = strtrim(fad_av,2)
        printf, 12, 'FAD_av:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]
      endelse            
      close,12 
      
      ;; save stats summary in idl format for potential change analysis at some later point
      ;; check if we have a geotiff image
      geotiff_log = '' ;; gdal geotiff-information
      xdim = sz[0] & ydim = sz[1]  ;; size of the image         
      if info.is_geotiff gt 0 then begin  ;; we have a geotiff image
        IF info.my_os EQ 'windows' THEN BEGIN
          cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalinfo -noct "' + fname + '"'
        ENDIF ELSE BEGIN
          if strlen(info.sysgdal) gt 0 then $
            cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + fname + '"' else $
            cmd = info.dir_fwtools + 'gdalinfo -noct "' + fname + '"'
        ENDELSE
        IF info.my_os EQ 'windows' THEN spawn, cmd, geotiff_log, / hide ELSE spawn, cmd, geotiff_log        
      endif      
      save, filename=info.dir_tmp + 'fad.sav', fadtype, xdim, ydim, geotiff_log, $
         rare, patchy, transitional, dominant, interior, intact, separated, continuous, fgarea, kdim_str, fad_av, obj_last

      ;; return stuff into info GTB infostructure      
      * info.mscale = temporary(mscale)
      * info.process = temporary(im)
      * info.fr_image = * info.process
      if fadtype eq 'FAD-APP2' then begin
        restore, info.dir_guidossub + 'fe47colors.sav' & info.disp_colors_id = 10 ;; FE47 colors
      endif else begin
        restore, info.dir_guidossub + 'fadcolors.sav' & info.disp_colors_id = 8 ;; FAD colors        
      endelse
      tvlct, r, g, b
      info.ctbl = - 1 & info.autostretch_id = 0 
      info.add_title = ' (' + fadclass + ': MultiScale summary)'
      
 
      ;; reset mspa and use info.is_fragm also for FAD
      info.is_mspa = 0 & info.mspa_stats_show = 0b & info.is_fragm = 3 & info.is_contort = 0
      info.do_mspa_stats_id = 0 & info.is_cs22 = 0 & info.is_nw = 0 & info.is_cost = 0
      info.do_label_groups_id = 0 

   END

   ;;*****************************************************************************************************

   'batch_fad':  BEGIN
     tit = 'Select (Geo-)Tif-files'
     im_file = $
       dialog_pickfile(Title = tit, get_path = path2file, $
       path = info.dir_data, $
       default_extension = 'tif', / fix_filter, $
       / must_exist, $
       / multiple_files, filter = ['*.tif', '*.tiff'])
     IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
     
     ;; test that the directory of the selected files has no sub-directories
     pushd, path2file
     list = file_search() & nl = n_elements(list) & nr_dir = 0
     for idx = 0, nl-1 do begin
      q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
     endfor
     IF nr_dir GT 0 THEN BEGIN
       msg = 'The directory of your Batch FAD input files contains sub-directories.'  +  string(10b) +  string(10b) + $
         'Please set up a new directory having Batch FAD input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)  
       GOTO, fin
     ENDIF
     popd

     ;; do the loop processing now
     ;; files are now selected, reset the GUI
     ;;========================================================================
     ;; reset the front image and block any events
     ;;========================================================================
     title = 'FAD Batch Processing'
     goto, resetfront

     backto_batch_fad:
     
     ;; define required pointers for FAD
     cancel = ptr_new(1b)
     IF info.mspa_param1_id EQ 1b THEN conn = ptr_new('8') ELSE conn = ptr_new('4')  ;; fg-conn
     ftype = ptr_new('')
     ;; get the fad settings
     get_fad, ftype = ftype, conn = conn, cancel = cancel, Group_Leader = event.top, $
       title = 'Select: FAD or FAD-APP'

     ;; check if cancel was selected then do nothing else apply the
     ;; default or new kernel
     IF * cancel NE 0b THEN BEGIN
       ptr_free, cancel & cancel = 0b
       ptr_free, conn & conn = 0b
       ptr_free, ftype & ftype = 0b
       GOTO, fin
     ENDIF
     fadclass = * ftype
     fgconn_str = * conn
     ;; show selected FG-conn in GUI
     info.mspa_param1_id = fgconn_str eq '8'
     widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id

     if fadclass eq 'FAD 6-class' then fadtype = 'FAD'
     if fadclass eq 'FAD-APP 2-class' then fadtype = 'FAD-APP2'
     if fadclass eq 'FAD-APP 5-class' then fadtype = 'FAD-APP5'
     if fadtype eq 'FAD' then fadg = 'FAD' else fadg = 'FAD-APP'

     ;; free and delete the temporary pointers
     ptr_free, cancel & cancel = 0b
     ptr_free, conn & conn = 0b
     ptr_free, ftype & ftype = 0b
     
     
     ;; test that we can write into the parent directory or if it exists already
     batch_type = 'batch_' + fadtype
     dd = file_dirname(im_file[0], / mark_directory)
     dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
     res = file_test(dir_batch, /directory, /write)
     if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.' + string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
       res = dialog_message(msg,/question)
       If res eq 'No' then goto, fin
       ;; empty it
       pushd, dir_batch
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd
     endif else begin ;; does not exist yet, create it
       file_mkdir, dir_batch
     endelse
    
     desc = 'GTB_FAD, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
     desc0 = 'GTB, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
     ;; validate and process the images in a loop
     fn_logfile = dir_batch + strlowcase(fadtype) + '.log'
     nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
     openw, 9, fn_logfile
     printf, 9, fadg + ' batch processing logfile: ', systime()
     printf, 9, 'Number of files to be processed: ', nr_im_files
     printf, 9, '==============================================='
     close, 9

     msg = 'Processing selected images for FAD, please wait...'
     progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
     progressBar -> Start

     FOR fidx = 0, nr_im_files - 1 DO BEGIN
       counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
       ;; validate the input, if not skip it without message
       IF progressBar -> CheckCancel() THEN BEGIN
         res = Dialog_Message('Batch-processing cancelled by user.')
         openw, 9, fn_logfile, /append
         printf, 9, 'Batch-processing cancelled by user.'
         close, 9
         progressBar -> Destroy
         Obj_Destroy, progressBar
         tvlct, rini, gini, bini
         GOTO, fin
       ENDIF

       input = im_file(fidx)
       res = strpos(input,' ') ge 0
       IF res EQ 1 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid FAD input (empty space in directory path or input filename): ', input
         close, 9
         GOTO, skip_batch_fad  ;; invalid input
       ENDIF

       type = '' & res = query_image(input, type=type)
       IF type NE 'TIFF' THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid FAD input (not a TIFF image): ', input
         close, 9
         GOTO, skip_batch_fad  ;; invalid input
       ENDIF

       res = query_tiff(input)
       IF res EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid FAD input file: ', input
         close, 9
         GOTO, skip_batch_fad  ;; invalid input
       ENDIF

       image0 = read_tiff(input, geotiff = geotiff) & is_geotiff = (size(geotiff))[0] ;; read and check it
       sz = size(image0,/dim) & xdim=sz[0] & ydim=sz[1] & imgminsize=(xdim<ydim)
       IF imgminsize LT 250 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid FAD input file (x/y dimension less than 250 pixels): ', input
         close, 9
         GOTO, skip_batch_fad  ;; invalid input
       ENDIF
      
       LM_Compliance, input, image0, 'fad', info.immaxsizeg, 0, result
       IF result EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid FAD input file: ', input
         close, 9
         GOTO, skip_batch_fad  ;; invalid input
       ENDIF

       ;; now all is ok for processing
       ;;==================================
       ;; write the final result to the initial input dir
       fbn = file_basename(input, '.tif') & outdir = dir_batch + fbn + '_' + strlowcase(fadtype)
       if fadtype eq 'FAD' or fadtype eq 'FAD-APP5' then $
        restore, info.dir_guidossub + 'fadcolors.sav' else restore, info.dir_guidossub + 'fe47colors.sav'
       tvlct, r, g, b
       ;; setup the output directory for the current image file
       file_mkdir, outdir

       ;; image properties
       qmiss = where(image0 eq 0b,ctmiss, /l64) & q3b = where(image0 eq 3b, ct3b, /l64) & q4b = where(image0 eq 4b, ct4b, /l64) 
       BGmask = where(image0 EQ 1b, /l64) & FGmask = where(image0 eq 2b, /l64, fgarea)
       
       ;; get average patch size and # of patches
       ext1 = lonarr(sz[0] + 2, sz[1] + 2)
       ext1[1:sz[0], 1:sz[1]] = long(image0 eq 2b)
       
       ;; label FG only
       conn8 = fgconn_str eq '8'
       conn_str = fgconn_str + '-conn FG'
      
       ;; label FG only
       ext1 = label_region(ext1, all_neighbors=conn8, / ulong)
       if fadg eq 'FAD-APP' then obj_area = histogram(ext1, reverse_indices = rev, /l64) else obj_area = histogram(ext1, /l64)
       obj_last=max(ext1) & ext1=0
       aps = total(obj_area[1:*]) / obj_last & z81 = strtrim(aps,2) & obj_area = 0 & z80 = strtrim(obj_last,2)
       z20 = '# Patches: ' + z80 & z22 = 'APS: ' + z81      
       
       ;; loop over 5 observation scales
       kdim = [7, 13, 27, 81, 243]

       time0 = systime( / sec)
       widget_control, / hourglass
       ;; define arrays for cummulative values in summary barplot in popup window
       intact = fltarr(6) & interior = intact & dominant = intact & transitional = intact
       patchy = intact & rare = intact & separated = intact & continuous = intact & fad_av = intact

       ;; calculate FAD for each of the 5 observation scales
       imdisp = image0 * 0 ;;; the sum of classes over observation scales image to be shown in the viewport

       for isc = 0,4 do begin
         if isc lt 4 then tmp = image0 else tmp = temporary(image0)
         IF ct4b GT 0 THEN tmp[q4b] = 0b
         kdim_str = strtrim(kdim[isc],2)
         
         ;; run spatcon P2
         spatcon, tmp, kdim[isc], 'p2', info.dir_tmp, info.my_os, info.resfloat, im
         ;; rescale to normalized byte range
         if info.resfloat eq 0 then begin
           ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
           ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
           ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels
           q = where(im eq 255b, ct, /l64)
           im = (temporary(im) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
           im = byte(round(temporary(im) * 100.0))
           if ct gt 0 then im[q] = 100b
         endif else begin
           im = byte(round(im*100.0))
         endelse
         fad_av(isc) = mean(im(FGmask))
         
         ;; do we want APP?
         if fadg eq 'FAD-APP' then begin
           extim = bytarr(sz[0] + 2, sz[1] + 2)
           extim[1:sz[0], 1:sz[1]] = im
           FOR i = 1l, obj_last DO BEGIN
             av = byte(round(mean(extim[rev[rev[i]:rev[i + 1] - 1]])))
             extim[rev[rev[i]:rev[i + 1] - 1]] = av
           ENDFOR
           im = extim[1:sz[0], 1:sz[1]] & extim=0
         endif

         ;; add specialBG (105b), specialBG-Nf (106b), Missing (102b), background (101b)
         if ct3b gt 0 then im[q3b] = 105b
         if ct4b gt 0 then im[q4b] = 106b
         if ctmiss gt 0 then im[qmiss] = 102b
         im[BGmask] = 101b

         ;; the statistics
         if fadg eq 'FAD' then begin
           ;; get the 5 fragmentation proportions (the 6th, rare, is always 100.0%)
           zz = (im EQ 100b) & intact(isc) = total(zz)/fgarea*100.0
           zz = (im GE 90b) AND (im LT 100b) & interior(isc) = total(zz)/fgarea*100.0
           zz = (im GE 60b) AND (im LT 90b) & dominant(isc) = total(zz)/fgarea*100.0
           zz = (im GE 40b) AND (im LT 60b) & transitional(isc) = total(zz)/fgarea*100.0
           zz = (im GE 10b) AND (im LT 40b) & patchy(isc) = total(zz)/fgarea*100.0
           zz = (im LT 10b) & rare(isc) = total(zz)/fgarea*100.0 & zz = 0
         endif else begin ;; output 5-class as well as 2-class
           zz = (im GE 90b) AND (im LE 100b) & interior(isc) = total(zz)/fgarea*100.0
           zz = (im GE 60b) AND (im LT 90b) & dominant(isc) = total(zz)/fgarea*100.0
           zz = (im GE 40b) AND (im LT 60b) & transitional(isc) = total(zz)/fgarea*100.0
           zz = (im GE 10b) AND (im LT 40b) & patchy(isc) = total(zz)/fgarea*100.0
           zz = (im LT 10b) & rare(isc) = total(zz)/fgarea*100.0
           zz = (im GE 40b) AND (im LE 100b) & continuous(isc) = total(zz)/fgarea*100.0
           zz = (im LT 40b) & separated(isc) = total(zz)/fgarea*100.0 & zz = 0
         endelse

         ;; add to summary image
         imdisp = imdisp + im

         ;; write out the single scale image
         fn_out = outdir + '/' + fbn + '_' + strlowcase(fadtype) + '_' + kdim_str + '.tif'
         IF (size(geotiff))[0] gt 0 THEN $
           write_tiff, fn_out, im, red = r, green = g, blue = b, geotiff = geotiff, description = desc, compression = 1 ELSE $
           write_tiff, fn_out, im, red = r, green = g, blue = b, description = desc, compression = 1
         im = 0                         
       endfor
       
       ;; average over the 5 classes in byte values
       im = byte(round(temporary(imdisp)/5.0))

       ;; add specialBG (105b), specialBG-Nf (106b), Missing (102b), background (101b) for display image: imdisp = actual summary data
       if ct3b gt 0 then im[q3b] = 105b
       if ct4b gt 0 then im[q4b] = 106b
       if ctmiss gt 0 then im[qmiss] = 102b
       im[BGmask] = 101b & BGmask = 0 & qmiss = 0 & q3b = 0 & q4b = 0
       fad_av(5) = mean(im(FGmask)) & FGmask = 0
       
       if fadg eq 'FAD' then begin
         ;; stats for sum of classes over observation scale for display image: im
         zz = (im EQ 100b) & intact(5) = total(zz)/fgarea*100.0
         zz = (im GE 90b) AND (im LT 100b) & interior(5) = total(zz)/fgarea*100.0
         zz = (im GE 60b) AND (im LT 90b) & dominant(5) = total(zz)/fgarea*100.0
         zz = (im GE 40b) AND (im LT 60b) & transitional(5) = total(zz)/fgarea*100.0
         zz = (im GE 10b) AND (im LT 40b) & patchy(5) = total(zz)/fgarea*100.0
         zz = (im LT 10b) & rare(5) = total(zz)/fgarea*100.0 & zz = 0
       endif else begin ;; output 5-class as well as 2-class
         zz = (im GE 90b) AND (im LE 100b) & interior(5) = total(zz)/fgarea*100.0
         zz = (im GE 60b) AND (im LT 90b) & dominant(5) = total(zz)/fgarea*100.0
         zz = (im GE 40b) AND (im LT 60b) & transitional(5) = total(zz)/fgarea*100.0
         zz = (im GE 10b) AND (im LT 40b) & patchy(5) = total(zz)/fgarea*100.0
         zz = (im LT 10b) & rare(5) = total(zz)/fgarea*100.0
         zz = (im GE 40b) AND (im LE 100b) & continuous(5) = total(zz)/fgarea*100.0
         zz = (im LT 40b) & separated(5) = total(zz)/fgarea*100.0 & zz = 0
       endelse

       fn_out = outdir + '/' + fbn + '_' + strlowcase(fadtype) + '_mscale.tif'
       ;; add the geotiff info if available
       IF is_geotiff GT 0 THEN $
         write_tiff, fn_out, im, red = r, green = g, blue = b, geotiff = geotiff, description = desc, compression = 1 ELSE $
         write_tiff, fn_out, im, red = r, green = g, blue = b, description = desc, compression = 1
       im = 0

       ;; the barplot popup window
       ;; here in batch mode add the buffer keyword to not open a graphic window on the screen
       ;; this is important because if the screensave kicks in then the graphic content can no lonnger be saved to a file
       scales = indgen(6)+1
       ;; normal barplot
       ;;==============================================================
       b1 = BARPLOT(scales, intact, Fill_Color=[0,120,0], yrange=[-4,104], xrange=[0.2, 9.5], /buffer, $
         ytitle='Foreground proportion [%]', xtitle='         Observation scale | MultiScale | Legend', $
         xticklen=0.02,yticklen=0.02,xminor=1, xtickv=[1,2,3,4,5])

       if fadtype eq 'FAD-APP2' then begin
         y2 = continuous & y1 = intact
         b2 = BARPLOT(scales,y2, BOTTOM_values=y1, Fill_Color=[140,200,101],/overplot)
         y1=y2 & y2 = separated+y2
         b3 = BARPLOT(scales,y2, BOTTOM_values=y1, Fill_Color=[0,120,0],/overplot)
       endif else begin
         y2 = interior+intact & y1 = intact
         b2 = BARPLOT(scales,y2, BOTTOM_values=y1, Fill_Color=[0,175,0],/overplot) & y1=y2 & y2 = dominant+y2
         b3 = BARPLOT(scales,y2, BOTTOM_values=y1, Fill_Color=[140,200,100],/overplot) & y1=y2 & y2 = transitional+y2
         b4 = BARPLOT(scales,y2, BOTTOM_values=y1, Fill_Color=[255,200,0],/overplot) & y1=y2 & y2 = patchy+y2
         b5 = BARPLOT(scales,y2, BOTTOM_values=y1, Fill_Color=[250,140,90],/overplot) & y1=y2 & y2 = rare+y2
         b6 = BARPLOT(scales,y2, BOTTOM_values=y1, Fill_Color=[215,50,40],/overplot)
       endelse

       ;; separator lines
       a = plot([5.5, 5.5],[-4, 104], /data, color='Black',/overplot, thick=3)
       a = plot([6.5, 6.5],[-4, 104], /data, color='Black',/overplot, thick=3)
       a = text(6.7,95, fadtype, /data,/current)
       a = text(6.7,90,'Fragmentation class: ',/data,/current)

       ;; legend
       if fadtype eq 'FAD-APP2' then begin
         c = symbol(6.9,85,'square',/data, /sym_filled, sym_color=[0,120,0],sym_size=2,LABEL_STRING='Separated')
         c = symbol(6.9,78,'square',/data, /sym_filled, sym_color=[140,200,101],sym_size=2,LABEL_STRING='Continuous')
       endif else begin
         c = symbol(6.9,85,'square',/data, /sym_filled, sym_color=[215,50,40],sym_size=2,LABEL_STRING='Rare')
         c = symbol(6.9,78,'square',/data, /sym_filled, sym_color=[250,140,90],sym_size=2,LABEL_STRING='Patchy')
         c = symbol(6.9,71,'square',/data, /sym_filled, sym_color=[255,200,0],sym_size=2,LABEL_STRING='Transitional')
         c = symbol(6.9,64,'square',/data, /sym_filled, sym_color=[140,200,100],sym_size=2,LABEL_STRING='Dominant')
         c = symbol(6.9,57,'square',/data, /sym_filled, sym_color=[0,175,0],sym_size=2,LABEL_STRING='Interior')
         if fadg eq 'FAD' then c = symbol(6.9,50,'square',/data, /sym_filled, sym_color=[0,120,0],sym_size=2,LABEL_STRING='Intact')
       endelse

       ;; info on special pixels
       IF (ct4b GT 0) THEN BEGIN
         a = text(6.7,40, 'Non-fragmenting',/data,/current)
         a = text(6.7,35, 'BG pixels present',/data,/current)
       ENDIF
       str = conn_str + ' [pixels]:'
       a = text(6.7,20,str,/data,/current)
       z = strtrim(fgarea,2) & q = strmid(z,0,1,/reverse)
       ;; remove the dot at the end if it exists
       if q eq '.' then z = strmid(z,0,strlen(z)-1)
       a = text(6.7,15,'Area: '+z,/data,/current)
       a = text(6.7,10,z20,/data,/current)
       a = text(6.7,5,z22,/data,/current)
       fn_out = outdir + '/' + fbn + '_' + strlowcase(fadtype) + '_barplot.png'
       b1.save,fn_out, resolution=300
       b1.close
       
       ;; write out the statistics table
       fn_out = outdir + '/' + fbn + '_' + strlowcase(fadtype) + '_mscale.txt'
       z = strtrim(fgarea,2)
       openw,12,fn_out
       printf, 12, fadg + ': Foreground Area Density summary analysis for image: '
       printf, 12, file_basename(input)
       printf, 12, '================================================================================'
       printf, 12, conn_str + ': area, # patches, aps [pixels]: ', z, ', ', z80,', ', z81
       IF ct4b GT 0 THEN printf, 12, 'Non-fragmenting background pixels [4b] in input image'
       printf, 12, 'Fragmentation class: foreground proportion at observation scale/area: '
       printf, 12, 'Observation scale:    1         2          3          4          5        mscale'
       printf, 12, 'Neighborhood area:   7x7      13x13      27x27      81x81     243x243'
       printf, 12, '================================================================================'
       if fadg eq 'FAD' then begin
         printf, 12, format='(a14,6(f11.4))', 'Rare: ', rare
         printf, 12, format='(a14,6(f11.4))', 'Patchy: ', patchy
         printf, 12, format='(a14,6(f11.4))', 'Transitional: ', transitional
         printf, 12, format='(a14,6(f11.4))', 'Dominant: ', dominant
         printf, 12, format='(a14,6(f11.4))', 'Interior: ', interior
         printf, 12, format='(a14,6(f11.4))', 'Intact: ', intact
       endif else begin
         printf, 12, 'FAD-APP 5-class:'
         printf, 12, format='(a14,6(f11.4))', 'Rare: ', rare
         printf, 12, format='(a14,6(f11.4))', 'Patchy: ', patchy
         printf, 12, format='(a14,6(f11.4))', 'Transitional: ', transitional
         printf, 12, format='(a14,6(f11.4))', 'Dominant: ', dominant
         printf, 12, format='(a14,6(f11.4))', 'Interior: ', interior
         printf, 12, 'FAD-APP 2-class:'
         printf, 12, format='(a14,6(f11.4))', 'Separated: ', separated
         printf, 12, format='(a14,6(f11.4))', 'Continuous: ', continuous
       endelse
       printf, 12, '================================================================================'
       printf, 12, format='(a14,6(f11.4))', 'FAD_av: ', fad_av
       close, 12
           
       ;; save stats summary in idl format for potential change analysis at some later point
       ;; check if we have a geotiff image
       geotiff_log = '' ;; gdal geotiff-information
       xdim = sz[0] & ydim = sz[1]  ;; size of the image
       if (size(geotiff))[0] gt 0 then begin
         IF info.my_os EQ 'windows' THEN BEGIN
           cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalinfo -noct "' + input + '"'
         ENDIF ELSE BEGIN
           if strlen(info.sysgdal) gt 0 then $
             cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + input + '"' else $
             cmd = info.dir_fwtools + 'gdalinfo -noct "' + input + '"'
         ENDELSE
         IF info.my_os EQ 'windows' THEN spawn, cmd, geotiff_log, / hide ELSE spawn, cmd, geotiff_log
       endif
       fn_out = outdir + '/' + fbn + '_' + strlowcase(fadtype) + '_mscale.sav' 
       save, filename = fn_out, fadtype, xdim, ydim, geotiff_log, $
         rare, patchy, transitional, dominant, interior, intact, separated, continuous, fgarea, kdim_str, fad_av, obj_last
         
       ;; write csv output
       fn_out = outdir + '/' + fbn + '_' + strlowcase(fadtype) + '_mscale.csv'
       openw,12,fn_out
       printf,12, fadg + ': FragmClass\ObsScale:, 1, 2, 3, 4, 5, Summary' & z = strtrim(rare,2)
       if fadg eq 'FAD' then begin
         printf, 12, 'Rare:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]  & z = strtrim(patchy,2)
         printf, 12, 'Patchy:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]  & z = strtrim(transitional,2)
         printf, 12, 'Transitional:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]  & z = strtrim(dominant,2)
         printf, 12, 'Dominant:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]  & z = strtrim(interior,2)
         printf, 12, 'Interior:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]  & z = strtrim(intact,2)
         printf, 12, 'Intact:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]
       endif else begin
         printf, 12, 'FAD-APP 5-class:' & z = strtrim(rare,2)
         printf, 12, 'Rare:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]  & z = strtrim(patchy,2)
         printf, 12, 'Patchy:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]  & z = strtrim(transitional,2)
         printf, 12, 'Transitional:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5] & z = strtrim(dominant,2)
         printf, 12, 'Dominant:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5] & z = strtrim(interior,2)
         printf, 12, 'Interior:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]
         printf, 12, 'FAD-APP 2-class:' & z = strtrim(separated,2)
         printf, 12, 'Separated:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5] & z = strtrim(continuous,2)
         printf, 12, 'Continuous:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5] & z = strtrim(fad_av,2)
         printf, 12, 'FAD_av:, ',z[0], ', ',z[1], ', ',z[2], ', ',z[3], ', ',z[4], ', ',z[5]
       endelse
       close,12
       okfile = okfile + 1       
              
       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'File: ' + input
       printf, 9, 'FAD comp.time [sec]: ', systime( / sec) - time0
       close, 9

       skip_batch_fad:
       stepn = (fidx + 1.0)/nr_im_files * 100.0
       progressBar -> Update, stepn
     ENDFOR
     progressBar -> Destroy
     Obj_Destroy, progressBar

     ;; inform that batch is done
     proct = systime( / sec) - time00
     IF proct GT 3600.0 THEN BEGIN
       proct2 = proct - ulong(proct/3600)*3600
       proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDIF ELSE BEGIN
       proctstr = strtrim(ulong(proct/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDELSE
     IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
     openw, 9, fn_logfile, /append
     printf, 9, ''
     printf, 9, '==============================================='
     printf, 9, strupcase(fadtype) + ' Batch Processing total comp.time: ', proctstr
     printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
     printf, 9, '==============================================='
     close, 9

     msg = strupcase(fadtype) + ' Batch Processing finished.' + string(10b) + $
       'Total computation time: ' + proctstr + string(10b) + $
       'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
       'More information can be found in the logfile: ' + string(10b) + fn_logfile
     res = dialog_message(msg, / information)
     ;; reset the colortable to the settings before the batch processing
     tvlct, rini, gini, bini
     GOTO, fin
   END
   
   
   ;;*****************************************************************************************************

   'frag_fos':  BEGIN
     ;; check for input compliance:
     ;; 1) if already a mspa image then quit
     IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_contort GT 0 OR info.is_nw EQ 1 OR info.is_cost EQ 1 THEN BEGIN
       res = dialog_message(info.wronginput, / information)
       GOTO, fin
     ENDIF

     ;; 2) if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF

     ;; 3) check input compliance
     fname = info.fname_input & image0 = * info.fr_image
     LM_Compliance, fname, image0, 'fad', info.immaxsizeg, 1, result
     IF result EQ 0 THEN GOTO, fin  ;; invalid input

     sz = size(image0,/dim) & xdim=sz[0] & ydim=sz[1] & imgminsize=(xdim<ydim)

     ;; check if we have a geotiff image
     geotiff_log = '' ;; gdal geotiff-information
     if info.is_geotiff gt 0 then begin  ;; we have a geotiff image
       IF info.my_os EQ 'windows' THEN BEGIN
         cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalinfo -noct "' + fname + '"'
       ENDIF ELSE BEGIN
         if strlen(info.sysgdal) gt 0 then $
           cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + fname + '"' else $
           cmd = info.dir_fwtools + 'gdalinfo -noct "' + fname + '"'
       ENDELSE
       IF info.my_os EQ 'windows' THEN spawn, cmd, geotiff_log, / hide ELSE spawn, cmd, geotiff_log
     endif
     
     ;; test if pixel-resolution is available from gdal g_ps: gdal pixel size
     gdal = 'gdalinfo: no details on the pixel resolution.'
     IF (size(geotiff_log))[0] NE 0 THEN BEGIN
       gps = geotiff_log[WHERE(STRMATCH(geotiff_log, 'Pixel Size*', /FOLD_CASE) EQ 1)] 
       gps = gps[0] & p =strlen(gps)
       if p gt 0 then gdal = 'gdalinfo: ' + gps
     ENDIF

     ;; define required pointers for FOS
     cancel = ptr_new(1b)
     pres = ptr_new(25) ;; pixel resolution
     wdim = ptr_new(5) ;; window edge length = kdim
     conn = ptr_new('8') ;; fg-conn
     ftype = ptr_new('')
     ;; get the fos settings
     get_fos, ftype = ftype, conn =conn, pres = pres, wdim = wdim, gdal = gdal, cancel = cancel, Group_Leader = event.top, $
      title = 'Please set: PixelResolution [m] x square WindowSize = Observation Scale'

     ;; check if cancel was selected then do nothing else apply the
     ;; default or new kernel
     IF * cancel NE 0b THEN BEGIN
       ptr_free, cancel & cancel = 0b
       ptr_free, pres & pres = 0b
       ptr_free, wdim & wdim = 0b
       ptr_free, conn & conn = 0b
       ptr_free, ftype & ftype = 0b
       GOTO, fin
     ENDIF
     pixres = float(* pres) & pixres_str = * pres
     kdim = fix(* wdim) & kdim_str = * wdim
     fgconn_str = * conn
     fosclass = * ftype
     
     if fosclass eq 'FOS 5-class' then fostype = 'FOS5'
     if fosclass eq 'FOS 6-class' then fostype = 'FOS6'
     if fosclass eq 'FOS-APP 2-class' then fostype = 'FOS-APP2'
     if fosclass eq 'FOS-APP 5-class' then fostype = 'FOS-APP5'

     ;; free and delete the temporary pointers
     ptr_free, cancel & cancel = 0b
     ptr_free, pres & pres = 0b
     ptr_free, wdim & wdim = 0b   
     ptr_free, conn & conn = 0b
     ptr_free, ftype & ftype = 0b
     
     IF kdim ge imgminsize THEN BEGIN
       res = dialog_message('Kernel dimension larger than x or y image dimension. ' + $
         string(10b) + 'Returning...', / information)
       GOTO, fin
     ENDIF
     
     ;; we are ready for FOS now
     widget_control, / hourglass
     hec = ((pixres * kdim)^2) / 10000.0
     acr = hec * 2.47105
     hec = strtrim(hec,2)
     acr = strtrim(acr,2)
     
     ;; show selected FG-conn in GUI
     info.mspa_param1_id = fgconn_str eq '8'
     widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id

     
     ;; image properties
     qmiss = where(image0 eq 0b,ctmiss, /l64) & q3b = where(image0 eq 3b, ct3b, /l64) & q4b = where(image0 eq 4b, ct4b, /l64)
     BGmask = where(image0 EQ 1b, /l64) & qFG = where(image0 eq 2b, /l64, fgarea) & fad_av = -1.0

     ;; get average patch size and # of patches
     ext1 = lonarr(sz[0] + 2, sz[1] + 2)
     ext1[1:sz[0], 1:sz[1]] = long(image0 eq 2b)
     IF info.mspa_param1_id EQ 1b THEN conn8 = 1 ELSE conn8 = 0
     ;; label FG only
     ext1 = label_region(ext1, all_neighbors=conn8, / ulong)
     obj_area = histogram(ext1, /l64) 
     if strmid(fostype,0,7) eq 'FOS-APP' then obj_area = histogram(ext1, reverse_indices = rev, /l64) else obj_area = histogram(ext1, /l64)
     obj_last=max(ext1) & ext1=0
     aps = total(obj_area[1:*]) / obj_last & z81 = strtrim(aps,2) & obj_area = 0 & z80 = strtrim(obj_last,2)
     z20 = '# Patches: ' + z80 & z22 = 'APS: ' + z81

     ;; calculate FAD for the fixed observation scale
     IF ct4b GT 0 THEN image0[q4b] = 0b ;; specialBG-Nf
     
     ;; run spatcon P2
     spatcon, image0, kdim, 'p2', info.dir_tmp, info.my_os, info.resfloat, im
     ;; rescale to normalized byte range
     if info.resfloat eq 0 then begin
       ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
       ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
       ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels
       q = where(im eq 255b, ct, /l64)
       im = (temporary(im) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
       im = byte(round(temporary(im) * 100.0))
       if ct gt 0 then im[q] = 100b
     endif else begin
       im = byte(round(im*100.0))
     endelse
     ;; calculate pixel-based fad_av
     fad_av = mean(im(qFG)) & qFG = 0

     ;; do we want APP?
     if strmid(fostype,0,7) eq 'FOS-APP' then begin
       extim = bytarr(sz[0] + 2, sz[1] + 2)
       extim[1:sz[0], 1:sz[1]] = im
       FOR i = 1l, obj_last DO BEGIN
         av = byte(round(mean(extim[rev[rev[i]:rev[i + 1] - 1]])))
         extim[rev[rev[i]:rev[i + 1] - 1]] = av
       ENDFOR
       im = extim[1:sz[0], 1:sz[1]] & extim=0
     endif
     
     ;; add specialBG (105b), specialBG-Nf (106b), Missing (102b), background (101b)
     if ct3b gt 0 then im[q3b] = 105b & q3b = 0
     if ct4b gt 0 then im[q4b] = 106b & q4b = 0
     if ctmiss gt 0 then im[qmiss] = 102b
     qmiss = 0
     im[BGmask] = 101b & BGmask = 0 

     ;; the statistics, first initialize
     intact = -1 & interior = -1 & dominant = -1 & transitional = -1 
     patchy = -1 & rare = -1 & separated = -1 & continuous = -1
     if strlen(fostype) eq 4 then begin
       ;; get the 6 fragmentation proportions 
       if fosclass eq 'FOS 6-class' then begin
         zz = (im EQ 100b) & intact = total(zz)/fgarea*100.0
         zz = (im GE 90b) AND (im LT 100b) & interior = total(zz)/fgarea*100.0
       endif else begin
         zz = (im GE 90b) AND (im LE 100b) & interior = total(zz)/fgarea*100.0
       endelse     
       zz = (im GE 60b) AND (im LT 90b) & dominant = total(zz)/fgarea*100.0
       zz = (im GE 40b) AND (im LT 60b) & transitional = total(zz)/fgarea*100.0
       zz = (im GE 10b) AND (im LT 40b) & patchy = total(zz)/fgarea*100.0 & z = 0
       zz = (im LT 10b) & rare = total(zz)/fgarea*100.0 & zz = 0
     endif else begin
       ;; 5 class or 2-class Forest Europe 4.7
       zz = (im GE 90b) AND (im LE 100b) & interior = total(zz)/fgarea*100.0
       zz = (im GE 60b) AND (im LT 90b) & dominant = total(zz)/fgarea*100.0
       zz = (im GE 40b) AND (im LT 60b) & transitional = total(zz)/fgarea*100.0
       zz = (im GE 10b) AND (im LT 40b) & patchy = total(zz)/fgarea*100.0 & z = 0
       zz = (im LT 10b) & rare = total(zz)/fgarea*100.0 & zz = 0
       zz = (im GE 40b) AND (im LE 100b) & continuous = total(zz)/fgarea*100.0
       zz = (im LT 40b) & separated = total(zz)/fgarea*100.0 & zz = 0
     endelse

     ;; write statistics out to disk in tmp to be copied later if files are saved
     z = strtrim(ulong64(fgarea),2)
     fx = info.dir_tmp + 'fos.txt' & file_delete,fx,/allow_nonexistent,/quiet
     openw,12,fx
     printf, 12, fostype + ': Fixed Observation Scale summary analysis for image: '
     printf, 12, fname
     printf, 12, '================================================================================'
     IF info.mspa_param1_id EQ 1b THEN conn_str = '8-conn FG' ELSE conn_str = '4-conn FG'
     printf, 12, conn_str + ': area, # patches, aps [pixels]: ', z, ', ', z80,', ', z81
     IF ct4b GT 0 THEN printf, 12, 'Non-fragmenting background pixels [4b] in input image'
     printf, 12, 'Fragmentation class at observation scale: ' + hec + ' hectares/' + acr + ' acres'
     printf, 12, '(Pixel resolution: ' + pixres_str + '[m], Window size: ' + kdim_str + 'x' + kdim_str +')'
     printf, 12, '================================================================================'
     if strlen(fostype) eq 4 then begin
       printf, 12, format='(a14,f11.4)', 'Rare: ', rare
       printf, 12, format='(a14,f11.4)', 'Patchy: ', patchy
       printf, 12, format='(a14,f11.4)', 'Transitional: ', transitional
       printf, 12, format='(a14,f11.4)', 'Dominant: ', dominant
       printf, 12, format='(a14,f11.4)', 'Interior: ', interior
       if fosclass eq 'FOS 6-class' then printf, 12, format='(a14,f11.4)', 'Intact: ', intact    
     endif else begin ;; FOS-APP
       printf, 12, 'FOS-APP 5-class:'
       printf, 12, format='(a14,f11.4)', 'Rare: ', rare
       printf, 12, format='(a14,f11.4)', 'Patchy: ', patchy
       printf, 12, format='(a14,f11.4)', 'Transitional: ', transitional
       printf, 12, format='(a14,f11.4)', 'Dominant: ', dominant
       printf, 12, format='(a14,f11.4)', 'Interior: ', interior
       printf, 12, 'FOS-APP 2-class:'
       printf, 12, format='(a14,f11.4)', 'Separated: ', separated
       printf, 12, format='(a14,f11.4)', 'Continuous: ', continuous
     endelse
     printf, 12, '================================================================================'
     printf, 12, format='(a14,f11.4)', 'FOS_av: ', strtrim(fad_av,2)
     close, 12
     
     ;; d) write csv output
     fn_out = info.dir_tmp + 'fos.csv'
     openw,12,fn_out
     printf,12, fostype + ': FragmClass\ObsScale: ' + hec + ' hectares/' + acr + ' acres (Pixel resolution: ' + pixres_str + '[m] - Window size: ' + kdim_str + 'x' + kdim_str +')'
     if strlen(fostype) eq 4 then begin
       if fostype eq 'FOS6' then printf, 12, 'FOS 6-class:' else printf, 12, 'FOS 5-class:'
       printf,12, 'Rare:, ' + strtrim(rare,2)
       printf,12, 'Patchy:, ' + strtrim(patchy,2)
       printf,12, 'Transitional:, ' + strtrim(transitional,2)
       printf,12, 'Dominant:, ' + strtrim(dominant,2)
       printf,12, 'Interior:, ' + strtrim(interior,2)
       if fosclass eq 'FOS 6-class' then printf,12, 'Intact:, ' + strtrim(intact,2)
     endif else begin
       printf,12, 'FOS-APP 5-class:'
       printf,12, 'Rare:, ' + strtrim(rare,2)
       printf,12, 'Patchy:, ' + strtrim(patchy,2)
       printf,12, 'Transitional:, ' + strtrim(transitional,2)
       printf,12, 'Dominant:, ' + strtrim(dominant,2)
       printf,12, 'Interior:, ' + strtrim(interior,2)
       printf,12, 'FOS-APP 2-class:'
       printf,12, 'Separated:, ' + strtrim(separated,2)
       printf,12, 'Continuous:, ' + strtrim(continuous,2)
     endelse
     printf, 12, 'FOS_av:, ', strtrim(fad_av,2)
     close,12    
     
     ;; show the summary image statistics
     xdisplayfile, info.dir_tmp + 'fos.txt', title = 'FOS statistics'

     ;; save stats summary in idl format for potential change analysis at some later point
     save, filename=info.dir_tmp + 'fos.sav', fostype, $
       xdim, ydim, geotiff_log, rare, patchy, transitional, dominant, interior, intact, separated, continuous, fad_av, fgarea, obj_last, $
       conn_str, pixres_str, kdim_str, hec, acr
       
     ;; return stuff into info GTB infostructure
     * info.process = temporary(im)
     * info.fr_image = * info.process
     
     if fosclass eq 'FOS 6-class' or fosclass eq 'FOS-APP 5-class' then begin
       restore, info.dir_guidossub + 'fadcolors.sav' & info.disp_colors_id = 8 ;; FAD colors
     endif else if fosclass eq 'FOS 5-class' then begin
       restore, info.dir_guidossub + 'fadcolors5.sav' & info.disp_colors_id = 9 ;; FAD colors
     endif else if fosclass eq 'FOS-APP 2-class' then begin
       restore, info.dir_guidossub + 'fe47colors.sav' & info.disp_colors_id = 10 ;; FAD 2-class colors (Forest Europe 4.7)
     endif
     tvlct, r, g, b
     info.ctbl = - 1 & info.autostretch_id = 0 
     info.add_title = ' (' + fosclass + ': ' + kdim_str + 'x' + kdim_str + ': ' + hec + ' hectares/' + acr + ' acres)'

     ;; reset mspa and use info.is_fragm also for FAD
     info.is_mspa = 0 & info.mspa_stats_show = 0b & info.is_fragm = 3 & info.is_contort = 0
     info.do_mspa_stats_id = 0 & info.is_cs22 = 0 & info.is_nw = 0 & info.is_cost = 0
     info.do_label_groups_id = 0

   END
   
;;*****************************************************************************************************

   'batch_fos':  BEGIN
     tit = 'Select (Geo-)Tif-files'
     im_file = $
       dialog_pickfile(Title = tit, get_path = path2file, $
       path = info.dir_data, $
       default_extension = 'tif', / fix_filter, $
       / must_exist, $
       / multiple_files, filter = ['*.tif', '*.tiff'])
     IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected

     ;; test that the directory of the selected files has no sub-directories
     pushd, path2file
     list = file_search() & nl = n_elements(list) & nr_dir = 0
     for idx = 0, nl-1 do begin
       q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
     endfor
     IF nr_dir GT 0 THEN BEGIN
       msg = 'The directory of your Batch FOS input files contains sub-directories.'  +  string(10b) +  string(10b) + $
         'Please set up a new directory having Batch FOS input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     popd
     

     ;; do the loop processing now
     ;; files are now selected, reset the GUI
     ;;========================================================================
     ;; reset the front image and block any events
     ;;========================================================================
     title = 'FOS Batch Processing'
     goto, resetfront

     backto_batch_fos:
     desc = 'GTB_FOS, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
     ;; show the fos-selection window
     ;; define required pointers for FOS
     cancel = ptr_new(1b)
     pres = ptr_new(25) ;; pixel resolution
     wdim = ptr_new(5) ;; window edge length = kdim
     conn = ptr_new('8') ;; fg-conn
     ftype = ptr_new('')

     ;; get the fos settings
     gdal = 'gdalinfo: we assume all batch images have the same pixel resolution, correct?'
     get_fos, ftype = ftype, conn = conn,pres = pres, wdim = wdim, gdal = gdal, cancel = cancel, Group_Leader = event.top, $
       title = 'Please set: PixelResolution [m] x square WindowSize = Observation Scale'

     ;; check if cancel was selected then do nothing else apply the
     ;; default or new kernel
     IF * cancel NE 0b THEN BEGIN
       ptr_free, cancel & cancel = 0b
       ptr_free, pres & pres = 0b
       ptr_free, wdim & wdim = 0b
       ptr_free, conn & conn = 0b
       ptr_free, ftype & ftype = 0b
       GOTO, fin
     ENDIF
     pixres = float(* pres) & pixres_str = * pres
     kdim = fix(* wdim) & kdim_str = * wdim
     fgconn_str = * conn
     fosclass = * ftype

     if fosclass eq 'FOS 5-class' then fostype = 'FOS5'
     if fosclass eq 'FOS 6-class' then fostype = 'FOS6'
     if fosclass eq 'FOS-APP 2-class' then fostype = 'FOS-APP2'
     if fosclass eq 'FOS-APP 5-class' then fostype = 'FOS-APP5'


     hec = ((pixres * kdim)^2) / 10000.0
     acr = hec * 2.47105
     hec = strtrim(hec,2)
     acr = strtrim(acr,2)

     ;; free and delete the temporary pointers
     ptr_free, cancel & cancel = 0b
     ptr_free, pres & pres = 0b
     ptr_free, wdim & wdim = 0b
     ptr_free, conn & conn = 0b
     ptr_free, ftype & ftype = 0b
     
     ;; test that we can write into the parent directory or if it exists already
     if fosclass eq 'FOS 5-class' then batch_type = 'batch_FOS5'
     if fosclass eq 'FOS 6-class' then batch_type = 'batch_FOS6'
     if fosclass eq 'FOS-APP 2-class' then batch_type = 'batch_FOS-APP2'
     if fosclass eq 'FOS-APP 5-class' then batch_type = 'batch_FOS-APP5'
     
     dd = file_dirname(im_file[0], / mark_directory)
     dir_batch = file_dirname(dd, / mark_directory) + batch_type + '_' + kdim_str + info.os_sep
     res = file_test(dir_batch, /directory, /write)
     if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.' + string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
       res = dialog_message(msg,/question)
       If res eq 'No' then goto, fin
       ;; empty it
       pushd, dir_batch
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd
     endif else begin ;; does not exist yet, create it
       file_mkdir, dir_batch
     endelse    

     ;; validate and process the images in a loop
     fn_logfile = dir_batch + strlowcase(strmid(batch_type,6)) + '_' + kdim_str + '.log'
     nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
     IF info.mspa_param1_id EQ 1b THEN conn_str = '8-conn FG: ' ELSE conn_str = '4-conn FG: '
     openw, 9, fn_logfile
     printf, 9, fostype + ' batch processing logfile: ', systime()
     printf, 9, strmid(conn_str,0,9) + ', Pixel resolution: ' + pixres_str + $
      '[m], Window size: ' + kdim_str + 'x' + kdim_str
     printf, 9, 'Observation scale: ' + hec + ' hectares/' + acr + ' acres'
     printf, 9, 'Number of files to be processed: ', nr_im_files
     printf, 9, '==============================================='
     close, 9

     msg = 'Processing selected images for ' + fostype +', please wait...'
     progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
     progressBar -> Start

     FOR fidx = 0, nr_im_files - 1 DO BEGIN
       counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
       ;; validate the input, if not skip it without message
       IF progressBar -> CheckCancel() THEN BEGIN
         res = Dialog_Message('Batch-processing cancelled by user.')
         openw, 9, fn_logfile, /append
         printf, 9, 'Batch-processing cancelled by user.'
         close, 9
         progressBar -> Destroy
         Obj_Destroy, progressBar
         tvlct, rini, gini, bini
         GOTO, fin
       ENDIF

       input = im_file(fidx)
       res = strpos(input,' ') ge 0
       IF res EQ 1 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid FOS input (empty space in directory path or input filename): ', input
         close, 9
         GOTO, skip_batch_fos  ;; invalid input
       ENDIF

       type = '' & res = query_image(input, type=type)
       IF type NE 'TIFF' THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid FOS input (not a TIFF image): ', input
         close, 9
         GOTO, skip_batch_fos  ;; invalid input
       ENDIF

       res = query_tiff(input, geotiff = geotiffinfo)
       IF res EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid FOS input file: ', input
         close, 9
         GOTO, skip_batch_fos  ;; invalid input
       ENDIF

       image0 = read_tiff(input)  ;; read and check it
       sz = size(image0,/dim) & xdim=sz[0] & ydim=sz[1] & imgminsize=(xdim<ydim)
       
       IF kdim ge imgminsize THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid FOS input file (Kernel dimension larger than x or y image dimension.): ', input
         printf, 9, ' ' , input
         close, 9
         GOTO, skip_batch_fos  ;; invalid input
       ENDIF


       LM_Compliance, input, image0, 'fad', info.immaxsizeg, 0, result
       IF result EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid FOS input file: ', input
         close, 9
         GOTO, skip_batch_fos  ;; invalid input
       ENDIF

       ;; now all is ok for processing
       time0 = systime( / sec)
       widget_control, / hourglass
  
       ;; image properties
       qmiss = where(image0 eq 0b,ctmiss, /l64) & q3b = where(image0 eq 3b, ct3b, /l64) & q4b = where(image0 eq 4b, ct4b, /l64)
       BGmask = where(image0 EQ 1b, /l64) & qFG = where(image0 eq 2b, /l64, fgarea) & fad_av = -1.0

       ;; get average patch size and # of patches
       ext1 = lonarr(sz[0] + 2, sz[1] + 2)
       ext1[1:sz[0], 1:sz[1]] = long(image0 eq 2b)
       conn8 = fgconn_str eq '8'
       ;; label FG only
       ext1 = label_region(ext1, all_neighbors=conn8, / ulong)
       if strmid(fosclass,0,7) eq 'FOS-APP' then obj_area = histogram(ext1, reverse_indices = rev, /l64) else obj_area = histogram(ext1, / l64)
       obj_last=max(ext1) & ext1 = 0
       aps = total(obj_area[1:*]) / obj_last & z81 = strtrim(aps,2) & obj_area = 0 & z80 = strtrim(obj_last,2)
       z20 = '# Patches: ' + z80 & z22 = 'APS: ' + z81

       ;; calculate FAD for the fixed observation scale
       IF ct4b GT 0 THEN image0[q4b] = 0b
       ;; run spatcon P2
       spatcon, image0, kdim, 'p2', info.dir_tmp, info.my_os, info.resfloat, im
       ;; rescale to normalized byte range
       if info.resfloat eq 0 then begin
         ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
         ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
         ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels
         q = where(im eq 255b, ct, /l64)
         im = (temporary(im) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
         im = byte(round(temporary(im) * 100.0))
         if ct gt 0 then im[q] = 100b
       endif else begin
         im = byte(round(im*100.0))
       endelse
       ;; calculate pixel-based fad_av
       fad_av = mean(im(qFG)) & qFG = 0
       
       ;; do we want APP?
       if strmid(fosclass,0,7) eq 'FOS-APP' then begin
         extim = bytarr(sz[0] + 2, sz[1] + 2)
         extim[1:sz[0], 1:sz[1]] = im
         FOR i = 1l, obj_last DO BEGIN
           av = byte(round(mean(extim[rev[rev[i]:rev[i + 1] - 1]])))
           extim[rev[rev[i]:rev[i + 1] - 1]] = av
         ENDFOR
         im = extim[1:sz[0], 1:sz[1]] & extim=0
       endif

       ;; add specialBG (105b), specialBG-Nf (106b), Missing (102b), background (101b)
       if ct3b gt 0 then im[q3b] = 105b & q3b = 0
       if ct4b gt 0 then im[q4b] = 106b & q4b = 0
       if ctmiss gt 0 then im[qmiss] = 102b
       qmiss = 0
       im[BGmask] = 101b & BGmask = 0 
       
       ;; the statistics, first initialize
       intact = -1 & interior = -1 & dominant = -1 & transitional = -1
       patchy = -1 & rare = -1 & separated = -1 & continuous = -1
       if fosclass eq 'FOS 6-class' then begin
         ;; get the 6 fragmentation proportions 
         zz = (im EQ 100b) & intact = total(zz)/fgarea*100.0
         zz = (im GE 90b) AND (im LT 100b) & interior = total(zz)/fgarea*100.0
         zz = (im GE 60b) AND (im LT 90b) & dominant = total(zz)/fgarea*100.0
         zz = (im GE 40b) AND (im LT 60b) & transitional = total(zz)/fgarea*100.0
         zz = (im GE 10b) AND (im LT 40b) & patchy = total(zz)/fgarea*100.0 & z = 0
         zz = (im LT 10b) & rare = total(zz)/fgarea*100.0 & zz = 0
       endif else begin
         ;; 5-class or 2-class Forest Europe 4.7
         zz = (im GE 90b) AND (im LE 100b) & interior = total(zz)/fgarea*100.0
         zz = (im GE 60b) AND (im LT 90b) & dominant = total(zz)/fgarea*100.0
         zz = (im GE 40b) AND (im LT 60b) & transitional = total(zz)/fgarea*100.0
         zz = (im GE 10b) AND (im LT 40b) & patchy = total(zz)/fgarea*100.0 & z = 0
         zz = (im LT 10b) & rare = total(zz)/fgarea*100.0 & zz = 0
         zz = (im GE 40b) AND (im LE 100b) & continuous = total(zz)/fgarea*100.0
         zz = (im LT 40b) & separated = total(zz)/fgarea*100.0 & zz = 0
       endelse    
       
       ;; write the final result to the initial input dir
       fbn = file_basename(input, '.tif')
       outdir = dir_batch + fbn + '_' + strlowcase(fostype) + '_' + kdim_str

       ;; setup the output directory for the current image file
       file_mkdir, outdir
       pushd, outdir
       if fosclass eq 'FOS 6-class' or fosclass eq 'FOS-APP 5-class' then begin
         restore, info.dir_guidossub + 'fadcolors.sav'  ;; FAD colors
       endif else if fosclass eq 'FOS-APP 2-class' then begin
         restore, info.dir_guidossub + 'fe47colors.sav' ;; FAD 2-class colors (Forest Europe 4.7)
       endif else if fosclass eq 'FOS 5-class' then begin
         restore, info.dir_guidossub + 'fadcolors5.sav'
       endif
       tvlct, r, g, b

       ;; a) the fullres classified summary image
       ;; first save the visual summary result
       fn_out = fbn + '_' + strlowcase(fostype) + '_' + kdim_str + '.tif'
       ;; add the geotiff info if available
       IF (size(geotiffinfo))[0] gt 0 THEN BEGIN
         write_tiff, fn_out, im, red = r, green = g, blue = b, geotiff = geotiffinfo, description = desc, compression = 1
       ENDIF ELSE BEGIN
         write_tiff, fn_out, im, red = r, green = g, blue = b, description = desc, compression = 1
       ENDELSE
       im = 0

       ;; b) the statistics       
       fn_out = fbn + '_' + strlowcase(fostype) + '_' + kdim_str + '.txt'
       ;; write statistics out to disk in tmp to be copied later if files are saved
       z = strtrim(ulong64(fgarea),2)
       openw,12,fn_out
       printf, 12, fostype + ': Fixed Observation Scale summary analysis for image: '
       printf, 12, input
       printf, 12, '================================================================================'
       printf, 12, conn_str + 'area, # patches, aps [pixels]: ', z, ', ', z80,', ', z81
       IF ct4b GT 0 THEN printf, 12, 'Non-fragmenting background pixels [4b] in input image'
       printf, 12, 'Fragmentation class at observation scale: ' + hec + ' hectares/' + acr + ' acres'
       printf, 12, '(Pixel resolution: ' + pixres_str + '[m], Window size: ' + kdim_str + 'x' + kdim_str +')'
       printf, 12, '================================================================================'
       if fosclass eq 'FOS 6-class' or fosclass eq 'FOS 5-class' then begin
         printf, 12, fosclass + ':'
         printf, 12, format='(a14,f11.4)', 'Rare: ', rare
         printf, 12, format='(a14,f11.4)', 'Patchy: ', patchy
         printf, 12, format='(a14,f11.4)', 'Transitional: ', transitional
         printf, 12, format='(a14,f11.4)', 'Dominant: ', dominant
         printf, 12, format='(a14,f11.4)', 'Interior: ', interior
         if fosclass eq 'FOS 6-class' then printf, 12, format='(a14,f11.4)', 'Intact: ', intact
       endif else begin
         printf, 12, 'FOS-APP 5-class:'
         printf, 12, format='(a14,f11.4)', 'Rare: ', rare
         printf, 12, format='(a14,f11.4)', 'Patchy: ', patchy
         printf, 12, format='(a14,f11.4)', 'Transitional: ', transitional
         printf, 12, format='(a14,f11.4)', 'Dominant: ', dominant
         printf, 12, format='(a14,f11.4)', 'Interior: ', interior
         printf, 12, 'FOS-APP 2-class:'
         printf, 12, format='(a14,f11.4)', 'Separated: ', separated
         printf, 12, format='(a14,f11.4)', 'Continuous: ', continuous
       endelse
       printf, 12, '================================================================================'
       printf, 12, format='(a14,f11.4)', 'FOS_av: ', strtrim(fad_av,2)
       close, 12
       
       ;; c) the sav-file
       ;; check if we have a geotiff image
       geotiff_log = '' ;; gdal geotiff-information
       if (size(geotiffinfo))[0] gt 0 then begin
         IF info.my_os EQ 'windows' THEN BEGIN
                  cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalinfo -noct "' + input + '"'
         ENDIF ELSE BEGIN
         if strlen(info.sysgdal) gt 0 then $
             cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + input + '"' else $
             cmd = info.dir_fwtools + 'gdalinfo -noct "' + input + '"'
         ENDELSE
         IF info.my_os EQ 'windows' THEN spawn, cmd, geotiff_log, / hide ELSE spawn, cmd, geotiff_log
       endif       
       
       fn_out = fbn + '_' + strlowcase(fostype) + '_' + kdim_str + '.sav'
       save, filename = fn_out, fostype, $
         xdim, ydim, geotiff_log, rare, patchy, transitional, dominant, interior, intact, separated, continuous, fad_av, fgarea, obj_last, $
         conn_str, pixres_str, kdim_str, hec, acr       
         
       ;; d) write csv output
       fn_out = fbn + '_' + strlowcase(fostype) + '_' + kdim_str + '.csv'
       openw,12,fn_out
       printf,12, fostype + ': FragmClass\ObsScale: ' + hec + ' hectares/' + acr + ' acres (Pixel resolution: ' + pixres_str + '[m] - Window size: ' + kdim_str + 'x' + kdim_str +')'
       if fosclass eq 'FOS 6-class' or fosclass eq 'FOS 5-class'  then begin
         printf,12, 'Rare:, ' + strtrim(rare,2)
         printf,12, 'Patchy:, ' + strtrim(patchy,2)
         printf,12, 'Transitional:, ' + strtrim(transitional,2)
         printf,12, 'Dominant:, ' + strtrim(dominant,2)
         printf,12, 'Interior:, ' + strtrim(interior,2)
         if fosclass eq 'FOS 6-class' then printf,12, 'Intact:, ' + strtrim(intact,2)
       endif else begin
         printf,12, 'FOS-APP 5-class:'
         printf,12, 'Rare:, ' + strtrim(rare,2)
         printf,12, 'Patchy:, ' + strtrim(patchy,2)
         printf,12, 'Transitional:, ' + strtrim(transitional,2)
         printf,12, 'Dominant:, ' + strtrim(dominant,2)
         printf,12, 'Interior:, ' + strtrim(interior,2)
         printf,12, 'FOS-APP 2-class:'
         printf,12, 'Separated:, ' + strtrim(separated,2)
         printf,12, 'Continuous:, ' + strtrim(continuous,2)
       endelse
       printf, 12, 'FOS_av:, ', strtrim(fad_av,2)
       close,12

       okfile = okfile + 1
       ;; go back to the FOS image directory
       popd

       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'File: ' + input
       printf, 9, fostype + ' comp.time [sec]: ', systime( / sec) - time0
       close, 9

       skip_batch_fos:
       stepn = (fidx + 1.0)/nr_im_files * 100.0
       progressBar -> Update, stepn
     ENDFOR
     progressBar -> Destroy
     Obj_Destroy, progressBar

     ;; inform that batch is done
     proct = systime( / sec) - time00
     IF proct GT 3600.0 THEN BEGIN
       proct2 = proct - ulong(proct/3600)*3600
       proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDIF ELSE BEGIN
       proctstr = strtrim(ulong(proct/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDELSE
     IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
     openw, 9, fn_logfile, /append
     printf, 9, ''
     printf, 9, '==============================================='
     printf, 9, fostype + ' Batch Processing total comp.time: ', proctstr
     printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
     printf, 9, '==============================================='
     close, 9

     msg = fostype + ' Batch Processing finished.' + string(10b) + $
       'Total computation time: ' + proctstr + string(10b) + $
       'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
       'More information can be found in the logfile: ' + string(10b) + fn_logfile
     res = dialog_message(msg, / information)
     ;; reset the colortable to the settings before the batch processing
     tvlct, rini, gini, bini
     GOTO, fin
   END
  
   ;;*****************************************************************************************************

   'kernel_p2':  BEGIN
      ;; check for input compliance:
      ;; 1) if already a mspa image then quit
      IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_contort GT 0 OR info.is_nw EQ 1 OR info.is_cost EQ 1 THEN BEGIN
         res = dialog_message(info.wronginput, / information)
         GOTO, fin
      ENDIF

      ;; 2) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
         info.selsubregion_id = 0
         ;; deactivate zoomfactor selector
         widget_control, info.w_zoomfac, sensitive = 1
         widget_control, info.w_selsubregion, $
                         set_value = 'Zoom Mode'
         ;; restore the prezoomed process image
         * info.process = * info.prezoomprocess
         ;; disable button and enable motion events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 1
         widget_control, info.w_draw, Draw_Button_Events = 0
         info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF

      ;; 3) check input compliance
      fname = info.fname_input 
      ;; assign the full resolution image
      image0 = * info.fr_image     
      MSPA_Compliance, fname, image0, info.immaxsizeg, 1, result
      IF result EQ 0 THEN GOTO, fin  ;; invalid input


      ;; define a pointer to the default kernel, 5 x 5
      kdim = 5 & def_kernel = replicate(1, kdim, kdim)
      cancel = ptr_new(1b)
      selected_kernel = ptr_new(def_kernel)
      ;; get the kernel settings, make square & binary
      get_kernel, selected_kernel = selected_kernel, $
       cancel = cancel, Group_Leader = event.top, / binary, / square, /noedit, $
       title = 'Select kernel dimension'
      ;; check if cancel was selected then do nothing else apply the
      ;; default or new kernel
      IF * cancel NE 0b THEN BEGIN
        ptr_free, cancel & cancel = 0b
        ptr_free, selected_kernel & selected_kernel = 0b
        GOTO, fin
      ENDIF
      kdim = * selected_kernel & kdim = (size(kdim))[1]
      qmiss = where(image0 eq 0b,ctmiss, /l64)
      
      q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
      IF kdim ge imgminsize THEN BEGIN
        res = dialog_message('Kernel dimension larger than x or y image dimension. ' + $
          string(10b) + 'Returning...', / information)
        GOTO, fin
      ENDIF

      widget_control, / hourglass
      BGmask = where(image0 EQ 1b, /l64) 
      spatcon, image0, kdim, 'p2', info.dir_tmp, info.my_os, info.resfloat, im
      
      ;; rescale to normalized byte range
      if info.resfloat eq 0 then begin
        ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
        ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
        ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels  
        q = where(im eq 255b, ct, /l64)
        im = (temporary(im) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
        im = byte(round(temporary(im) * 100.0))
        if ct gt 0 then im[q] = 100b
      endif else begin
        im = byte(round(im*100.0))
      endelse
      imtmp = im & px_mask = where(imtmp ge 0b, /l64)
     
      ;; start with a background color image
      im = imtmp *0b +101b        
      ;; add FG and Missing(102b) 
      im[px_mask] = imtmp[px_mask] & imtmp=0 & px_mask=0
      if ctmiss gt 0 then im[qmiss] = 102b

      ;; backup original image for doing the FG-masking
      save, BGmask, im, ctmiss, qmiss, filename = info.dir_tmp + 'mask.sav',/compress & BGmask = 0
      * info.nw_ids = im
      * info.process = temporary(im)
      * info.fr_image = * info.process
      restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
      info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 5 ;; entropy

      ;; free and delete the temporary pointers
      ptr_free, cancel & cancel = 0b
      ptr_free, selected_kernel & selected_kernel = 0b
      zz = '; tick Divide for new P2 range settings; Intext for FG masking'
      info.add_title = ' (P2: FG density, kdim=' + strtrim(kdim, 2) + zz + ')'
      ;; set Intext to off
      info.mspa_param4_id = 0b
      widget_control, info.w_mspa_param4, set_value = info.mspa_param4_id
      
      ;; reset mspa and use info.is_fragm also for P2
      info.is_mspa = 0 & info.mspa_stats_show = 0b & info.is_fragm = 2 & info.is_contort = 0
      info.do_mspa_stats_id = 0 & info.is_cs22 = 0 & info.is_nw = 0 & info.is_cost = 0
      info.do_label_groups_id = 0

      ;Divide panel settings
      widget_control, info.w_labelstr, set_value = 'Density range: '
      widget_control, info.w_label_t1, set_value = ['X','10','30','50']
      widget_control, info.w_label_t2, set_value = ['X','60','70','80']
      widget_control, info.w_label_t1, set_combobox_select = 1 & info.label_t1 = 10
      widget_control, info.w_label_t2, set_combobox_select = 1 & info.label_t2 = 60
            
   END

   ;;*****************************************************************************************************

   'batch_p2':  BEGIN
      tit = 'Select (Geo-)Tif-files'
      im_file = $
        dialog_pickfile(Title = tit, get_path = path2file, $
                        path = info.dir_data, $
                        default_extension = 'tif', / fix_filter, $
                        / must_exist, $
                        / multiple_files, filter = ['*.tif', '*.tiff'])
      IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
      
      ;; test that the directory of the selected files has no sub-directories
      ;; this will also ensure no output file is opened in excel or thelike
      pushd, path2file
      list = file_search() & nl = n_elements(list) & nr_dir = 0
      for idx = 0, nl-1 do begin
        q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
      endfor
      IF nr_dir GT 0 THEN BEGIN
        msg = 'The directory of your Batch P2 input files contains sub-directories.'  +  string(10b) +  string(10b) + $
          'Please set up a new directory having Batch P2 input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF
      popd  
      
      ;; define a pointer to the default kernel, 5 x 5
      kdim = 5 & def_kernel = replicate(1, kdim, kdim)
      cancel = ptr_new(1b)
      selected_kernel = ptr_new(def_kernel)
      ;; get the kernel settings, make square & binary
      get_kernel, selected_kernel = selected_kernel, $
        cancel = cancel, Group_Leader = event.top, / binary, / square, /noedit, $
        title = 'Select kernel dimension'
      ;; check if cancel was selected then do nothing else apply the
      ;; default or new kernel

      IF * cancel NE 0b THEN BEGIN
        ptr_free, cancel & cancel = 0b
        ptr_free, selected_kernel & selected_kernel = 0b
        GOTO, fin
      ENDIF
      kdim = * selected_kernel & kdim = (size(kdim))[1] & kdim_str = strtrim(kdim, 2)

      
      ;; test that we can write into the parent directory or if it exists already
      batch_type = 'batch_P2'
      dd = file_dirname(im_file[0], / mark_directory)
      dir_batch = file_dirname(dd, / mark_directory) + batch_type + '_' + kdim_str + info.os_sep
      res = file_test(dir_batch, /directory, /write)
      if res eq 1 then begin ;; dir_batch already exists
        msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
          'already exists. All previous content will be erased before we continue.'+ string(10b) + $
          "Please click 'Yes' to confirm or 'No' to exit"
        res = dialog_message(msg,/question)
        If res eq 'No' then goto, fin
        ;; empty it
        pushd, dir_batch
        list = file_search() & nl = n_elements(list)
        if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
        popd
      endif else begin ;; does not exist yet, create it
        file_mkdir, dir_batch
      endelse


      ;; do the loop processing now
      ;; files are now selected, reset the GUI
      ;;========================================================================
      ;; reset the front image and block any events
      ;;========================================================================
      title = 'P2 Batch Processing'
      goto, resetfront

      backto_batch_p2:

      ;; validate and process the images in a loop
      fn_logfile = dir_batch + batch_type + '_' + kdim_str  + '.log'
      nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l

      openw, 9, fn_logfile
      printf, 9, 'P2 batch processing logfile: ', systime()
      printf, 9, 'Number of files to be processed: ', nr_im_files
      printf, 9, '==============================================='
      close, 9
      msg = 'Processing selected images for P2, please wait...'
      progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
      progressBar -> Start


      FOR fidx = 0, nr_im_files - 1 DO BEGIN
        counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
        ;; validate the input, if not skip it without message
        IF progressBar -> CheckCancel() THEN BEGIN
          res = Dialog_Message('Batch-processing cancelled by user.')
          openw, 9, fn_logfile, /append
          printf, 9, 'Batch-processing cancelled by user.'
          close, 9
          progressBar -> Destroy
          Obj_Destroy, progressBar
          tvlct, rini, gini, bini
          GOTO, fin
        ENDIF

        input = im_file(fidx)
        res = strpos(input,' ') ge 0
        IF res EQ 1 THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid P2 input (empty space in directory path or input filename): ', input
          close, 9
          GOTO, skip_batch_p2  ;; invalid input
        ENDIF

        type = '' & res = query_image(input, type=type)
        IF type NE 'TIFF' THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid P2 input (not a TIFF image): ', input
          close, 9
          GOTO, skip_batch_p2  ;; invalid input
        ENDIF

        res = query_tiff(input, geotiff = geotiffinfo)
        IF res EQ 0 THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid P2 input file: ', input
          close, 9
          GOTO, skip_batch_p2  ;; invalid input
        ENDIF

        image0 = read_tiff(input)  ;; read and check it
        MSPA_Compliance, input, image0, info.immaxsizeg * 10, 0, result
        q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
        IF result EQ 0 OR kdim ge imgminsize THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid P2 input file: ', input
          close, 9
          GOTO, skip_batch_p2  ;; invalid input
        ENDIF

        ;; now all is ok for processing
        time0 = systime( / sec)
        qmiss = where(image0 eq 0b,ctmiss, /l64) & BGmask = where(image0 EQ 1b, /l64)
        widget_control, / hourglass
        spatcon, image0, kdim, 'p2', info.dir_tmp, info.my_os, info.resfloat, im

        ;; rescale to normalized byte range
        if info.resfloat eq 0 then begin
         ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
         ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
         ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels  
         q = where(im eq 255b, ct, /l64)
         im = (temporary(im) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
         im = byte(round(temporary(im) * 100.0))
         if ct gt 0 then im[q] = 100b
        endif else begin
         im = byte(round(im*100.0))
       endelse
        
        ;; apply FG-mask and add Missing
        im[BGmask] = 101b
        if ctmiss gt 0 then im[qmiss] = 102b

        ;; write the final result to the initial input dir
        res = file_basename(input, '.tif')
        fn_out = dir_batch + res + '_p2_' + kdim_str + '.tif'
        restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
        
        ;; add the geotiff info if available
        desc = 'GTB_P2, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
        IF (size(geotiffinfo))[0] gt 0 THEN $
          write_tiff, fn_out, im, red = r, green = g, blue = b, description = desc, geotiff = geotiffinfo, compression = 1 ELSE $
          write_tiff, fn_out, im, red = r, green = g, blue = b, description = desc, compression = 1
        im = 0
        okfile = okfile + 1
        openw, 9, fn_logfile, /append
        printf, 9, ' '
        printf, 9, '==============   ' + counter + '   =============='
        printf, 9, 'File: ' + input
        printf, 9, 'P2 comp.time [sec]: ', systime( / sec) - time0
        close, 9

        skip_batch_p2:
        stepn = (fidx + 1.0)/nr_im_files * 100.0
        progressBar -> Update, stepn
      ENDFOR
      progressBar -> Destroy
      Obj_Destroy, progressBar

      ;; inform that batch is done
      proct = systime( / sec) - time00
      IF proct GT 3600.0 THEN BEGIN
        proct2 = proct - ulong(proct/3600)*3600
        proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
          ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
      ENDIF ELSE BEGIN
        proctstr = strtrim(ulong(proct/60.),2) + $
          ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
      ENDELSE
      IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
      openw, 9, fn_logfile, /append
      printf, 9, ''
      printf, 9, '==============================================='
      printf, 9, 'P2 Batch Processing total comp.time: ', proctstr
      printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
      printf, 9, '==============================================='
      close, 9

      msg = 'P2 Batch Processing finished.' + string(10b) + $
        'Total computation time: ' + proctstr + string(10b) + $
        'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
        'More information can be found in the logfile: ' + string(10b) + fn_logfile
      res = dialog_message(msg, / information)
      ;; reset the colortable to the settings before the batch processing
      tvlct, rini, gini, bini

      ;; free and delete the temporary pointers
      ptr_free, cancel & cancel = 0b
      ptr_free, selected_kernel & selected_kernel = 0b
      GOTO, fin
   END


   ;;*****************************************************************************************************

   'kernel_p22':  BEGIN
      ;; check for input compliance:
      ;; 1) if already a mspa image then quit
      IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_contort GT 0 OR info.is_nw EQ 1 OR info.is_cost EQ 1 THEN BEGIN
         res = dialog_message(info.wronginput, / information)
         GOTO, fin
      ENDIF

      ;; 2) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
         info.selsubregion_id = 0
         ;; deactivate zoomfactor selector
         widget_control, info.w_zoomfac, sensitive = 1
         widget_control, info.w_selsubregion, $
                         set_value = 'Zoom Mode'
         ;; restore the prezoomed process image
         * info.process = * info.prezoomprocess
         ;; disable button and enable motion events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 1
         widget_control, info.w_draw, Draw_Button_Events = 0
         info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF

      ;; 3) check input compliance
      MSPA_Compliance, info.fname_input, * info.fr_image, info.immaxsizeg, $
                       1, result
      IF result EQ 0 THEN GOTO, fin  ;; invalid input

      ;; assign the full resolution image
      image0 = * info.fr_image

      ;; define a pointer to the default kernel, 5 x 5
      kdim = 5 & def_kernel = replicate(1, kdim, kdim)
      cancel = ptr_new(1b)
      selected_kernel = ptr_new(def_kernel)
      ;; get the kernel settings, make square & binary
      get_kernel, selected_kernel = selected_kernel, $
       cancel = cancel, Group_Leader = event.top, / binary, / square, /noedit, $
       title = 'Select kernel dimension'
      ;; check if cancel was selected then do nothing else apply the
      ;; default or new kernel
      IF * cancel NE 0b THEN BEGIN
        ptr_free, cancel & cancel = 0b
        ptr_free, selected_kernel & selected_kernel = 0b
        GOTO, fin
      ENDIF
      kdim = * selected_kernel & kdim = (size(kdim))[1]
      qmiss = where(image0 eq 0b,ctmiss, /l64)
      
      q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
      IF kdim ge imgminsize THEN BEGIN
        res = dialog_message('Kernel dimension larger than x or y image dimension. ' + $
          string(10b) + 'Returning...', / information)
        GOTO, fin
      ENDIF
 
      widget_control, / hourglass
      BGmask = where(image0 EQ 1b, /l64)
      spatcon, image0, kdim, 'p22', info.dir_tmp, info.my_os, info.resfloat, im

      ;; rescale to normalized byte range
      if info.resfloat eq 0 then begin
        ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
        ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
        ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels
        q = where(im eq 255b, ct, /l64)
        im = (temporary(im) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
        im = byte(round(temporary(im) * 100.0))
        if ct gt 0 then im[q] = 100b
      endif else begin
        im = byte(round(im*100.0))
      endelse
      imtmp = im & px_mask = where(imtmp ge 0b, /l64)

      ;; start with a background color image
      im = imtmp *0b +101b
      ;; add FG and Missing(102b)
      im[px_mask] = imtmp[px_mask] & imtmp=0 & px_mask=0
      if ctmiss gt 0 then im[qmiss] = 102b
     
      ;; backup original image for doing the FG-masking
      save, BGmask, im, ctmiss, qmiss, filename = info.dir_tmp + 'mask.sav',/compress & BGmask = 0 
      * info.nw_ids = im
      * info.process = temporary(im)
      * info.fr_image = * info.process
      restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
      info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 5 ;; entropy

      ;; free and delete the temporary pointers
      ptr_free, cancel & cancel = 0b
      ptr_free, selected_kernel & selected_kernel = 0b
      zz = '; tick Divide for new P22 range settings; Intext for FG masking'
      info.add_title = ' (P22: FG contagion, kdim=' + strtrim(kdim, 2) + zz + ')'
      ;; set Intext to off
      info.mspa_param4_id = 0b
      widget_control, info.w_mspa_param4, set_value = info.mspa_param4_id

      ;; reset mspa and use info.is_fragm also for P22
      info.is_mspa = 0 & info.mspa_stats_show = 0b & info.is_fragm = 2 & info.is_contort = 0
      info.do_mspa_stats_id = 0 & info.is_cs22 = 0 & info.is_nw = 0 & info.is_cost = 0
      info.do_label_groups_id = 0

      ;Divide panel settings
      widget_control, info.w_labelstr, set_value = 'Contagion range: '
      widget_control, info.w_label_t1, set_value = ['X','10','30','50']
      widget_control, info.w_label_t2, set_value = ['X','60','70','80']
      widget_control, info.w_label_t1, set_combobox_select = 1 & info.label_t1 = 10
      widget_control, info.w_label_t2, set_combobox_select = 1 & info.label_t2 = 60

   END


   ;;*****************************************************************************************************

   'batch_p22':  BEGIN
      tit = 'Select (Geo-)Tif-files'
      im_file = $
        dialog_pickfile(Title = tit, get_path = path2file, $
                        path = info.dir_data, $
                        default_extension = 'tif', / fix_filter, $
                        / must_exist, $
                        / multiple_files, filter = ['*.tif', '*.tiff'])
      IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
      
      ;; test that the directory of the selected files has no sub-directories
      ;; this will also ensure no output file is opened in excel or thelike
      pushd, path2file
      list = file_search() & nl = n_elements(list) & nr_dir = 0
      for idx = 0, nl-1 do begin
        q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
      endfor
      IF nr_dir GT 0 THEN BEGIN
        msg = 'The directory of your Batch P22 input files contains sub-directories.'  +  string(10b) +  string(10b) + $
          'Please set up a new directory having Batch P22 input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF
      popd
        
      ;; define a pointer to the default kernel, 5 x 5
      kdim = 5 & def_kernel = replicate(1, kdim, kdim)
      cancel = ptr_new(1b)
      selected_kernel = ptr_new(def_kernel)
      ;; get the kernel settings, make square & binary
      get_kernel, selected_kernel = selected_kernel, $
        cancel = cancel, Group_Leader = event.top, / binary, / square, /noedit, $
        title = 'Select kernel dimension'
      ;; check if cancel was selected then do nothing else apply the
      ;; default or new kernel

      IF * cancel NE 0b THEN BEGIN
        ptr_free, cancel & cancel = 0b
        ptr_free, selected_kernel & selected_kernel = 0b
        GOTO, fin
      ENDIF
      kdim = * selected_kernel & kdim = (size(kdim))[1] & kdim_str = strtrim(kdim, 2)

      
      ;; test that we can write into the parent directory or if it exists already
      batch_type = 'batch_P22'
      dd = file_dirname(im_file[0], / mark_directory)
      dir_batch = file_dirname(dd, / mark_directory) + batch_type + '_' + kdim_str + info.os_sep
      res = file_test(dir_batch, /directory, /write)
      if res eq 1 then begin ;; dir_batch already exists
        msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
          'already exists. All previous content will be erased before we continue.'+ string(10b) + $
          "Please click 'Yes' to confirm or 'No' to exit"
        res = dialog_message(msg,/question)
        If res eq 'No' then goto, fin
        ;; empty it
        pushd, dir_batch
        list = file_search() & nl = n_elements(list)
        if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
        popd
      endif else begin ;; does not exist yet, create it
        file_mkdir, dir_batch
      endelse


      ;; files are now selected, reset the GUI
      ;;========================================================================
      ;; reset the front image and block any events
      ;;========================================================================
      title = 'P22 Batch Processing'
      goto, resetfront

      backto_batch_p22:

      ;; do the loop processing now
      ;; validate and process the images in a loop
      ;; do the loop processing now
      ;; validate and process the images in a loop
      fn_logfile = dir_batch + batch_type + '_' + kdim_str + '.log'
      nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
      openw, 9, fn_logfile
      printf, 9, 'P22 batch processing logfile: ', systime()
      printf, 9, 'Number of files to be processed: ', nr_im_files
      printf, 9, '==============================================='
      close, 9
      msg = 'Processing selected images for P22, please wait...'
      progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
      progressBar -> Start

      
      FOR fidx = 0, nr_im_files - 1 DO BEGIN
        counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
        ;; validate the input, if not skip it without message        
        IF progressBar -> CheckCancel() THEN BEGIN
          res = Dialog_Message('Batch-processing cancelled by user.')
          openw, 9, fn_logfile, /append
          printf, 9, 'Batch-processing cancelled by user.'
          close, 9
          progressBar -> Destroy
          Obj_Destroy, progressBar
          tvlct, rini, gini, bini
          GOTO, fin
        ENDIF

        input = im_file(fidx)
        res = strpos(input,' ') ge 0
        IF res EQ 1 THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid P22 input (empty space in directory path or input filename): ', input
          close, 9
          GOTO, skip_batch_p22  ;; invalid input
        ENDIF
        
        type = '' & res = query_image(input, type=type)
        IF type NE 'TIFF' THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid P22 input (not a TIFF image): ', input
          close, 9
          GOTO, skip_batch_p22  ;; invalid input
        ENDIF

        res = query_tiff(input, geotiff = geotiffinfo)
        IF res EQ 0 THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid P22 input file: ', input
          close, 9
          GOTO, skip_batch_p22  ;; invalid p22 input
        ENDIF

        image0 = read_tiff(input)  ;; read and check it
        MSPA_Compliance, input, image0, info.immaxsizeg * 10, 0, result
        q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
        IF result EQ 0 OR kdim ge imgminsize THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid P22 input file: ', input
          close, 9
          GOTO, skip_batch_p22  ;; invalid p22 input
        ENDIF

        ;; now all is ok for processing
        time0 = systime( / sec)
        qmiss = where(image0 eq 0b,ctmiss, /l64) & BGmask = where(image0 EQ 1b, /l64)
        widget_control, / hourglass

        spatcon, image0, kdim, 'p22', info.dir_tmp, info.my_os, info.resfloat, im
        
        ;; rescale to normalized byte range
        if info.resfloat eq 0 then begin
          ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
          ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
          ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels
          q = where(im eq 255b, ct, /l64)
          im = (temporary(im) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
          im = byte(round(temporary(im) * 100.0))
          if ct gt 0 then im[q] = 100b
        endif else begin
          im = byte(round(im*100.0))
        endelse

        ;; apply FG-mask and add Missing
        im[BGmask] = 101b
        if ctmiss gt 0 then im[qmiss] = 102b

        ;; write the final result to the initial input dir
        res = file_basename(input, '.tif')
        fn_out = dir_batch + res + '_p22_' + kdim_str + '.tif'
        restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b

        ;; add the geotiff info if available
        desc = 'GTB_P22, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
        IF (size(geotiffinfo))[0] gt 0 THEN $
          write_tiff, fn_out, im, red = r, green = g, blue = b, description = desc, geotiff = geotiffinfo, compression = 1 ELSE $
          write_tiff, fn_out, im, red = r, green = g, blue = b, description = desc, compression = 1
        im = 0
        okfile = okfile + 1
        openw, 9, fn_logfile, /append
        printf, 9, ' '
        printf, 9, '==============   ' + counter + '   =============='
        printf, 9, 'File: ' + input
        printf, 9, 'P22 comp.time [sec]: ', systime( / sec) - time0
        close, 9

        skip_batch_p22:
        stepn = (fidx + 1.0)/nr_im_files * 100.0
        progressBar -> Update, stepn
      ENDFOR
      progressBar -> Destroy
      Obj_Destroy, progressBar

      ;; inform that batch is done
      proct = systime( / sec) - time00
      IF proct GT 3600.0 THEN BEGIN
        proct2 = proct - ulong(proct/3600)*3600
        proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
          ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
      ENDIF ELSE BEGIN
        proctstr = strtrim(ulong(proct/60.),2) + $
          ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
      ENDELSE
      IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
      openw, 9, fn_logfile, /append
      printf, 9, ''
      printf, 9, '==============================================='
      printf, 9, 'P22 Batch Processing total comp.time: ', proctstr
      printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
      printf, 9, '==============================================='
      close, 9

      msg = 'P22 Batch Processing finished.' + string(10b) + $
        'Total computation time: ' + proctstr + string(10b) + $
        'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
        'More information can be found in the logfile: ' + string(10b) + fn_logfile
      res = dialog_message(msg, / information)
      ;; reset the colortable to the settings before the batch processing
      tvlct, rini, gini, bini

      ;; free and delete the temporary pointers
      ptr_free, cancel & cancel = 0b
      ptr_free, selected_kernel & selected_kernel = 0b
      GOTO, fin
   END

   ;;*****************************************************************************************************

   'kernel_p23':  BEGIN
      ;; check for input compliance:
      ;; 1) if already a mspa image then quit
      IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_contort GT 0 OR info.is_nw EQ 1 OR info.is_cost EQ 1 THEN BEGIN
        res = dialog_message(info.wronginput, / information)
        GOTO, fin
      ENDIF

      ;; 2) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
        info.selsubregion_id = 0
        ;; deactivate zoomfactor selector
        widget_control, info.w_zoomfac, sensitive = 1
        widget_control, info.w_selsubregion, $
          set_value = 'Zoom Mode'
        ;; restore the prezoomed process image
        * info.process = * info.prezoomprocess
        ;; disable button and enable motion events in w_draw
        widget_control, info.w_draw, Draw_Motion_Events = 1
        widget_control, info.w_draw, Draw_Button_Events = 0
        info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF

      ;; 3) check input compliance
      LM_Compliance, info.fname_input, * info.fr_image, 'p23', info.immaxsizeg, 1, result
      IF result EQ 0 THEN GOTO, fin  ;; invalid input

      ;; assign the full resolution image
      image0 = * info.fr_image

      ;; define a pointer to the default kernel, 5 x 5
      kdim = 5 & def_kernel = replicate(1, kdim, kdim)
      cancel = ptr_new(1b)
      selected_kernel = ptr_new(def_kernel)
      ;; get the kernel settings, make square & binary
      get_kernel, selected_kernel = selected_kernel, $
        cancel = cancel, Group_Leader = event.top, / binary, / square, /noedit, $
        title = 'Select kernel dimension'
      ;; check if cancel was selected then do nothing else apply the
      ;; default or new kernel
      IF * cancel NE 0b THEN BEGIN
        ptr_free, cancel & cancel = 0b
        ptr_free, selected_kernel & selected_kernel = 0b
        GOTO, fin
      ENDIF
      kdim = * selected_kernel & kdim = (size(kdim))[1]
      qmiss = where(image0 eq 0b,ctmiss, /l64)
      
      q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
      IF kdim ge imgminsize THEN BEGIN
        res = dialog_message('Kernel dimension larger than x or y image dimension. ' + $
          string(10b) + 'Returning...', / information)
        GOTO, fin
      ENDIF

      widget_control, / hourglass
      BGmask = where(image0 EQ 1b, /l64)
      spatcon, image0, kdim, 'p23', info.dir_tmp, info.my_os, info.resfloat, im

      ;; rescale to normalized byte range
      if info.resfloat eq 0 then begin
        ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
        ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
        ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels
        q = where(im eq 255b, ct, /l64)
        im = (temporary(im) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
        im = byte(round(temporary(im) * 100.0))
        if ct gt 0 then im[q] = 100b
      endif else begin
        im = byte(round(im*100.0))
      endelse
      imtmp = im & px_mask = where(imtmp ge 0b, /l64)

      ;; start with a background color image
      im = imtmp *0b +101b
      ;; add FG and Missing(102b)
      im[px_mask] = imtmp[px_mask] & imtmp=0 & px_mask=0
      if ctmiss gt 0 then im[qmiss] = 102b
     
      ;; backup original image for doing the FG-masking
      save, BGmask, im, ctmiss, qmiss, filename = info.dir_tmp + 'mask.sav',/compress & BGmask = 0
      * info.nw_ids = im
      * info.process = temporary(im)
      * info.fr_image = * info.process
      restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
      info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 5 ;; entropy

      ;; free and delete the temporary pointers
      ptr_free, cancel & cancel = 0b
      ptr_free, selected_kernel & selected_kernel = 0b
      zz = '; tick Divide for new P23 range settings; Intext for FG masking'
      info.add_title = ' (P23: FG/interesting BG edges, kdim=' + strtrim(kdim, 2) + zz + ')'
      ;; set Intext to off
      info.mspa_param4_id = 0b
      widget_control, info.w_mspa_param4, set_value = info.mspa_param4_id

      ;; reset mspa and use info.is_fragm also for P23
      info.is_mspa = 0 & info.mspa_stats_show = 0b & info.is_fragm = 2 & info.is_contort = 0
      info.do_mspa_stats_id = 0 & info.is_cs22 = 0 & info.is_nw = 0 & info.is_cost = 0
      info.do_label_groups_id = 0

      ;Divide panel settings
      widget_control, info.w_labelstr, set_value = 'P23 range: '
      widget_control, info.w_label_t1, set_value = ['X','10','30','50']
      widget_control, info.w_label_t2, set_value = ['X','60','70','80']
      widget_control, info.w_label_t1, set_combobox_select = 1 & info.label_t1 = 10
      widget_control, info.w_label_t2, set_combobox_select = 1 & info.label_t2 = 60    
      
    END
    
    ;;*****************************************************************************************************

    'batch_p23':  BEGIN
      tit = 'Select (Geo-)Tif-files'
      im_file = $
        dialog_pickfile(Title = tit, get_path = path2file, $
        path = info.dir_data, $
        default_extension = 'tif', / fix_filter, $
        / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
      IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
      
      ;; test that the directory of the selected files has no sub-directories
      ;; this will also ensure no output file is opened in excel or thelike
      pushd, path2file
      list = file_search() & nl = n_elements(list) & nr_dir = 0
      for idx = 0, nl-1 do begin
        q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
      endfor
      IF nr_dir GT 0 THEN BEGIN
        msg = 'The directory of your Batch P23 input files contains sub-directories.'  +  string(10b) +  string(10b) + $
          'Please set up a new directory having Batch P23 input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF
      popd
      
      ;; define a pointer to the default kernel, 5 x 5
      kdim = 5 & def_kernel = replicate(1, kdim, kdim)
      cancel = ptr_new(1b)
      selected_kernel = ptr_new(def_kernel)
      ;; get the kernel settings, make square & binary
      get_kernel, selected_kernel = selected_kernel, $
        cancel = cancel, Group_Leader = event.top, / binary, / square, /noedit, $
        title = 'Select kernel dimension'
      ;; check if cancel was selected then do nothing else apply the
      ;; default or new kernel

      IF * cancel NE 0b THEN BEGIN
        ptr_free, cancel & cancel = 0b
        ptr_free, selected_kernel & selected_kernel = 0b
        GOTO, fin
      ENDIF
      kdim = * selected_kernel & kdim = (size(kdim))[1] & kdim_str = strtrim(kdim, 2)
      
      ;; test that we can write into the parent directory or if it exists already
      batch_type = 'batch_P23'
      dd = file_dirname(im_file[0], / mark_directory)
      dir_batch = file_dirname(dd, / mark_directory) + batch_type + '_' + kdim_str + info.os_sep
      res = file_test(dir_batch, /directory, /write)
      if res eq 1 then begin ;; dir_batch already exists
        msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
          'already exists. All previous content will be erased before we continue.'+ string(10b) + $
          "Please click 'Yes' to confirm or 'No' to exit"
        res = dialog_message(msg,/question)
        If res eq 'No' then goto, fin
        ;; empty it
        pushd, dir_batch
        list = file_search() & nl = n_elements(list)
        if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
        popd
      endif else begin ;; does not exist yet, create it
        file_mkdir, dir_batch
      endelse

      ;; files are now selected, reset the GUI
      ;;========================================================================
      ;; reset the front image and block any events
      ;;========================================================================
      title = 'P23 Batch Processing'
      goto, resetfront
 
      backto_batch_p23:

      ;; do the loop processing now
      ;; validate and process the images in a loop
      ;; do the loop processing now
      ;; validate and process the images in a loop
      fn_logfile = dir_batch + batch_type + '_' + kdim_str + '.log'
      nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
      openw, 9, fn_logfile
      printf, 9, 'P23 batch processing logfile: ', systime()
      printf, 9, 'Number of files to be processed: ', nr_im_files
      printf, 9, '==============================================='
      close, 9
      msg = 'Processing selected images for P23, please wait...'
      progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
      progressBar -> Start
   
      FOR fidx = 0, nr_im_files - 1 DO BEGIN
        counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
        ;; validate the input, if not skip it without message
        IF progressBar -> CheckCancel() THEN BEGIN
          res = Dialog_Message('Batch-processing cancelled by user.')
          openw, 9, fn_logfile, /append
          printf, 9, 'Batch-processing cancelled by user.'
          close, 9
          progressBar -> Destroy
          Obj_Destroy, progressBar
          tvlct, rini, gini, bini
          GOTO, fin
        ENDIF

        input = im_file(fidx)
        res = strpos(input,' ') ge 0
        IF res EQ 1 THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid P23 input (empty space in directory path or input filename): ', input
          close, 9
          GOTO, skip_batch_p23  ;; invalid input
        ENDIF
        
        type = '' & res = query_image(input, type=type)
        IF type NE 'TIFF' THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid P23 input (not a TIFF image): ', input
          close, 9
          GOTO, skip_batch_p23  ;; invalid input
        ENDIF

        res = query_tiff(input, geotiff = geotiffinfo)
        IF res EQ 0 THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid P23 input file: ', input
          close, 9
          GOTO, skip_batch_p23  ;; invalid P23 input
        ENDIF

        image0 = read_tiff(input)  ;; read and check it
        LM_Compliance, input, image0, 'p23', info.immaxsizeg * 10, 0, result
        q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
        IF result EQ 0 OR kdim ge imgminsize THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid P23 input file: ', input
          close, 9
          GOTO, skip_batch_p23  ;; invalid P23 input
        ENDIF

        ;; now all is ok for processing
        time0 = systime( / sec)
        qmiss = where(image0 eq 0b,ctmiss, /l64) & BGmask = where(image0 EQ 1b, /l64)
        widget_control, / hourglass

        spatcon, image0, kdim, 'p23', info.dir_tmp, info.my_os, info.resfloat, im

        ;; rescale to normalized byte range
        if info.resfloat eq 0 then begin
          ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
          ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
          ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels
          q = where(im eq 255b, ct, /l64)
          im = (temporary(im) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
          im = byte(round(temporary(im) * 100.0))
          if ct gt 0 then im[q] = 100b
        endif else begin
          im = byte(round(im*100.0))
        endelse

        ;; apply FG-mask and add Missing
        im[BGmask] = 101b
        if ctmiss gt 0 then im[qmiss] = 102b

        ;; write the final result to the initial input dir
        res = file_basename(input, '.tif')
        fn_out = dir_batch + res + '_p23_' + kdim_str + '.tif'
         restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b

        ;; add the geotiff info if available
        desc = 'GTB_P23, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
        IF (size(geotiffinfo))[0] gt 0 THEN $
          write_tiff, fn_out, im, red = r, green = g, blue = b, description = desc, geotiff = geotiffinfo, compression = 1 ELSE $
          write_tiff, fn_out, im, red = r, green = g, blue = b, description = desc, compression = 1
        im = 0
        okfile = okfile + 1
        openw, 9, fn_logfile, /append
        printf, 9, ' '
        printf, 9, '==============   ' + counter + '   =============='
        printf, 9, 'File: ' + input
        printf, 9, 'P23 comp.time [sec]: ', systime( / sec) - time0
        close, 9

        skip_batch_p23:
        stepn = (fidx + 1.0)/nr_im_files * 100.0
        progressBar -> Update, stepn
    ENDFOR
    progressBar -> Destroy
    Obj_Destroy, progressBar


    ;; inform that batch is done
    proct = systime( / sec) - time00
    IF proct GT 3600.0 THEN BEGIN
      proct2 = proct - ulong(proct/3600)*3600
      proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
        ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
    ENDIF ELSE BEGIN
      proctstr = strtrim(ulong(proct/60.),2) + $
        ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
    ENDELSE
    IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
    openw, 9, fn_logfile, /append
    printf, 9, ''
    printf, 9, '==============================================='
    printf, 9, 'P23 Batch Processing total comp.time: ', proctstr
    printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
    printf, 9, '==============================================='
    close, 9

    msg = 'P23 Batch Processing finished.' + string(10b) + $
      'Total computation time: ' + proctstr + string(10b) + $
      'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
      'More information can be found in the logfile: ' + string(10b) + fn_logfile
    res = dialog_message(msg, / information)
    ;; reset the colortable to the settings before the batch processing
    tvlct, rini, gini, bini

    ;; free and delete the temporary pointers
    ptr_free, cancel & cancel = 0b
    ptr_free, selected_kernel & selected_kernel = 0b
    GOTO, fin
   END
   
   ;;*****************************************************************************************************

   'batch_recode':  BEGIN
     ;; 0) use sample file for batch recode setup    
     tit = 'Select a (Geo-)Tif-file to setup recoding'
     input = $
       dialog_pickfile(Title = tit, get_path = path2file, $
       path = info.dir_data, default_extension = 'tif', / fix_filter, $
       / must_exist, filter = ['*.tif', '*.tiff'])
     IF input EQ '' THEN GOTO, fin ;; 'cancel' selected
     
     ;; test that the directory of the selected files has no sub-directories
     ;; this will also ensure no output file is opened in excel or thelike
     pushd, path2file
     list = file_search() & nl = n_elements(list) & nr_dir = 0
     for idx = 0, nl-1 do begin
       q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
     endfor
     IF nr_dir GT 0 THEN BEGIN
       msg = 'The directory of your Batch Recode input files contains sub-directories.'  +  string(10b) +  string(10b) + $
         'Please set up a new directory having Batch Recode input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     popd
       
     ;; in batch mode recode must use an array with all possible byte values, (set in get_xrecode)
     ;; to ensure it will work on all possible values in the input images
     cancel = ptr_new(1b) & seltab = ptr_new(1b)    
     msg = "Define a recode table from scratch or click on 'Restore'" + string(10b) + 'and load/modify an existing GTBrecode*.sav table'
     result = dialog_message(title = 'Batch Recode', / information, msg)
     tit = "Recode class values"

     ;; get the selected mapping
     pushd,info.dir_data
     get_xrecode, upv = upv, batch = 1, tit = tit, cancel = cancel, seltab=seltab, Group_Leader = event.top
     popd
     ;; check if cancel was selected then do nothing else apply the recoding table
     IF * cancel NE 0b THEN BEGIN
       ptr_free, cancel & cancel = 0b
       ptr_free, seltab & seltab = 0b
       GOTO, fin
     ENDIF
     psel = * seltab & ptr_free, seltab & seltab = 0b
     ptr_free, cancel & cancel = 0b

     ;; 1) read files
     tit = 'Select (Geo-)Tif-files for batch recoding'
     im_file = $
       dialog_pickfile(Title = tit, get_path = path2file, $
       path = info.dir_data, $
       default_extension = 'tif', / fix_filter, $
       / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
     IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
     
     ;; test that we can write into the parent directory or if it exists already
     batch_type = 'batch_Recode'
     dd = file_dirname(im_file[0], / mark_directory)
     dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
     res = file_test(dir_batch, /directory, /write)
     if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
       res = dialog_message(msg,/question)
       If res eq 'No' then goto, fin
       ;; empty it
       pushd, dir_batch
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd
     endif else begin ;; does not exist yet, create it
       file_mkdir, dir_batch
     endelse


     ;; do the loop processing now
     ;; files are now selected, reset the GUI
     ;;========================================================================
     ;; reset the front image and block any events
     ;;========================================================================
     title = 'Batch Recode Processing'
     goto, resetfront

     backto_batch_recode:

     ;; validate and process the images in a loop
     fn_logfile = dir_batch + 'batch_recode.log'
     nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
     openw, 9, fn_logfile
     printf, 9, 'Batch recode processing logfile: ', systime()
     printf, 9, 'Number of files to be processed: ', nr_im_files
     printf, 9, '==============================================='
     close, 9
     msg = 'Recoding selected images, please wait...'
     progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
     progressBar -> Start


     FOR fidx = 0, nr_im_files - 1 DO BEGIN
       counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
       ;; validate the input, if not skip it without message
       IF progressBar -> CheckCancel() THEN BEGIN
         res = Dialog_Message('Batch-processing cancelled by user.')
         openw, 9, fn_logfile, /append
         printf, 9, 'Batch-processing cancelled by user.'
         close, 9
         progressBar -> Destroy
         Obj_Destroy, progressBar
         tvlct, rini, gini, bini
         GOTO, fin
       ENDIF

       input = im_file(fidx)
       res = strpos(input,' ') ge 0
       IF res EQ 1 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid batch recode input (empty space in directory path or input filename): ', input
         close, 9
         GOTO, skip_batch_recode  ;; invalid input
       ENDIF
       
       type = '' & res = query_image(input, type=type)
       IF type NE 'TIFF' THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid batch recode input (not a TIFF image): ', input
         close, 9
         GOTO, skip_batch_recode  ;; invalid input
       ENDIF

       res = query_tiff(input, qtres, geotiff = geotiffinfo)
       res = (res eq 0) + (qtres.channels NE 1) + (qtres.num_images NE 1) + (qtres.pixel_type GT 1 )
       IF res NE 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid batch recode input file: ', input
         close, 9
         GOTO, skip_batch_recode  ;; invalid input
       ENDIF
       tmp = read_tiff(input) ;& tmp = byte(0 > tmp < 255)

       ;; now all is ok for processing
       time0 = systime( / sec)
       widget_control, / hourglass
       
       pushd, info.dir_tmp
       ;; we need these 3 files in tmp-directory: recsize.txt, recode.txt, recinput (bsq-file) -> recoutput
       sz=qtres.dimensions & pseln=rotate(psel,5)
       ;; for recode: rows first, then columns!
       openw,1, 'recsize.txt'
       printf,1,'nrows '+strtrim(sz[1],2)
       printf,1,'ncols '+strtrim(sz[0],2)
       close,1
       openw,1, 'recode.txt' & printf,1,pseln & close,1
       openw, 1, 'recinput' & writeu,1, tmp & close,1

       ;; setup recode
       IF info.my_os EQ 'windows' THEN BEGIN
         IF (!version.memory_bits EQ 64) THEN recode='..\spatcon\recode64.exe' ELSE $
           recode='..\spatcon\recode32.exe'
         file_copy, recode, 'recode.exe', /overwrite
       ENDIF ELSE IF info.my_os EQ 'apple' THEN BEGIN
         recode='../spatcon/recode_mac' & file_copy, recode, 'recode', /overwrite
       ENDIF ELSE BEGIN
         recode='../spatcon/recode_lin64' & file_copy, recode, 'recode', /overwrite
       ENDELSE

       ;; run recode in tmp
       IF info.my_os EQ 'windows' THEN spawn, 'recode.exe', log, / hide ELSE spawn, './recode', log

       ;; get result
       recoutput = temporary(tmp) * 0b
       openr, 1, 'recoutput' & readu,1, recoutput & close,1

       ;; empty dir_tmp and go back
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd

       ;; write the final result to the initial input dir
       res = file_basename(input, '.tif')
       fn_out = dir_batch + res + '_recode.tif'
       ;; get the correct colortable
       loadct,0
       ;; add the geotiff info if available      
       IF (size(geotiffinfo))[0] gt 0 THEN $
         write_tiff, fn_out, recoutput, geotiff = geotiffinfo, compression = 1 ELSE $
         write_tiff, fn_out, recoutput, compression = 1
       recoutput = 0
       okfile = okfile + 1
       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'File: ' + input
       printf, 9, 'Recode comp.time [sec]: ', systime( / sec) - time0
       close, 9

       skip_batch_recode:
       stepn = (fidx + 1.0)/nr_im_files * 100.0
       progressBar -> Update, stepn
     ENDFOR
     progressBar -> Destroy
     Obj_Destroy, progressBar

     ;; inform that batch is done
     proct = systime( / sec) - time00
     IF proct GT 3600.0 THEN BEGIN
       proct2 = proct - ulong(proct/3600)*3600
       proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDIF ELSE BEGIN
       proctstr = strtrim(ulong(proct/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDELSE
     IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
     openw, 9, fn_logfile, /append
     printf, 9, ''
     printf, 9, '==============================================='
     printf, 9, 'Batch Recode Processing total comp.time: ', proctstr
     printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
     printf, 9, '==============================================='
     close, 9

     msg = 'Batch Recode Processing finished.' + string(10b) + $
       'Total computation time: ' + proctstr + string(10b) + $
       'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
       'More information can be found in the logfile: ' + string(10b) + fn_logfile
     res = dialog_message(msg, / information)
     ;; reset the colortable to the settings before the batch processing
     tvlct, rini, gini, bini
     GOTO, fin
   END

   ;;*****************************************************************************************************

   'kernel_sumd':  BEGIN
     ;; check for input compliance:
     ;; 1) if already a mspa image then quit
     IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_contort GT 0 OR info.is_nw EQ 1 OR info.is_cost EQ 1 THEN BEGIN
       res = dialog_message(info.wronginput, / information)
       GOTO, fin
     ENDIF
     
     ;; 2) if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF
     
     ;; assign the full resolution image
     image0 = * info.fr_image

     ;; 3) check input compliance, image must be byte
     IF size(image0, / type) NE 1 THEN BEGIN
       msg = 'Input image is not of type BYTE.' + string(10b) + $
         "Try using General Tools: Preprocessing: Convert -> Byte"  + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF

     ;; define a pointer to the default kernel, 7 x 7
     kdim = 7 & def_kernel = replicate(1, kdim, kdim)
     cancel = ptr_new(1b)
     selected_kernel = ptr_new(def_kernel)
     ;; get the kernel settings, make square & binary
     get_kernel, selected_kernel = selected_kernel, $
       cancel = cancel, Group_Leader = event.top, / binary, / square, /noedit, $
       title = 'Select kernel dimension'
     ;; check if cancel was selected then do nothing else apply the
     ;; default or new kernel
     IF * cancel NE 0b THEN BEGIN
       ptr_free, cancel & cancel = 0b
       ptr_free, selected_kernel & selected_kernel = 0b
       GOTO, fin
     ENDIF
     kdim = * selected_kernel & kdim = (size(kdim))[1]
     qmiss = where(image0 eq 0b,ctmiss, /l64) 
     
     q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
     IF kdim ge imgminsize THEN BEGIN
       res = dialog_message('Kernel dimension larger than x or y image dimension. ' + $
         string(10b) + 'Returning...', / information)
       GOTO, fin
     ENDIF

     
     widget_control, / hourglass
     spatcon, image0, kdim, 'sumd', info.dir_tmp, info.my_os, info.resfloat, im

     ;; rescale to normalized byte range
     if info.resfloat eq 0 then begin
       ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
       ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
       ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels
       q = where(im eq 255b, ct, /l64)
       im = (temporary(im) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
       im = byte(round(temporary(im) * 100.0))
       if ct gt 0 then im[q] = 100b
     endif else begin
       im = byte(round(im*100.0))
     endelse

     ;; add Missing(102b)
     if ctmiss gt 0 then im[qmiss] = 102b           
     * info.process = temporary(im)
     restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
     info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 5 ;; entropy

     ;; free and delete the temporary pointers
     ptr_free, cancel & cancel = 0b
     ptr_free, selected_kernel & selected_kernel = 0b
     * info.fr_image = * info.process
     info.add_title = ' (SumD: overall contagion, kdim=' + strtrim(kdim, 2) + ')'
   END
   
   ;;*****************************************************************************************************

   'batch_sumd':  BEGIN
     tit = 'Select (Geo-)Tif-files'
     im_file = $
       dialog_pickfile(Title = tit, get_path = path2file, $
       path = info.dir_data, $
       default_extension = 'tif', / fix_filter, $
       / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
     IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
     
     ;; test that the directory of the selected files has no sub-directories
     ;; this will also ensure no output file is opened in excel or thelike
     pushd, path2file
     list = file_search() & nl = n_elements(list) & nr_dir = 0
     for idx = 0, nl-1 do begin
       q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
     endfor
     IF nr_dir GT 0 THEN BEGIN
       msg = 'The directory of your Batch SumD input files contains sub-directories.'  +  string(10b) +  string(10b) + $
         'Please set up a new directory having Batch SumD input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     popd
     
     ;; test that we can write into the parent directory or if it exists already
     batch_type = 'batch_SumD'
     dd = file_dirname(im_file[0], / mark_directory)
     dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
     res = file_test(dir_batch, /directory, /write)
     if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
          'already exists. All previous content will be erased before we continue.'+ string(10b) + $
          "Please click 'Yes' to confirm or 'No' to exit"
       res = dialog_message(msg,/question)
       If res eq 'No' then goto, fin
       ;; empty it
       pushd, dir_batch
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd
     endif else begin ;; does not exist yet, create it
       file_mkdir, dir_batch
     endelse


    
     ;; define a pointer to the default kernel, 5 x 5
     kdim = 7 & def_kernel = replicate(1, kdim, kdim)
     cancel = ptr_new(1b)
     selected_kernel = ptr_new(def_kernel)
     ;; get the kernel settings, make square & binary
     get_kernel, selected_kernel = selected_kernel, $
       cancel = cancel, Group_Leader = event.top, / binary, / square, /noedit, $
       title = 'Select kernel dimension'
     ;; check if cancel was selected then do nothing else apply the
     ;; default or new kernel
    
     IF * cancel NE 0b THEN BEGIN
       ptr_free, cancel & cancel = 0b
       ptr_free, selected_kernel & selected_kernel = 0b
       GOTO, fin
     ENDIF
    
     kdim = * selected_kernel & kdim = (size(kdim))[1]
    
     ;; files are now selected, reset the GUI
     ;;========================================================================
     ;; reset the front image and block any events
     ;;========================================================================
     title = 'SumD Batch Processing'
     goto, resetfront

     backto_batch_sumd:
    
     ;; do the loop processing now
     ;; validate and process the images in a loop
     ;; do the loop processing now
     ;; validate and process the images in a loop
     fn_logfile = dir_batch + batch_type + '.log'
     nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
     openw, 9, fn_logfile
     printf, 9, 'SumD batch processing logfile: ', systime()
     printf, 9, 'Number of files to be processed: ', nr_im_files
     printf, 9, '==============================================='
     close, 9
     msg = 'Processing selected images for SumD, please wait...'
     progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
     progressBar -> Start
    
     FOR fidx = 0, nr_im_files - 1 DO BEGIN
       counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
       ;; validate the input, if not skip it without message
       IF progressBar -> CheckCancel() THEN BEGIN
         res = Dialog_Message('Batch-processing cancelled by user.')
         openw, 9, fn_logfile, /append
         printf, 9, 'Batch-processing cancelled by user.'
         close, 9
         progressBar -> Destroy
         Obj_Destroy, progressBar
         tvlct, rini, gini, bini
         GOTO, fin
       ENDIF
    
       input = im_file(fidx)
       res = strpos(input,' ') ge 0
       IF res EQ 1 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid SumD input (empty space in directory path or input filename): ', input
         close, 9
         GOTO, skip_batch_sumd  ;; invalid input
       ENDIF
       
       type = '' & res = query_image(input, type=type)
       IF type NE 'TIFF' THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid SumD input (not a TIFF image): ', input
         close, 9
         GOTO, skip_batch_sumd  ;; invalid input
       ENDIF

       res = query_tiff(input, geotiff = geotiffinfo)
       IF res EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid SumD input file: ', input
         close, 9
         GOTO, skip_batch_sumd  ;; invalid sumd input
       ENDIF
    
       image0 = read_tiff(input)  ;; read and check it
       q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)      
       IF size(image0, / type) NE 1 OR kdim ge imgminsize THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid sumd input file: ', input
         close, 9
         GOTO, skip_batch_sumd  ;; invalid sumd input
       ENDIF   
    
       ;; now all is ok for processing
       qmiss = where(image0 eq 0b,ctmiss, /l64)
       time0 = systime( / sec)
       widget_control, / hourglass 
       spatcon, image0, kdim, 'sumd', info.dir_tmp, info.my_os, info.resfloat, im
    
       ;; rescale to normalized byte range
       if info.resfloat eq 0 then begin
         ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
         ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
         ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels
         q = where(im eq 255b, ct, /l64)
         im = (temporary(im) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
         im = byte(round(temporary(im) * 100.0))
         if ct gt 0 then im[q] = 100b
       endif else begin
         im = byte(round(im*100.0))
       endelse
    
       ;; add Missing(102b)
       if ctmiss gt 0 then im[qmiss] = 102b
       ;; write the final result to the initial input dir
       res = file_basename(input, '.tif')
       fn_out = dir_batch + res + '_sumd_' + strtrim(kdim, 2) + '.tif'
       ;; get the correct colortable
       ;if okfile eq 0 then begin
         restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
       ;endif
    
       ;; add the geotiff info if available
       IF (size(geotiffinfo))[0] gt 0 THEN $
         write_tiff, fn_out, im, red = r, green = g, blue = b, geotiff = geotiffinfo, compression = 1 ELSE $
         write_tiff, fn_out, im, red = r, green = g, blue = b, compression = 1
       im = 0
       okfile = okfile + 1
       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'File: ' + input
       printf, 9, 'SumD comp.time [sec]: ', systime( / sec) - time0
       close, 9
    
       skip_batch_sumd:
       stepn = (fidx + 1.0)/nr_im_files * 100.0
       progressBar -> Update, stepn       
     ENDFOR
     progressBar -> Destroy
     Obj_Destroy, progressBar
    
     ;; inform that batch is done
     proct = systime( / sec) - time00
     IF proct GT 3600.0 THEN BEGIN
       proct2 = proct - ulong(proct/3600)*3600
       proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDIF ELSE BEGIN
       proctstr = strtrim(ulong(proct/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDELSE
     IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
     openw, 9, fn_logfile, /append
     printf, 9, ''
     printf, 9, '==============================================='
     printf, 9, 'SumD Batch Processing total comp.time: ', proctstr
     printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
     printf, 9, '==============================================='
     close, 9
    
     msg = 'SumD Batch Processing finished.' + string(10b) + $
       'Total computation time: ' + proctstr + string(10b) + $
       'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
       'More information can be found in the logfile: ' + string(10b) + fn_logfile
     res = dialog_message(msg, / information)
     ;; reset the colortable to the settings before the batch processing
     tvlct, rini, gini, bini
    
     ;; free and delete the temporary pointers
     ptr_free, cancel & cancel = 0b
     ptr_free, selected_kernel & selected_kernel = 0b
     GOTO, fin
     END

     ;;*****************************************************************************************************

     'kernel_shannon':  BEGIN
     widget_control, / hourglass
     ;; check for input compliance:
     ;; 1) if already a mspa image then quit
     IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_contort GT 0 OR info.is_nw EQ 1 OR info.is_cost EQ 1 THEN BEGIN
       res = dialog_message(info.wronginput, / information)
       GOTO, fin
     ENDIF

     ;; 2) if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF

     ;; assign the full resolution image
     image0 = * info.fr_image
     
     ;; 3) check input compliance, image must be byte
     IF size(image0, / type) NE 1 THEN BEGIN
       msg = 'Input image is not of type BYTE.' + string(10b) + $
         "Try using General Tools: Preprocessing: Convert -> Byte"  + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF

     ;; define a pointer to the default kernel, 7 x 7
     kdim = 7 & def_kernel = replicate(1, kdim, kdim)
     cancel = ptr_new(1b)
     selected_kernel = ptr_new(def_kernel)
     ;; get the kernel settings, make square & binary
     get_kernel, selected_kernel = selected_kernel, $
       cancel = cancel, Group_Leader = event.top, / binary, / square, /noedit, $
       title = 'Select kernel dimension'
     ;; check if cancel was selected then do nothing else apply the
     ;; default or new kernel
     IF * cancel NE 0b THEN BEGIN
       ptr_free, cancel & cancel = 0b
       ptr_free, selected_kernel & selected_kernel = 0b
       GOTO, fin
     ENDIF
     kdim = * selected_kernel & kdim = (size(kdim))[1]
     qmiss = where(image0 eq 0b,ctmiss, /l64) & fg = image0 eq 2b
     
     q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
     IF kdim ge imgminsize THEN BEGIN
       res = dialog_message('Kernel dimension larger than x or y image dimension. ' + $
         string(10b) + 'Returning...', / information)
       GOTO, fin
     ENDIF

     ;; reset mspa
     info.is_mspa = 0 & info.mspa_stats_show = 0b & info.is_fragm = 0 & info.is_contort = 0
     info.do_mspa_stats_id = 0 & info.is_cs22 = 0 & info.is_nw = 0 & info.is_cost = 0
     info.do_label_groups_id = 0 & info.selsubregion_id = 0
     widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
     
     widget_control, / hourglass
     spatcon, image0, kdim, 'shannon', info.dir_tmp, info.my_os, info.resfloat, im

     ;; rescale to normalized byte range
     if info.resfloat eq 0 then begin
       ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
       ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
       ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels
       q = where(im eq 255b, ct, /l64)
       im = (temporary(im) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
       im = byte(round(temporary(im) * 100.0))
       if ct gt 0 then im[q] = 100b
     endif else begin
       im = byte(round(im*100.0))
     endelse

     ;; add Missing(102b)
     if ctmiss gt 0 then im[qmiss] = 102b & * info.process = temporary(im)
     restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
     info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 5 ;; entropy

     ;; free and delete the temporary pointers
     ptr_free, cancel & cancel = 0b
     ptr_free, selected_kernel & selected_kernel = 0b
     * info.fr_image = * info.process
     info.add_title = ' (Shannon edge-type evenness: kdim=' + strtrim(kdim, 2) + ')'

   END
   
   ;;*****************************************************************************************************

   'batch_shannon':  BEGIN
     tit = 'Select (Geo-)Tif-files'
     im_file = $
       dialog_pickfile(Title = tit, get_path = path2file, $
       path = info.dir_data, $
       default_extension = 'tif', / fix_filter, $
       / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
     IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
     
     ;; test that the directory of the selected files has no sub-directories
     ;; this will also ensure no output file is opened in excel or thelike
     pushd, path2file
     list = file_search() & nl = n_elements(list) & nr_dir = 0
     for idx = 0, nl-1 do begin
       q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
     endfor
     IF nr_dir GT 0 THEN BEGIN
       msg = 'The directory of your Batch Shannon input files contains sub-directories.'  +  string(10b) +  string(10b) + $
         'Please set up a new directory having Batch Shannon input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     popd
     
     ;; test that we can write into the parent directory or if it exists already
     batch_type = 'batch_Shannon'
     dd = file_dirname(im_file[0], / mark_directory)
     dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
     res = file_test(dir_batch, /directory, /write)
     if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
       res = dialog_message(msg,/question)
       If res eq 'No' then goto, fin
       ;; empty it
       pushd, dir_batch
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd
     endif else begin ;; does not exist yet, create it
       file_mkdir, dir_batch
     endelse
  
     ;; define a pointer to the default kernel, 5 x 5
     kdim = 7 & def_kernel = replicate(1, kdim, kdim)
     cancel = ptr_new(1b)
     selected_kernel = ptr_new(def_kernel)
     ;; get the kernel settings, make square & binary
     get_kernel, selected_kernel = selected_kernel, $
       cancel = cancel, Group_Leader = event.top, / binary, / square, /noedit, $
       title = 'Select kernel dimension'
     ;; check if cancel was selected then do nothing else apply the
     ;; default or new kernel
  
     IF * cancel NE 0b THEN BEGIN
       ptr_free, cancel & cancel = 0b
       ptr_free, selected_kernel & selected_kernel = 0b
       GOTO, fin
     ENDIF
  
     kdim = * selected_kernel & kdim = (size(kdim))[1]
  
     ;; files are now selected, reset the GUI
     ;;========================================================================
     ;; reset the front image and block any events
     ;;========================================================================
     title = 'Shannon Batch Processing'
     goto, resetfront

     backto_batch_shannon:
  
     ;; do the loop processing now
     ;; validate and process the images in a loop
     ;; do the loop processing now
     ;; validate and process the images in a loop
     fn_logfile = dir_batch + batch_type + '.log'
     nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
     openw, 9, fn_logfile
     printf, 9, 'Shannon batch processing logfile: ', systime()
     printf, 9, 'Number of files to be processed: ', nr_im_files
     printf, 9, '==============================================='
     close, 9
     msg = 'Processing selected images for Shannon, please wait...'
     progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
     progressBar -> Start

     FOR fidx = 0, nr_im_files - 1 DO BEGIN
       counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
       ;; validate the input, if not skip it without message
       IF progressBar -> CheckCancel() THEN BEGIN
         res = Dialog_Message('Batch-processing cancelled by user.')
         openw, 9, fn_logfile, /append
         printf, 9, 'Batch-processing cancelled by user.'
         close, 9
         progressBar -> Destroy
         Obj_Destroy, progressBar
         tvlct, rini, gini, bini
         GOTO, fin
       ENDIF

     input = im_file(fidx)
     res = strpos(input,' ') ge 0
     IF res EQ 1 THEN BEGIN
       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'Skipping invalid Shannon input (empty space in directory path or input filename): ', input
       close, 9
       GOTO, skip_batch_shannon  ;; invalid input
     ENDIF
     
     type = '' & res = query_image(input, type=type)
     IF type NE 'TIFF' THEN BEGIN
       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'Skipping invalid Shannon input (not a TIFF image): ', input
       close, 9
       GOTO, skip_batch_shannon  ;; invalid input
     ENDIF

     res = query_tiff(input, geotiff = geotiffinfo)
     IF res EQ 0 THEN BEGIN
       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'Skipping invalid Shannon input file: ', input
       close, 9
       GOTO, skip_batch_shannon 
     ENDIF

     image0 = read_tiff(input)  ;; read and check it
     q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)     
     IF size(image0, / type) NE 1 OR kdim ge imgminsize THEN BEGIN
       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'Skipping invalid Shannon input file: ', input
       close, 9
       GOTO, skip_batch_shannon  
     ENDIF

     ;; now all is ok for processing
     qmiss=where(image0 eq 0b,ctmiss, /l64)
     time0 = systime( / sec)
     widget_control, / hourglass

     spatcon, image0, kdim, 'shannon', info.dir_tmp, info.my_os, info.resfloat, im

     ;; rescale to normalized byte range
     if info.resfloat eq 0 then begin
       ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
       ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
       ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels
       q = where(im eq 255b, ct, /l64)
       im = (temporary(im) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
       im = byte(round(temporary(im) * 100.0))
       if ct gt 0 then im[q] = 100b
     endif else begin
       im = byte(round(im*100.0))
     endelse

     ;; add Missing(102b)
     if ctmiss gt 0 then im[qmiss] = 102b
     ;; write the final result to the initial input dir
     res = file_basename(input, '.tif')
     fn_out = dir_batch + res + '_shannon_' + strtrim(kdim, 2) + '.tif'
     ;; get the correct colortable
     ;if okfile eq 0 then begin
       restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
     ;endif

     ;; add the geotiff info if available
     IF (size(geotiffinfo))[0] gt 0 THEN $
       write_tiff, fn_out, im, red = r, green = g, blue = b, geotiff = geotiffinfo, compression = 1 ELSE $
       write_tiff, fn_out, im, red = r, green = g, blue = b, compression = 1
     im = 0
     okfile = okfile + 1
     openw, 9, fn_logfile, /append
     printf, 9, ' '
     printf, 9, '==============   ' + counter + '   =============='
     printf, 9, 'File: ' + input
     printf, 9, 'Shannon comp.time [sec]: ', systime( / sec) - time0
     close, 9

     skip_batch_shannon:
     stepn = (fidx + 1.0)/nr_im_files * 100.0
     progressBar -> Update, stepn
   ENDFOR
   progressBar -> Destroy
   Obj_Destroy, progressBar

   ;; inform that batch is done
   proct = systime( / sec) - time00
   IF proct GT 3600.0 THEN BEGIN
     proct2 = proct - ulong(proct/3600)*3600
     proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
       ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
   ENDIF ELSE BEGIN
     proctstr = strtrim(ulong(proct/60.),2) + $
       ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
   ENDELSE
   IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
   openw, 9, fn_logfile, /append
   printf, 9, ''
   printf, 9, '==============================================='
   printf, 9, 'Shannon Batch Processing total comp.time: ', proctstr
   printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
   printf, 9, '==============================================='
   close, 9

   msg = 'Shannon Batch Processing finished.' + string(10b) + $
     'Total computation time: ' + proctstr + string(10b) + $
     'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
     'More information can be found in the logfile: ' + string(10b) + fn_logfile
   res = dialog_message(msg, / information)
   ;; reset the colortable to the settings before the batch processing
   tvlct, rini, gini, bini

   ;; free and delete the temporary pointers
   ptr_free, cancel & cancel = 0b
   ptr_free, selected_kernel & selected_kernel = 0b
   GOTO, fin
 END

 ;;*****************************************************************************************************

   'kernel_lm':  BEGIN
      ;; check for input compliance:
      ;; 1) if already a mspa image then quit
      IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_contort GT 0 OR info.is_nw EQ 1 OR info.is_cost EQ 1 THEN BEGIN
        res = dialog_message(info.wronginput, / information)
        GOTO, fin
      ENDIF

      ;; 2) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
        info.selsubregion_id = 0
        ;; deactivate zoomfactor selector
        widget_control, info.w_zoomfac, sensitive = 1
        widget_control, info.w_selsubregion, $
          set_value = 'Zoom Mode'
        ;; restore the prezoomed process image
        * info.process = * info.prezoomprocess
        ;; disable button and enable motion events in w_draw
        widget_control, info.w_draw, Draw_Motion_Events = 1
        widget_control, info.w_draw, Draw_Button_Events = 0
        info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF
  
      ;; 3) check input compliance
      LM_Compliance, info.fname_input, * info.fr_image, 'lm', info.immaxsizeg, 1, result
      IF result EQ 0 THEN GOTO, fin  ;; invalid input
  
      ;; assign the full resolution image
      image0 = * info.fr_image
     
      ;; define a pointer to the default kernel, 5 x 5
      kdim = 5 & def_kernel = replicate(1, kdim, kdim)
      cancel = ptr_new(1b)
      selected_kernel = ptr_new(def_kernel)
      ;; get the kernel settings, make square & binary
      get_kernel, selected_kernel = selected_kernel, $
        cancel = cancel, Group_Leader = event.top, / binary, / square, /noedit, $
        title = 'Select kernel dimension'
      ;; check if cancel was selected then do nothing else apply the
      ;; default or new kernel
      IF * cancel NE 0b THEN BEGIN
        ptr_free, cancel & cancel = 0b
        ptr_free, selected_kernel & selected_kernel = 0b
        GOTO, fin
      ENDIF
      kdim = * selected_kernel & kdim = (size(kdim))[1] & kdim_str = strtrim(kdim, 2)
      ;; free and delete the temporary pointers
      ptr_free, cancel & cancel = 0b
      ptr_free, selected_kernel & selected_kernel = 0b                
      q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
      IF kdim ge imgminsize THEN BEGIN
        res = dialog_message('Kernel dimension larger than x or y image dimension. ' + $
          string(10b) + 'Returning...', / information)
        GOTO, fin
      ENDIF

      ;; do the lm now
      widget_control, / hourglass
      qmiss = where(image0 eq 0b,ctmiss, /l64)
      spatcon, image0, kdim, 'lm', info.dir_tmp, info.my_os, 0, im  ;; im not defined here, it will be used in heatmap
      
      if ctmiss gt 0 then save, qmiss, filename = info.dir_tmp + 'missing.sav'
      
      restore, info.dir_guidossub + 'lmcolors.sav' & tvlct, r, g, b
      ;; recode and get heatmap: store resulting files heatmap.png and heatmap.csv in dir_tmp for later
      heatmap, info.dir_tmp, info.dir_guidossub, info.my_os, kdim_str, ctmiss, im

      * info.process = temporary(im)
      info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 7 ;; LM colours

      * info.fr_image = * info.process
      info.add_title = ' (LM, kdim=' + kdim_str + ')'
      
      
      ;; open heatmap image
      IF info.my_os EQ 'apple' THEN BEGIN
        spawn, 'open ' + info.dir_tmp + 'heatmap.png'
      ENDIF ELSE IF info.my_os EQ 'windows' THEN BEGIN
        pushd, info.dir_tmp
        spawn, 'start heatmap.png', / nowait
        popd
      ENDIF ELSE BEGIN ;; Linux
        IF strlen(info.xdgop) EQ 0 THEN BEGIN
          st = "Please install xdg-open to automatically" + $
            "display images within GuidosToolbox."
          result = dialog_message(st, / information)
        ENDIF ELSE BEGIN
          spawn, info.xdgop + ' "' + info.dir_tmp + 'heatmap.png' + '"'
        ENDELSE
      ENDELSE    

   END

   ;;*****************************************************************************************************

   'batch_lm':  BEGIN
      tit = 'Select (Geo-)Tif-files'
      im_file = $
        dialog_pickfile(Title = tit, get_path = path2file, $
        path = info.dir_data, default_extension = 'tif', / fix_filter, $
        / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
      IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
      
      ;; test that the directory of the selected files has no sub-directories
      ;; this will also ensure no output file is opened in excel or thelike
      pushd, path2file
      list = file_search() & nl = n_elements(list) & nr_dir = 0
      for idx = 0, nl-1 do begin
        q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
      endfor
      IF nr_dir GT 0 THEN BEGIN
        msg = 'The directory of your Batch LM input files contains sub-directories.'  +  string(10b) +  string(10b) + $
          'Please set up a new directory having Batch LM input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF
      popd
      
      ;; define a pointer to the default kernel, 5 x 5
      kdim = 5 & def_kernel = replicate(1, kdim, kdim)
      cancel = ptr_new(1b)
      selected_kernel = ptr_new(def_kernel)
      ;; get the kernel settings, make square & binary
      get_kernel, selected_kernel = selected_kernel, $
        cancel = cancel, Group_Leader = event.top, / binary, / square, /noedit, $
        title = 'Select kernel dimension'
      ;; check if cancel was selected then do nothing else apply the
      ;; default or new kernel

      IF * cancel NE 0b THEN BEGIN
        ptr_free, cancel & cancel = 0b
        ptr_free, selected_kernel & selected_kernel = 0b
        GOTO, fin
      ENDIF
      kdim = * selected_kernel & kdim = (size(kdim))[1] & kdim_str = strtrim(kdim, 2)
      
      ;; test that we can write into the parent directory or if it exists already
      batch_type = 'batch_LM'
      dd = file_dirname(im_file[0], / mark_directory)
      dir_batch = file_dirname(dd, / mark_directory) + batch_type + '_' + kdim_str + info.os_sep
      res = file_test(dir_batch, /directory, /write)
      if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
        res = dialog_message(msg,/question)
        If res eq 'No' then goto, fin
        ;; empty it
        pushd, dir_batch
        list = file_search() & nl = n_elements(list)
        if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
        popd
      endif else begin ;; does not exist yet, create it
        file_mkdir, dir_batch
      endelse



      ;; files are now selected, reset the GUI
      ;;========================================================================
      ;; reset the front image and block any events
      ;;========================================================================
      title = 'LM Batch Processing'
      goto, resetfront
 
      backto_batch_lm:
      desc = 'GTB_LM, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'

      ;; do the loop processing now
      ;; validate and process the images in a loop
      ;; do the loop processing now
      ;; validate and process the images in a loop
      fn_logfile = dir_batch + batch_type + '_' + kdim_str + '.log'
      nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
      openw, 9, fn_logfile
      printf, 9, 'LM batch processing logfile: ', systime()
      printf, 9, 'Number of files to be processed: ', nr_im_files
      printf, 9, '==============================================='
      close, 9
      msg = 'Processing selected images for LM, please wait...'
      progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
      progressBar -> Start
      
      FOR fidx = 0, nr_im_files - 1 DO BEGIN
        counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
        ;; validate the input, if not skip it without message
        IF progressBar -> CheckCancel() THEN BEGIN
          res = Dialog_Message('Batch-processing cancelled by user.')
          openw, 9, fn_logfile, /append
          printf, 9, 'Batch-processing cancelled by user.'
          close, 9
          progressBar -> Destroy
          Obj_Destroy, progressBar
          tvlct, rini, gini, bini
          GOTO, fin
        ENDIF

        input = im_file(fidx)
        res = strpos(input,' ') ge 0
        IF res EQ 1 THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid LM input (empty space in directory path or input filename): ', input
          close, 9
          GOTO, skip_batch_lm  ;; invalid input
        ENDIF
        
        type = '' & res = query_image(input, type=type)
        IF type NE 'TIFF' THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid LM input (not a TIFF image): ', input
          close, 9
          GOTO, skip_batch_lm  ;; invalid input
        ENDIF

        res = query_tiff(input, geotiff = geotiffinfo)
        IF res EQ 0 THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid LM input file: ', input
          close, 9
          GOTO, skip_batch_lm  ;; invalid LM input
        ENDIF

        image0 = read_tiff(input)  ;; read and check it
        LM_Compliance, input, image0, 'lm', info.immaxsizeg * 10, 0, result
        q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
        IF result EQ 0 OR kdim ge imgminsize THEN BEGIN
          openw, 9, fn_logfile, /append
          printf, 9, ' '
          printf, 9, '==============   ' + counter + '   =============='
          printf, 9, 'Skipping invalid LM input file: ', input
          close, 9
          GOTO, skip_batch_lm  ;; invalid LM input
        ENDIF

        ;; now all is ok for processing
        time0 = systime( / sec)
        widget_control, / hourglass
        qmiss=where(image0 eq 0b,ctmiss, /l64)
        spatcon, image0, kdim, 'lm', info.dir_tmp, info.my_os, 0, im
        if ctmiss gt 0 then save, qmiss, filename = info.dir_tmp + 'missing.sav'

        restore, info.dir_guidossub + 'lmcolors.sav' & tvlct, r, g, b
        ;; recode and get heatmap: store resulting files heatmap.png and heatmap.csv in dir_tmp for later
        heatmap, info.dir_tmp, info.dir_guidossub, info.my_os, kdim_str, ctmiss, im

        ;; write the final result 
        res = file_basename(input, '.tif')
        outdir = dir_batch + res + '_lm_' + kdim_str & file_mkdir, outdir
        fn_out = outdir + '/' + res + '_lm_' + kdim_str + '.tif'

        ;; add the geotiff info if available
        IF (size(geotiffinfo))[0] gt 0 THEN $
          write_tiff, fn_out, im, red = r, green = g, blue = b, geotiff = geotiffinfo, description = desc, compression = 1 ELSE $
          write_tiff, fn_out, im, red = r, green = g, blue = b, description = desc, compression = 1
        
        ;; copy over the lm103class image
        fn_out = outdir + '/' + res + '_lm_' + kdim_str + '_103class.tif'
        close,1 & openr, 1, info.dir_tmp + 'lm103class'
        readu,1, im & close, 1
        IF (size(geotiffinfo))[0] gt 0 THEN $
          write_tiff, fn_out, im, geotiff = geotiffinfo, description = desc, compression = 1 ELSE $
          write_tiff, fn_out, im, description = desc, compression = 1
        im = 0
                
        fn_out = outdir + '/' + res + '_lm_' + kdim_str + '_heatmap.sav'
        file_copy, info.dir_tmp + 'heatmap.sav', fn_out, /overwrite

        fn_out = outdir + '/' + res + '_lm_' + kdim_str + '_heatmap.csv'
        file_copy, info.dir_tmp + 'heatmap.csv', fn_out, /overwrite
        
        fn_out = outdir + '/' + res + '_lm_' + kdim_str + '_heatmap.png'
        file_copy, info.dir_tmp + 'heatmap.png', fn_out, /overwrite
        
        fn_out = outdir + '/heatmap_legend.png'
        file_copy, info.dir_guidossub + 'heatmap_legend.png', fn_out, /overwrite
        
        okfile = okfile + 1
        openw, 9, fn_logfile, /append
        printf, 9, ' '
        printf, 9, '==============   ' + counter + '   =============='
        printf, 9, 'File: ' + input
        printf, 9, 'LM comp.time [sec]: ', systime( / sec) - time0
        close, 9

        skip_batch_lm:
        stepn = (fidx + 1.0)/nr_im_files * 100.0
        progressBar -> Update, stepn
      ENDFOR
      progressBar -> Destroy
      Obj_Destroy, progressBar

      ;; inform that batch is done
      proct = systime( / sec) - time00
      IF proct GT 3600.0 THEN BEGIN
        proct2 = proct - ulong(proct/3600)*3600
        proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
          ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
      ENDIF ELSE BEGIN
        proctstr = strtrim(ulong(proct/60.),2) + $
          ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
      ENDELSE
      IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
      openw, 9, fn_logfile, /append
      printf, 9, ''
      printf, 9, '==============================================='
      printf, 9, 'LM Batch Processing total comp.time: ', proctstr
      printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
      printf, 9, '==============================================='
      close, 9

      msg = 'LM Batch Processing finished.' + string(10b) + $
        'Total computation time: ' + proctstr + string(10b) + $
        'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
        'More information can be found in the logfile: ' + string(10b) + fn_logfile
      res = dialog_message(msg, / information)
      ;; reset the colortable to the settings before the batch processing
      tvlct, rini, gini, bini

      ;; free and delete the temporary pointers
      ptr_free, cancel & cancel = 0b
      ptr_free, selected_kernel & selected_kernel = 0b
      GOTO, fin
   END


   ;;*****************************************************************************************************

   'lmms':  BEGIN
     ;; check for input compliance:
     ;; 1) if already a mspa image then quit
     IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_contort GT 0 OR info.is_nw EQ 1 OR info.is_cost EQ 1 THEN BEGIN
       res = dialog_message(info.wronginput, / information)
       GOTO, fin
     ENDIF

     ;; 2) if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF

     ;; 3) check input compliance
     ;; assign the full resolution image
     image0 = * info.fr_image
     
     q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
     IF imgminsize LT 500 THEN BEGIN
       res = dialog_message('Dominance requires a minimum image dimension of 500 pixels in x and y image dimension.' + $
         string(10b) + 'Returning...', / information)
       GOTO, fin
     ENDIF
     LM_Compliance, info.fname_input, image0, 'lm', info.immaxsizeg, 1, result
     IF result EQ 0 THEN GOTO, fin  ;; invalid input

     ;; loop over 5 observation scales
     kdim = [7, 13, 27, 81, 243] 
     qmiss=where(image0 eq 0b,ctmiss, /l64)

     ;;widget_control, / hourglass
     ;; calculate LMMS for each of the 5 observation scales
     pushd, info.dir_tmp
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       ;; save missing data
       if ctmiss gt 0 then save, qmiss, filename = 'missing.sav'
     popd

     for idx = 0,4 do begin
     ;;  image0 = * info.fr_image
       ;; run spatcon LMMS: instead of LMMS we run a fake LM 5 times and then do the rest with combinelpt
       spatcon, image0, kdim[idx], 'lmms', info.dir_tmp, info.my_os, 0, im
       ;; rename images for later when doing combinelpt
       file_move, info.dir_tmp + 'p2_1.bsq',info.dir_tmp + 'obs' + strtrim(idx,2) + '_1.bsq',/overwrite
       file_move, info.dir_tmp + 'p2_2.bsq',info.dir_tmp + 'obs' + strtrim(idx,2) + '_2.bsq',/overwrite
       file_move, info.dir_tmp + 'p2_3.bsq',info.dir_tmp + 'obs' + strtrim(idx,2) + '_3.bsq',/overwrite
       ;; do the heatmap at that scale
       restore, info.dir_guidossub + 'lmcolors.sav' & tvlct, r, g, b
       ;; recode and get heatmap: store resulting files heatmap.png and heatmap.csv in dir_tmp for later
       kdim_str = strtrim(kdim[idx],2)
       heatmap, info.dir_tmp, info.dir_guidossub, info.my_os, kdim_str, ctmiss, im
       ;; rename stuff for later: the 19 class LM-image and heatmap stats at scale idx        
       file_move, info.dir_tmp + 'recoutput', info.dir_tmp + 'obs' + strtrim(idx,2) + '_lm',/overwrite  ;; 19 class LM-image
       file_move, info.dir_tmp + 'heatmap.csv', info.dir_tmp + 'obs' + strtrim(idx,2) + '_heatmap.csv',/overwrite 
       file_move, info.dir_tmp + 'heatmap.png', info.dir_tmp + 'obs' + strtrim(idx,2) + '_heatmap.png',/overwrite
       file_move, info.dir_tmp + 'heatmap.sav', info.dir_tmp + 'obs' + strtrim(idx,2) + '_heatmap.sav',/overwrite
     endfor
     
     pushd, info.dir_tmp
     
     ;; combine LPTs
     ;; the parameter file for combinelpt: first row = number of scales, second row: 1 - read 19class LM  or  2 - read103 class LM
     openw, 1, 'parfile.txt' & printf,1,'5' & printf,1,'2' & close,1
     file_copy, 'recsize.txt', 'scsize.txt',/overwrite
     cmd = ' parfile.txt scsize.txt scoutput obs0_1.bsq obs0_2.bsq obs0_3.bsq obs1_1.bsq obs1_2.bsq obs1_3.bsq obs2_1.bsq obs2_2.bsq obs2_3.bsq ' 
     cmd = cmd + 'obs3_1.bsq obs3_2.bsq obs3_3.bsq obs4_1.bsq obs4_2.bsq obs4_3.bsq'
     
     IF info.my_os EQ 'windows' THEN BEGIN
       IF (!version.memory_bits EQ 64) THEN combinelpt='..\spatcon\combinelpt64.exe' ELSE $
         combinelpt='..\spatcon\combinelpt32.exe'
       file_copy, combinelpt, 'combinelpt.exe', /overwrite
     ENDIF ELSE IF info.my_os EQ 'apple' THEN BEGIN
       combinelpt='../spatcon/combinelpt_mac' & file_copy, combinelpt, 'combinelpt', /overwrite
     ENDIF ELSE BEGIN
       combinelpt='../spatcon/combinelpt_lin64' & file_copy, combinelpt, 'combinelpt', /overwrite
     ENDELSE

     ;; run combinelpt in tmp
     IF info.my_os EQ 'windows' THEN spawn, 'combinelpt.exe' + cmd, log, / hide ELSE spawn, './combinelpt' + cmd, log
          
     ;; the result of combinelpt is the 103-class across-scale LPT
     ;; recode and get heatmap: store resulting files heatmap.png and heatmap.csv in dir_tmp for later
     kdim_str = 'multiscale'
     heatmap, info.dir_tmp, info.dir_guidossub, info.my_os, kdim_str, ctmiss, im ;; the output here is the 19-class across-scale LM
     if ctmiss gt 0 then im[qmiss] = 0b
         
     popd

     * info.process = temporary(im)
     restore, info.dir_guidossub + 'lmcolors.sav' & tvlct, r, g, b
     info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 7 ;; LM

     ;; free and delete the temporary pointers
     * info.fr_image = * info.process
     info.add_title = ' (Dominance: MultiScale summary)'
     
     ;; open heatmap image
     IF info.my_os EQ 'apple' THEN BEGIN
       spawn, 'open ' + info.dir_tmp + 'heatmap.png'
     ENDIF ELSE IF info.my_os EQ 'windows' THEN BEGIN
       pushd, info.dir_tmp
       spawn, 'start heatmap.png', / nowait
       popd
     ENDIF ELSE BEGIN ;; Linux
       IF strlen(info.xdgop) EQ 0 THEN BEGIN
         st = "Please install xdg-open to automatically" + $
           "display images within GuidosToolbox."
         result = dialog_message(st, / information)
       ENDIF ELSE BEGIN
         spawn, info.xdgop + ' "' + info.dir_tmp + 'heatmap.png' + '"'
       ENDELSE
     ENDELSE

     
     
     
   END


   ;;*****************************************************************************************************

   'batch_lmms':  BEGIN
     tit = 'Select (Geo-)Tif-files'
     im_file = $
       dialog_pickfile(Title = tit, get_path = path2file, $
       path = info.dir_data, default_extension = 'tif', / fix_filter, $
       / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
     IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
     
     ;; test that the directory of the selected files has no sub-directories
     pushd, path2file
     list = file_search() & nl = n_elements(list) & nr_dir = 0
     for idx = 0, nl-1 do begin
       q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
     endfor
     IF nr_dir GT 0 THEN BEGIN
       msg = 'The directory of your Batch Dominance input files contains sub-directories.'  +  string(10b) +  string(10b) + $
         'Please set up a new directory having Batch Dominance input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     popd 
     
     ;; test that we can write into the parent directory or if it exists already
     batch_type = 'batch_Dominance'
     dd = file_dirname(im_file[0], / mark_directory)
     dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
     res = file_test(dir_batch, /directory, /write)
     if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
       res = dialog_message(msg,/question)
       If res eq 'No' then goto, fin
       ;; empty it
       pushd, dir_batch
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd
     endif else begin ;; does not exist yet, create it
       file_mkdir, dir_batch
     endelse


     ;; do the loop processing now
     ;; files are now selected, reset the GUI
     ;;========================================================================
     ;; reset the front image and block any events
     ;;========================================================================
     kdim = [7, 13, 27, 81, 243] & kstr = ['7', '13', '27', '81', '243']
     title = 'Dominance Batch Processing'
     goto, resetfront

     backto_batch_lmms:
     
     desc = 'GTB_LM, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
     ;; validate and process the images in a loop
     fn_logfile = dir_batch + batch_type + '.log'
     nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
     openw, 9, fn_logfile
     printf, 9, 'Dominance batch processing logfile: ', systime()
     printf, 9, 'Number of files to be processed: ', nr_im_files
     printf, 9, '==============================================='
     close, 9
     msg = 'Processing selected images for Dominance, please wait...'
     progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
     progressBar -> Start
     
     FOR fidx = 0, nr_im_files - 1 DO BEGIN
       counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
       ;; validate the input, if not skip it without message
       IF progressBar -> CheckCancel() THEN BEGIN
         res = Dialog_Message('Batch-processing cancelled by user.')
         openw, 9, fn_logfile, /append
         printf, 9, 'Batch-processing cancelled by user.'
         close, 9
         progressBar -> Destroy
         Obj_Destroy, progressBar
         tvlct, rini, gini, bini
         GOTO, fin
       ENDIF

       input = im_file(fidx)
       res = strpos(input,' ') ge 0
       IF res EQ 1 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Dominance input (empty space in directory path or input filename): ', input
         close, 9
         GOTO, skip_batch_lmms  ;; invalid input
       ENDIF

       type = '' & res = query_image(input, type=type)
       IF type NE 'TIFF' THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Dominance input (not a TIFF image): ', input
         close, 9 
         GOTO, skip_batch_lmms  ;; invalid input
       ENDIF

       res = query_tiff(input, geotiff = geotiffinfo)
       IF res EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Dominance input file: ', input
         close, 9
         GOTO, skip_batch_lmms  ;; invalid input
       ENDIF

       image0 = read_tiff(input)  ;; read and check it      
       LM_Compliance, input, image0, 'lm', info.immaxsizeg * 10, 0, result
       q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
       IF result EQ 0 OR imgminsize LT 500 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Dominance input file: ', input
         close, 9
         GOTO, skip_batch_lmms  ;; invalid input
       ENDIF

       ;; now all is ok for processing
       time0 = systime( / sec)
       widget_control, / hourglass
       qmiss=where(image0 eq 0b,ctmiss, /l64)
       
       ;; ===========================================================
       ;; calculate LMMS for each of the 5 observation scales
       ;; first ensure dir_tmp is empty
       pushd, info.dir_tmp
         list = file_search() & nl = n_elements(list)
         if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive    
         ;; save missing data
         if ctmiss gt 0 then save, qmiss, filename = 'missing.sav'   
       popd

       for idx = 0,4 do begin
         ;; run spatcon LMMS: instead of LMMS we run a fake LM 5 times and then do the rest with combinelpt
         spatcon, image0, kdim[idx], 'lmms', info.dir_tmp, info.my_os, 0, im
         ;; rename images for later when doing combinelpt
         file_move, info.dir_tmp + 'p2_1.bsq',info.dir_tmp + 'obs' + strtrim(idx,2) + '_1.bsq',/overwrite
         file_move, info.dir_tmp + 'p2_2.bsq',info.dir_tmp + 'obs' + strtrim(idx,2) + '_2.bsq',/overwrite
         file_move, info.dir_tmp + 'p2_3.bsq',info.dir_tmp + 'obs' + strtrim(idx,2) + '_3.bsq',/overwrite
         ;; do the heatmap at that scale
         restore, info.dir_guidossub + 'lmcolors.sav' & tvlct, r, g, b
         ;; recode and get heatmap: store resulting files heatmap.png and heatmap.csv in dir_tmp for later
         kdim_str = strtrim(kdim[idx],2)
         heatmap, info.dir_tmp, info.dir_guidossub, info.my_os, kdim_str, ctmiss, im
         ;; rename stuff for later: the 19 class LM-image and heatmap stats at scale idx
         file_move, info.dir_tmp + 'recoutput', info.dir_tmp + 'obs' + strtrim(idx,2) + '_lm',/overwrite  ;; 19 class LM-image
         file_move, info.dir_tmp + 'heatmap.csv', info.dir_tmp + 'obs' + strtrim(idx,2) + '_heatmap.csv',/overwrite
         file_move, info.dir_tmp + 'heatmap.png', info.dir_tmp + 'obs' + strtrim(idx,2) + '_heatmap.png',/overwrite
         file_move, info.dir_tmp + 'heatmap.sav', info.dir_tmp + 'obs' + strtrim(idx,2) + '_heatmap.sav',/overwrite
       endfor
      
       pushd, info.dir_tmp
       
       ;; combine LPTs
       ;; the parameter file for combinelpt: first row = number of scales, second row: 1 - read 19class LM  or  2 - read103 class LM
       openw, 1, 'parfile.txt' & printf,1,'5' & printf,1,'2' & close,1
       file_copy, 'recsize.txt', 'scsize.txt',/overwrite
       cmd = ' parfile.txt scsize.txt scoutput obs0_1.bsq obs0_2.bsq obs0_3.bsq obs1_1.bsq obs1_2.bsq obs1_3.bsq obs2_1.bsq obs2_2.bsq obs2_3.bsq ' 
       cmd = cmd + 'obs3_1.bsq obs3_2.bsq obs3_3.bsq obs4_1.bsq obs4_2.bsq obs4_3.bsq'
       
       IF info.my_os EQ 'windows' THEN BEGIN
         IF (!version.memory_bits EQ 64) THEN combinelpt='..\spatcon\combinelpt64.exe' ELSE $
           combinelpt='..\spatcon\combinelpt32.exe'
         file_copy, combinelpt, 'combinelpt.exe', /overwrite
       ENDIF ELSE IF info.my_os EQ 'apple' THEN BEGIN
         combinelpt='../spatcon/combinelpt_mac' & file_copy, combinelpt, 'combinelpt', /overwrite
       ENDIF ELSE BEGIN
         combinelpt='../spatcon/combinelpt_lin64' & file_copy, combinelpt, 'combinelpt', /overwrite
       ENDELSE
  
       ;; run combinelpt in tmp
       IF info.my_os EQ 'windows' THEN spawn, 'combinelpt.exe' + cmd, log, / hide ELSE spawn, './combinelpt' + cmd, log

       ;; the result of combinelpt is the 103-class across-scale LPT
       ;; recode and get heatmap: store resulting files heatmap.png and heatmap.csv in dir_tmp for later
       kdim_str = 'multiscale'
       heatmap, info.dir_tmp, info.dir_guidossub, info.my_os, kdim_str, ctmiss, im ;; the output here is the 19-class across-scale LM
       if ctmiss gt 0 then im[qmiss] = 0b

       popd
       ;; ===========================================================

       ;; write the final result 
       res = file_basename(input, '.tif')
       outdir = dir_batch + res + '_dominance'

       ;; setup the output directory for the current image file
       file_mkdir, outdir
       pushd, outdir
       restore, info.dir_guidossub + 'lmcolors.sav' & tvlct, r, g, b
       
       ;; first save the visual summary result
       fn_out = res + '_lm_mscale.tif'
       ;; add the geotiff info if available
       IF (size(geotiffinfo))[0] gt 0 THEN $
         write_tiff, fn_out, im, red = r, green = g, blue = b, geotiff = geotiffinfo, description = desc, compression = 1 ELSE $
         write_tiff, fn_out, im, red = r, green = g, blue = b, description = desc, compression = 1
       im = 0
       z = res + '_lm_mscale_heatmap.csv'
       file_copy, info.dir_tmp + 'heatmap.csv', z, /overwrite
       z = res + '_lm_mscale_heatmap.png'
       file_copy, info.dir_tmp + 'heatmap.png', z, /overwrite
       z = res + '_lm_mscale_heatmap.sav'
       file_copy, info.dir_tmp + 'heatmap.sav', z, /overwrite
       z = 'heatmap_legend.png'
       file_copy, info.dir_guidossub + 'heatmap_legend.png', z, /overwrite

       ;; the 5 observation scales
       for isc = 0, 4 do begin
         ;; the actual data
         z = res + '_lm_' + strtrim(kstr[isc],2) + '.tif'                  
         openr, 1, info.dir_tmp + 'obs'+ strtrim(isc,2)+'_lm' & readu,1, image0 & close,1
         if ctmiss gt 0 then image0[qmiss]=0b
         IF (size(geotiffinfo))[0] gt 0 THEN $
           write_tiff, z, image0, red = r, green = g, blue = b, geotiff = geotiffinfo, description = desc, compression = 1 ELSE $
           write_tiff, z, image0, red = r, green = g, blue = b, description = desc, compression = 1           
         ;; the heatmap stuff
         z = res + '_lm_' + strtrim(kstr[isc],2)  + '_heatmap.csv'
         file_copy, info.dir_tmp + 'obs'+ strtrim(isc,2)+'_heatmap.csv', z, /overwrite
         z = res + '_lm_' + strtrim(kstr[isc],2)  + '_heatmap.png'
         file_copy, info.dir_tmp + 'obs'+ strtrim(isc,2)+'_heatmap.png', z, /overwrite
         z = res + '_lm_' + strtrim(kstr[isc],2)  + '_heatmap.sav'
         file_copy, info.dir_tmp + 'obs'+ strtrim(isc,2)+'_heatmap.sav', z, /overwrite          
       endfor
       popd
       
       ;; empty tmp for the next calculation
       pushd, info.dir_tmp
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd
      
       okfile = okfile + 1
       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'File: ' + input
       printf, 9, 'Dominance comp.time [sec]: ', systime( / sec) - time0
       close, 9

       skip_batch_lmms:
       stepn = (fidx + 1.0)/nr_im_files * 100.0
       progressBar -> Update, stepn
     ENDFOR
     progressBar -> Destroy
     Obj_Destroy, progressBar

     ;; inform that batch is done
     proct = systime( / sec) - time00
     IF proct GT 3600.0 THEN BEGIN
       proct2 = proct - ulong(proct/3600)*3600
       proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDIF ELSE BEGIN
       proctstr = strtrim(ulong(proct/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDELSE
     IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
     openw, 9, fn_logfile, /append
     printf, 9, ''
     printf, 9, '==============================================='
     printf, 9, 'Dominance Batch Processing total comp.time: ', proctstr
     printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
     printf, 9, '==============================================='
     close, 9

     msg = 'Dominance Batch Processing finished.' + string(10b) + $
       'Total computation time: ' + proctstr + string(10b) + $
       'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
       'More information can be found in the logfile: ' + string(10b) + fn_logfile
     res = dialog_message(msg, / information)
     ;; reset the colortable to the settings before the batch processing
     tvlct, rini, gini, bini
     GOTO, fin
   END

   ;;*****************************************************************************************************

   'spa':  BEGIN
     ;; check for input compliance:
     ;; 1) if already a mspa image then quit
     IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_cs22 EQ 1 OR info.is_nw EQ 1 OR info.is_contort GT 0 OR info.is_influ gt 0 OR info.is_cost EQ 1 THEN BEGIN
       res = dialog_message(info.wronginput, / information)
       GOTO, fin
     ENDIF

     ;; 2) if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF

     ;; 3) check input compliance
     MSPA_Compliance, info.fname_input, * info.fr_image, info.immaxsizeg, 1, result
     IF result EQ 0 THEN GOTO, fin  ;; invalid input
     
     ;; enforce FGconn to 8 and eew=1, just to avoid misunderstandings...
     info.mspa_param1_id = 1
     widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id
     widget_control, info.w_mspa_param2, set_value = ['x','1','2','3','4','5','6','7','8','9','10']
     widget_control, info.w_mspa_param2, set_combobox_select = 1

     ;; we must process the full resolution image
     image0 = * info.fr_image 
     se8 = replicate(1b, 3, 3) ;; 8-conn kernel
     ;; check for missing  pixels
     image0min = min(image0) & ct_qmiss = 0
     if image0min eq 0b then begin
       missing = image0 eq 0b 
       qmiss = where(missing eq 1b, ct_qmiss, /l64)      
     endif
     area_image = (size(image0))[4]
     area_data = area_image - ct_qmiss
     
     ;; extend the working image to ensure proper results for label_region
     sz = size(image0,/dim) & ext1 = bytarr(sz(0) + 4, sz(1) + 4) + 1b & sz2=size(ext1,/dim) 
     ext1[2:sz[0]+1, 2:sz[1]+1] = temporary(image0) & all_n = 1 ;8-connectivity
     ;; count FG-objects
     nr_FG = max(label_region(ext1 eq 2b, all_neighbors=all_n, / ulong))     
     ;; extend image data assignment into the surrounding buffer to not create artificial boundaries at the image outline
     ext1[2:sz[0]+1, 1] = ext1[2:sz[0]+1, 2] ;; bottom row
     ext1[2:sz[0]+1, sz2[1]-2] = ext1[2:sz[0]+1, sz2[1]-3] ;; top row
     ext1[1, 2:sz[1]+1] = ext1[2, 2:sz[1]+1] ;; left column
     ext1[sz2[0]-2, 2:sz[1]+1] = ext1[sz2[0]-3, 2:sz[1]+1] ;; right column
     ;; assign the corner pixels
     ext1[1,1] = ext1[2,2]  ;; left bottom
     ext1[1,sz2[1]-2] = ext1[2,sz2[1]-3] ;;  left top
     ext1[sz2[0]-2,1] = ext1[sz2[0]-3,2] ;; right bottom 
     ext1[sz2[0]-2, sz2[1]-2] = ext1[sz2[0]-3, sz2[1]-3] ;; right top
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
     ;; FG
     fg = temporary(ext1) eq 2b ;; real FG
     ;; extend FG into missing to avoid getting boundaries there
     if image0min eq 0b then begin
      tmp = fg[2:sz[0]+1, 2:sz[1]+1]     
      fg[2:sz[0]+1, 2:sz[1]+1] = dilate(tmp, se8) * missing + temporary(tmp)
      missing = 0
     endif
     
     ;; spa2: small, linear features
     if eventValue2 eq 'spa2' then begin 
       slf = fg - morph_open(fg, se8)
       image0 = (fg * 17b) - (slf * 16b)
       image0 = temporary(image0[2:sz2(0)-3, 2:sz2(1)-3])
       if ct_qmiss gt 0 then image0[qmiss] = 129b 
       qmiss = 0
       zz = image0 eq 17b & nr_Cores = max(label_region(zz, all_neighbors=all_n, / ulong))  & zz = 0b
       zz = image0 eq 1b & nr_margin = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b
       goto, spa2skip0
     endif
     
     ;; Cores
     cores = erode(fg,se8)      
     
     ;; Margin    
     margin = fg - cores
     if eventValue2 eq 'spa3' then fg = 0b
     
     ;; Holes, use 8-conn for FG <-> 4-conn for BG
     ;; holes must be done on extended BG to ensure the actual background is a hole 
     holes = label_region(1b-cores,/ulong) 
     ;; holes=0 -> FG; holes=1 -> image BG; holes gt 1 = actual holes inside Cores
     qholes = where(holes gt 1, ct_qholes, /l64) & holes = 0
        
     ;; map for display     
     if eventValue2 eq 'spa3' then begin       
       image0 = temporary(cores)*17b
       if ct_qholes gt 0 then image0[qholes] = 100b & qholes = 0
       ;; overplot the margin pixels on top of the holes of Core      
       qmargin = where(margin eq 1b, /l64)
       image0[qmargin] = 1b & margin = 0 & qmargin = 0
     endif else begin 
       ct_qislets = 0
       
       ;; SPA6
       ;; at this point we have 3 data sets of extended size sz2:
       ;; - fg: the potential fixed fg at the intersection with missing
       ;; - cores: the core mask
       ;; - margin: all non-core FG
             
       if eventValue2 eq 'spa6' then begin
         ;; get the islets
         ;;=================        
          ;; reconstruction by dilation          
          cord = cores & sum1 = 1 & sum2 = 0 & steps = 0
          while sum2 ne sum1 do begin
            sum1 = sum2
            cord = dilate(cord, se8) * fg
            sum2 = total(cord)      
            steps = steps + 1     
          endwhile
          cord = fg - temporary(cord) 
          qislets = where(cord eq 1b, ct_qislets, /l64)
          cord = 0             
       endif
       
       ;; continue with spa5            
       core_boundary = dilate(cores,se8)*temporary(fg)-cores
       ;; start with Core
       image0 = temporary(cores)*17b
       ;; add core-holes
       if ct_qholes gt 0 then image0[qholes] = 100b & qholes = 0
       ;; add core_boundary
       margin = temporary(margin)-core_boundary & qmargin = where(margin gt 0, ct_qmargin, /l64) & margin = 0
       image0 = temporary(image0) + temporary(core_boundary)*3b      
       ;; assign Perforation
       q = where(image0 eq 103b, ct, /l64)
       if ct gt 0 then image0[q] = 5b
       q = 0
       ;; add margin pixels
       if ct_qmargin gt 0 then image0[qmargin] = 1b
       qmargin = 0   
       ;; add islet pixels
       if ct_qislets gt 0 then image0[qislets] = 9b
       qislets = 0    
     endelse
        
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
     ;; only now after all classes are assigned do the statistics for holes in the extended image
     ;; do them with 4-connectivity because FG is fixed with 8-connectivity!
     ;; first, set the two box boundary to background, then do the labeling
     image0[0:1,*] = 0b & image0[sz2[0]-2:*,*] = 0b ;; left & right
     image0[*,0:1] = 0b & image0[*,sz2[1]-2:*] = 0b ;; bottom & top
     if ct_qmiss gt 0 then begin ;; add back the missing pixels
       zz = image0[2:sz2(0)-3, 2:sz2(1)-3]
       zz[qmiss] = 129b & qmiss = 0
       image0[2:sz2(0)-3, 2:sz2(1)-3] = temporary(zz)
     endif
     zz = image0 eq 100b & nr_holes = max(label_region(zz, / ulong)) & zz = 0b;; core-holes with 4-connectivity    
     zz = image0 eq 17b & nr_Cores = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b
     if eventValue2 eq 'spa3' then begin
       zz = image0 eq 1b & nr_margin = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b
     endif else begin ;; spa5/6
       ;; add the remaining stats: edge, perf, margin
       zz = image0 eq 3b & nr_edge = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b
       zz = image0 eq 5b & nr_perf = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b
       zz = image0 eq 1b & nr_margin = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b
       if eventValue2 eq 'spa6' then begin
         zz = image0 eq 9b & nr_islet = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b
       endif
       zz = image0 eq 17b or image0 eq 3b or image0 eq 5b & nr_contiguous = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b    
     endelse

     ;; go back to original dimension 
     ;;=======================================
     image0 = temporary(image0[2:sz2(0)-3, 2:sz2(1)-3])
          
     spa2skip0:
     ;; get areas via histogram counting
     histo = histogram(image0,/l64)    
     area_miss = histo[129]
     area_Cores = histo[17]
     area_holes = histo[100]
     area_oBG = histo[0]
     area_bg = area_oBG + area_holes
     area_fg = area_data - area_bg

     ;; add the remaining stats: edge, perf, margin
     area_edge = histo[3]     
     area_perf = histo[5]     
     area_islet = histo[9]      
     area_margin = histo[1]
     area_contiguous = area_Cores + area_edge + area_perf
     area_internal = area_contiguous + area_holes
     porosity = 100.0 - (double(area_contiguous) / area_internal * 100.0)
             
     ;; write out statistics to disk in tmp to be copied later if image is saved
     fx = info.dir_tmp + eventValue2 + '.txt' & file_delete,fx,/allow_nonexistent,/quiet
     conv1 = 100.0/area_data & conv2 = 100.0/area_fg
     openw,12,fx
     printf, 12, strupcase(eventValue2) + ': 8-connected Foreground, summary analysis for image: '
     printf, 12, info.fname_input
     printf, 12, '  '
     printf, 12, 'Image Dimension X/Y: ' + strtrim(sz(0),2) + '/' + strtrim(sz(1),2)
     printf, 12, 'Image Area =               Data Area                    + No Data (Missing) Area'
     printf, 12, '           = [ Foreground (FG) +   Background (BG)  ]     +          Missing    '
     printf, 12, '           = [        FG       + {Core-Opening + other BG} ] +       Missing    '
     printf, 12, '  '
     printf, 12, '================================================================================'
     printf, 12, '           Category              Area [pixels]: '
     printf, 12, '================================================================================'
     if eventValue2 eq 'spa2' then begin
       printf, 12, format='(a20,i22)', '        Contiguous: ', area_contiguous 
       printf, 12, format='(a20,i22)', '+              SLF: ', area_margin
       printf, 12, '--------------------------------------------------------------------------------'
       printf, 12, format='(a20,i22)',   '= Foreground Total: ', area_fg
       goto, spa2skip1
     endif 
     printf, 12, format='(a20,i22)',   '              Core: ', area_cores
     if eventValue2 eq 'spa3' then begin
       printf, 12, format='(a20,i22)', '+           Margin: ', area_margin
     endif else begin ;; spa5/6
       if eventValue2 eq 'spa6' then $
        printf, 12, format='(a20,i22)', '+            Islet: ', area_islet
       printf, 12, format='(a20,i22)', '+             Edge: ', area_edge
       printf, 12, format='(a20,i22)', '+      Perforation: ', area_perf
       printf, 12, format='(a20,i22)', '+           Margin: ', area_margin
       printf, 12, '(Contiguous = Core + Edge + Perforation: ' + strtrim(area_contiguous, 2) + ')'
     endelse      
     printf, 12, '--------------------------------------------------------------------------------'
     printf, 12, format='(a20,i22)',   '= Foreground Total: ', area_fg
     printf, 12, '  '
     printf, 12, format='(a20,i22)',   '      Core-Opening: ', area_holes    
     printf, 12, format='(a20,i22)',   '+         Other BG: ', area_oBG
     printf, 12, '--------------------------------------------------------------------------------'
     printf, 12, format='(a20,i22)',   '= Background Total: ', area_bg
     printf, 12, '  '
     printf, 12, format='(a20,i22)',   '  Foreground Total: ', area_fg
     spa2skip1:
     printf, 12, format='(a20,i22)',   '+ Background Total: ', area_bg
     printf, 12, '--------------------------------------------------------------------------------'
     printf, 12, format='(a20,i22)',   '=  Data Area Total: ', area_data
     printf, 12, '  '
     printf, 12, format='(a20,i22)',   '         Data Area: ', area_data
     printf, 12, format='(a20,i22)',   '+          Missing: ', area_miss
     printf, 12, '--------------------------------------------------------------------------------'
     printf, 12, format='(a20,i22)',   '= Image Area Total: ', area_image
     printf, 12, '  '
     printf, 12, '  '      
     printf, 12, '================================================================================'
     printf, 12, '           Category    Proportion [%]: '
     printf, 12, '================================================================================'
     if eventValue2 eq 'spa2' then begin
       printf, 12, format='(a20,f11.4)', '   Contiguous/Data: ', area_contiguous * conv1
       printf, 12, format='(a20,f11.4)', '+         SLF/Data: ', area_margin * conv1
       printf, 12, '--------------------------------------------------------------------------------'
       printf, 12, format='(a20,f11.4)', '           FG/Data: ', area_fg * conv1
       printf, 12, '--------------------------------------------------------------------------------'
       printf, 12, format='(a20,f11.4)', '     Contiguous/FG: ', area_contiguous * conv2
       printf, 12, format='(a20,f11.4)', '+           SLF/FG: ', area_margin * conv2
       goto, spa2skip2
     endif
     printf, 12, format='(a20,f11.4)',   ' Core-Opening/Data: ', area_holes * conv1
     printf, 12, '--------------------------------------------------------------------------------'
     printf, 12, format='(a20,f11.4)',   '         Core/Data: ', area_cores * conv1
     if eventValue2 eq 'spa3' then begin
       printf, 12, format='(a20,f11.4)', '       Margin/Data: ', area_margin * conv1
     endif else begin
       if eventValue2 eq 'spa6' then $
        printf, 12, format='(a20,f11.4)', '        Islet/Data: ', area_islet * conv1
       printf, 12, format='(a20,f11.4)', '         Edge/Data: ', area_edge * conv1
       printf, 12, format='(a20,f11.4)', '  Perforation/Data: ', area_perf * conv1
       printf, 12, format='(a20,f11.4)', '       Margin/Data: ', area_margin * conv1
       printf, 12, format='(a20,f11.4)', '   Contiguous/Data: ', area_contiguous * conv1    
     endelse   
     printf, 12, '--------------------------------------------------------------------------------'
     printf, 12, format='(a20,f11.4)',   '           FG/Data: ', area_fg * conv1
     printf, 12, '--------------------------------------------------------------------------------'
     printf, 12, format='(a20,f11.4)',   '           Core/FG: ', area_cores * conv2
     if eventValue2 eq 'spa3' then begin
       printf, 12, format='(a20,f11.4)', '         Margin/FG: ', area_margin * conv2
     endif else begin
       if eventValue2 eq 'spa6' then $
        printf, 12, format='(a20,f11.4)', '          Islet/FG: ', area_islet * conv2       
       printf, 12, format='(a20,f11.4)', '           Edge/FG: ', area_edge * conv2
       printf, 12, format='(a20,f11.4)', '    Perforation/FG: ', area_perf * conv2
       printf, 12, format='(a20,f11.4)', '         Margin/FG: ', area_margin * conv2    
       printf, 12, format='(a20,f11.4)', '     Contiguous/FG: ', area_contiguous * conv2
       printf, 12, format='(a20,f11.4)', '          Porosity: ', porosity
     endelse
     spa2skip2:
     printf, 12, '================================================================================'
     printf, 12, '  '
     printf, 12, '  '    
     printf, 12, '================================================================================'
     printf, 12, '           Category          Count [#]: '
     printf, 12, '================================================================================'
     if eventValue2 eq 'spa2' then begin
       printf, 12, format='(a20,i15)',   '        Contiguous: ', nr_cores
       printf, 12, format='(a20,i15)',   '        FG Objects: ', nr_fg
       printf, 12, format='(a20,i15)',   '               SLF: ', nr_margin
       goto, spa2skip3
     endif
     printf, 12, format='(a20,i15)',   '      Core-Opening: ', nr_holes
     printf, 12, format='(a20,i15)',   '        FG Objects: ', nr_fg
     printf, 12, '--------------------------------------------------------------------------------'
     printf, 12, format='(a20,i15)',   '              Core: ', nr_cores
     if eventValue2 eq 'spa3' then begin
       printf, 12, format='(a20,i15)', '            Margin: ', nr_margin
     endif else begin
       if eventValue2 eq 'spa6' then $
        printf, 12, format='(a20,i15)', '             Islet: ', nr_islet
       printf, 12, format='(a20,i15)', '              Edge: ', nr_edge
       printf, 12, format='(a20,i15)', '       Perforation: ', nr_perf
       printf, 12, format='(a20,i15)', '            Margin: ', nr_margin
       printf, 12, format='(a20,i15)', '        Contiguous: ', nr_contiguous
     endelse
     spa2skip3:
     printf, 12, '================================================================================'    
     close, 12
     
     ;; write out a smaller version of the above to be shown via xdisplayfile
     fx = info.dir_tmp + 'tmpspa.txt'
     openw,12,fx
     printf, 12, 'Image Area = FG + (Core-Opening + other BG) + Missing'
     printf, 12, '     --- More details after saving the result! ---'
     printf, 12, '==========================================='
     printf, 12, '        Category        Area [pixels]    Count [#]:  '
     printf, 12, '==========================================='
     if eventValue2 eq 'spa2' then begin
       printf, 12, format='(a14,i19,a2,i12)', 'Contiguous: ', area_contiguous,' ', nr_cores
       printf, 12, format='(a18,i18,a2,i12)', '      SLF: ', area_margin,' ', nr_margin
       goto, spa2skip4    
     endif
     printf, 12, format='(a14,i19,a2,i12)',   'Core-Opening: ', area_holes,' ', nr_holes
     printf, 12, format='(a20,i18,a2,i12)',   '         Core: ', area_cores,' ', nr_cores
     if eventValue2 eq 'spa3' then begin
       printf, 12, format='(a18,i18,a2,i12)', '      Margin: ', area_margin,' ', nr_margin
     endif else begin
       if eventValue2 eq 'spa6' then $
        printf, 12, format='(a21,i18,a2,i12)', '           Islet: ', area_islet,' ', nr_islet
       printf, 12, format='(a18,i18,a2,i12)', '         Edge: ', area_edge,' ', nr_edge
       printf, 12, format='(a17,i18,a2,i12)', ' Perforation: ', area_perf,' ', nr_perf
       printf, 12, format='(a18,i18,a2,i12)', '       Margin: ', area_margin,' ', nr_margin
       printf, 12, format='(a16,i18,a2,i12)', '    Contiguous: ', area_contiguous,' ', nr_contiguous
     endelse
     spa2skip4:
     printf, 12, '==========================================='
     printf, 12, '        Category      Proportion [%]: '
     printf, 12, '==========================================='
     if eventValue2 eq 'spa2' then begin
       printf, 12, format='(a17,f12.2)',   '  Contiguous/FG: ', area_contiguous * conv2
       printf, 12, format='(a18,f12.2)', '          SLF/FG: ', area_margin * conv2
       goto, spa2skip5
     endif
     
     printf, 12, format='(a13,f12.2)',   'CoreOp/Data: ', area_holes * conv1
     printf, 12, format='(a17,f12.2)',   '     Core/FG: ', area_cores * conv2
     if eventValue2 eq 'spa3' then begin
       printf, 12, format='(a16,f12.2)', '  Margin/FG: ', area_margin * conv2
     endif else begin ;; spa5/6 also show contiguous and porosity
       if eventValue2 eq 'spa6' then $
        printf, 12, format='(a19,f12.2)', '     Islet/FG: ', area_islet * conv2
       printf, 12, format='(a16,f12.2)', '    Edge/FG: ', area_edge * conv2
       printf, 12, format='(a18,f12.2)', '     Perf./FG: ', area_perf * conv2
       printf, 12, format='(a16,f12.2)', '  Margin/FG: ', area_margin * conv2
       printf, 12, format='(a16,f12.2)', 'Contig/FG: ', area_contiguous * conv2
       printf, 12, format='(a19,f12.2)', '       Porosity: ', porosity
     endelse
     spa2skip5:
     printf, 12, '==========================================='
     close, 12

     ;; show the summary image statistics
     xdisplayfile, fx, title = strupcase(eventValue2)+' statistics', width=45,height=file_lines(fx)+1

     * info.process = temporary(image0)
     * info.fr_image = * info.process

     restore, info.dir_guidossub + 'mspacolorstoff.sav'
     tvlct, r, g, b
     info.ctbl = - 1 & info.disp_colors_id = 3
     info.add_title = ' (' + strupcase(eventValue2) + ')'
     info.is_mspa = 0

   END

   ;;*****************************************************************************************************

   'batch_spa':  BEGIN
     tit = 'Select (Geo-)Tif-files'
     im_file = $
       dialog_pickfile(Title = tit, get_path = path2file, $
       path = info.dir_data, default_extension = 'tif', / fix_filter, $
       / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
     IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
     
     ;; test that the directory of the selected files has no sub-directories
     ;; this will also ensure no output file is opened in excel or thelike
     pushd, path2file
     list = file_search() & nl = n_elements(list) & nr_dir = 0
     for idx = 0, nl-1 do begin
       q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
     endfor
     IF nr_dir GT 0 THEN BEGIN
       msg = 'The directory of your Batch SPAx input files contains sub-directories.'  +  string(10b) +  string(10b) + $
         'Please set up a new directory having Batch SPAx input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     popd
     
     ;; test that we can write into the parent directory or if it exists already
     spax = strupcase(strmid(eventvalue2,3,/reverse))
     batch_type = 'batch_' + spax
     dd = file_dirname(im_file[0], / mark_directory)
     dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
     res = file_test(dir_batch, /directory, /write)
     if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
       res = dialog_message(msg,/question)
       If res eq 'No' then goto, fin
       ;; empty it
       pushd, dir_batch
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd
     endif else begin ;; does not exist yet, create it
       file_mkdir, dir_batch
     endelse

     ;; files are now selected, reset the GUI
     ;;========================================================================
     ;; reset the front image and block any events
     ;;========================================================================
     ev2 = strmid(eventValue2,6) 
     title = spax + ' Batch Processing'
     goto, resetfront

     backto_batch_spa:
     desc = 'GTB_SPA, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
     ;; do the loop processing now
     ;; validate and process the images in a loop
     fn_logfile = dir_batch + batch_type + '.log'
     nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
     openw, 9, fn_logfile
     printf, 9, spax + ' batch processing logfile: ', systime()
     printf, 9, 'Number of files to be processed: ', nr_im_files
     printf, 9, '==============================================='
     close, 9

     msg = 'Processing selected images for ' + spax + ', please wait...'
     progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
     progressBar -> Start

     FOR fidx = 0, nr_im_files - 1 DO BEGIN
       counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
       ;; validate the input, if not skip it without message
       IF progressBar -> CheckCancel() THEN BEGIN
         res = Dialog_Message('Batch-processing cancelled by user.')
         openw, 9, fn_logfile, /append
         printf, 9, 'Batch-processing cancelled by user.'
         close, 9
         progressBar -> Destroy
         Obj_Destroy, progressBar
         tvlct, rini, gini, bini
         GOTO, fin
       ENDIF


       input = im_file(fidx)
       res = strpos(input,' ') ge 0
       IF res EQ 1 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid ' + spax + ' input (empty space in directory path or input filename): ', input
         close, 9
         GOTO, skip_spa  ;; invalid input
       ENDIF

       type = '' & res = query_image(input, type=type)
       IF type NE 'TIFF' THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid ' + spax + ' input (not a TIFF image): ', input
         close, 9
         GOTO, skip_spa  ;; invalid input
       ENDIF


       res = query_tiff(input, geotiff = geotiffinfo)
       IF res EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid ' + spax + ' input file: ', input
         close, 9
         GOTO, skip_spa  ;; invalid input
       ENDIF

       image0 = read_tiff(input)  ;; read and check it
       MSPA_Compliance, input, image0, info.immaxsizeg*10, 0, result
       IF result EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid ' + spax + ' input file: ', input
         close, 9
         GOTO, skip_spa  ;; invalid input
       ENDIF

       ;; now all is ok for processing
       time0 = systime( / sec)
       widget_control, / hourglass       

       se8 = replicate(1b, 3, 3) ;; 8-conn kernel
       ;; check for missing  pixels
       image0min = min(image0) & ct_qmiss = 0
       if image0min eq 0b then begin
         missing = image0 eq 0b
         qmiss = where(missing eq 1b, ct_qmiss, /l64)
       endif
       area_image = (size(image0))[4]
       area_data = area_image - ct_qmiss
       
       ;; extend the working image to ensure proper results for label_region
       sz = size(image0,/dim) & ext1 = bytarr(sz(0) + 4, sz(1) + 4) + 1b & sz2=size(ext1,/dim)
       ext1[2:sz[0]+1, 2:sz[1]+1] = temporary(image0) & all_n = 1 ;8-connectivity
       ;; count FG-objetcs
       nr_FG = max(label_region(ext1 eq 2b, all_neighbors=all_n, / ulong))
       ;; extend image data assignment into the surrounding buffer to not create artificial boundaries at the image outline
       ext1[2:sz[0]+1, 1] = ext1[2:sz[0]+1, 2] ;; bottom row
       ext1[2:sz[0]+1, sz2[1]-2] = ext1[2:sz[0]+1, sz2[1]-3] ;; top row
       ext1[1, 2:sz[1]+1] = ext1[2, 2:sz[1]+1] ;; left column
       ext1[sz2[0]-2, 2:sz[1]+1] = ext1[sz2[0]-3, 2:sz[1]+1] ;; right column
       ;; assign the corner pixels
       ext1[1,1] = ext1[2,2]  ;; left bottom
       ext1[1,sz2[1]-2] = ext1[2,sz2[1]-3] ;;  left top
       ext1[sz2[0]-2,1] = ext1[sz2[0]-3,2] ;; right bottom
       ext1[sz2[0]-2, sz2[1]-2] = ext1[sz2[0]-3, sz2[1]-3] ;; right top
       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       ;; FG
       fg = temporary(ext1) eq 2b ;; real FG
       ;; extend FG into missing to avoid getting boundaries there
       if image0min eq 0b then begin
         tmp = fg[2:sz[0]+1, 2:sz[1]+1]
         fg[2:sz[0]+1, 2:sz[1]+1] = dilate(tmp, se8) * missing + temporary(tmp)
         missing =0
       endif
       
       ;; spa2: small, linear features
       if ev2 eq 'spa2' then begin
         slf = fg - morph_open(fg, se8)
         image0 = (fg * 17b) - (slf * 16b)
         image0 = temporary(image0[2:sz2(0)-3, 2:sz2(1)-3])
         if ct_qmiss gt 0 then image0[qmiss] = 129b
         qmiss = 0
         zz = image0 eq 17b & nr_Cores = max(label_region(zz, all_neighbors=all_n, / ulong))
         zz = image0 eq 1b & nr_margin = max(label_region(zz, all_neighbors=all_n, / ulong))
         goto, spa2skipb0
       endif
     
       ;; Cores
       cores = erode(fg,se8)

       ;; Margin
       margin = fg - cores
       if ev2 eq 'spa3' then fg = 0b

       ;; Holes, use 8-conn for FG <-> 4-conn for BG
       ;; holes must be done on extended BG to ensure the actual background is a hole
       holes = label_region(1b-cores,/ulong)
       ;; holes=0 -> FG; holes=1 -> image BG; holes gt 1 = actual holes inside Cores
       qholes = where(holes gt 1, ct_qholes, /l64) & holes = 0
       
       ;; map for display
       if ev2 eq 'spa3' then begin
         image0 = temporary(cores)*17b
         if ct_qholes gt 0 then image0[qholes] = 100b & qholes = 0
         ;; overplot the margin pixels on top of the holes of Core
         qmargin = where(margin eq 1b, /l64)
         image0[qmargin] = 1b & margin = 0 & qmargin = 0
       endif else begin
         ct_qislets = 0

         ;; SPA6
         ;; at this point we have 3 data sets of extended size sz2:
         ;; - fg: the potential fixed fg at the intersection with missing
         ;; - cores: the core mask
         ;; - margin: all non-core FG

         if ev2 eq 'spa6' then begin
           ;; reconstruction by dilation
           cord = cores & sum1 = 1 & sum2 = 0 & steps = 0
           while sum2 ne sum1 do begin
             sum1 = sum2
             cord = dilate(cord, se8) * fg
             sum2 = total(cord)
             steps = steps + 1
           endwhile
           cord = fg - temporary(cord)
           qislets = where(cord eq 1b, ct_qislets, /l64)
           cord = 0
         endif

         ;; continue with spa5
         core_boundary = dilate(cores,se8)*temporary(fg)-cores
         ;; start with Core
         image0 = temporary(cores)*17b
         ;; add core-holes
         if ct_qholes gt 0 then image0[qholes] = 100b & qholes = 0
         ;; add core_boundary
         margin = temporary(margin)-core_boundary & qmargin = where(margin gt 0, ct_qmargin, /l64) & margin = 0
         image0 = temporary(image0) + temporary(core_boundary)*3b
         ;; assign Perforation
         q = where(image0 eq 103b, ct, /l64)
         if ct gt 0 then image0[q] = 5b
         q = 0
         ;; add margin pixels
         if ct_qmargin gt 0 then image0[qmargin] = 1b
         qmargin = 0
         ;; add islet pixels
         if ct_qislets gt 0 then image0[qislets] = 9b
         qislets = 0
       endelse
       
       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       ;; only now after allclasses are assigned do the statistics for holes in the extended image
       ;; do them with 4-connectivity!
       ;; first, set the two box boundary to background, then do the labeling
       image0[0:1,*] = 0b & image0[sz2[0]-2:*,*] = 0b ;; left & right
       image0[*,0:1] = 0b & image0[*,sz2[1]-2:*] = 0b ;; bottom & top
       if ct_qmiss gt 0 then begin ;; add back the missing pixels
         zz = image0[2:sz2(0)-3, 2:sz2(1)-3]
         zz[qmiss] = 129b & qmiss = 0
         image0[2:sz2(0)-3, 2:sz2(1)-3] = temporary(zz)
       endif       
       zz = image0 eq 100b & nr_holes = max(label_region(zz, / ulong)) & zz = 0b;; core-holes with 4-connectivity
       zz = image0 eq 17b & nr_Cores = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b
       if ev2 eq 'spa3' then begin
         zz = image0 eq 1b & nr_margin = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b
       endif else begin
         ;; add the remaining stats: edge, perf, margin
         zz = image0 eq 3b & nr_edge = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b
         zz = image0 eq 5b & nr_perf = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b
         zz = image0 eq 1b & nr_margin = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b
         if ev2 eq 'spa6' then begin
           zz = image0 eq 9b & nr_islet = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b
         endif
         zz = image0 eq 17b or image0 eq 3b or image0 eq 5b & nr_contiguous = max(label_region(zz, all_neighbors=all_n, / ulong)) & zz = 0b 
       endelse

       ;; go back to original dimension
       ;;=======================================
       image0 = temporary(image0[2:sz2(0)-3, 2:sz2(1)-3])
       
       spa2skipb0:
       ;; get areas via histogram counting
       histo = histogram(image0,/l64)
       area_miss = histo[129]
       area_Cores = histo[17]
       area_holes = histo[100]
       area_oBG = histo[0]
       area_bg = area_oBG + area_holes
       area_fg = area_data - area_bg

       ;; add the remaining stats: edge, perf, margin
       area_edge = histo[3]
       area_perf = histo[5]
       area_islet = histo[9]
       area_margin = histo[1]
       area_contiguous = area_Cores + area_edge + area_perf
       area_internal = area_contiguous + area_holes
       porosity = 100.0 - (double(area_contiguous) / area_internal * 100.0)
    
       ;;=======================================
       ;; write the final result 
       res = file_basename(input, '.tif')
       fn_out = dir_batch + res + '_' + ev2 + '.tif'
       ;; get the correct colortable
       restore, info.dir_guidossub + 'mspacolorstoff.sav' & tvlct, r, g, b
       ;; add the geotiff info if available
       IF (size(geotiffinfo))[0] gt 0 THEN $
         write_tiff, fn_out, image0, red = r, green = g, blue = b, geotiff = geotiffinfo, description = desc, compression = 1 ELSE $
         write_tiff, fn_out, image0, red = r, green = g, blue = b, description = desc, compression = 1

       ;; write out statistics 
       fx = dir_batch + res + '_' + ev2 + '.txt' & file_delete,fx,/allow_nonexistent,/quiet
       conv1 = 100.0/area_data & conv2 = 100.0/area_fg & close, 12
       openw,12,fx
       printf, 12, spax + ': 8-connected Foreground, summary analysis for image: '
       printf, 12, input
       printf, 12, '  '
       printf, 12, 'Image Dimension X/Y: ' + strtrim(sz(0),2) + '/' + strtrim(sz(1),2)
       printf, 12, 'Image Area =               Data Area                    + No Data (Missing) Area'
       printf, 12, '           = [ Foreground (FG) +   Background (BG)  ]     +          Missing    '
       printf, 12, '           = [        FG       + {Core-Opening + other BG} ] +       Missing    '
       printf, 12, '  '
       printf, 12, '================================================================================'
       printf, 12, '           Category              Area [pixels]: '
       printf, 12, '================================================================================'
       if ev2 eq 'spa2' then begin
         printf, 12, format='(a20,i22)', '        Contiguous: ', area_contiguous 
         printf, 12, format='(a20,i22)', '+              SLF: ', area_margin
         printf, 12, '--------------------------------------------------------------------------------'
         printf, 12, format='(a20,i22)',   '= Foreground Total: ', area_fg
         goto, spa2skipb1
       endif            
       printf, 12, format='(a20,i22)',   '              Core: ', area_cores
       if ev2 eq 'spa3' then begin
         printf, 12, format='(a20,i22)', '+           Margin: ', area_margin
       endif else begin
         if ev2 eq 'spa6' then $
          printf, 12, format='(a20,i22)', '+            Islet: ', area_islet
         printf, 12, format='(a20,i22)', '+             Edge: ', area_edge
         printf, 12, format='(a20,i22)', '+      Perforation: ', area_perf
         printf, 12, format='(a20,i22)', '+           Margin: ', area_margin
         printf, 12, '(Contiguous = Core + Edge + Perforation: ' + strtrim(area_contiguous, 2) + ')'
       endelse
       printf, 12, '--------------------------------------------------------------------------------'
       printf, 12, format='(a20,i22)',   '= Foreground Total: ', area_fg
       printf, 12, '  '
       printf, 12, format='(a20,i22)',   '      Core-Opening: ', area_holes
       printf, 12, format='(a20,i22)',   '+         Other BG: ', area_oBG
       printf, 12, '--------------------------------------------------------------------------------'
       printf, 12, format='(a20,i22)',   '= Background Total: ', area_bg
       printf, 12, '  '
       printf, 12, format='(a20,i22)',   '  Foreground Total: ', area_fg
       spa2skipb1:
       printf, 12, format='(a20,i22)',   '+ Background Total: ', area_bg
       printf, 12, '--------------------------------------------------------------------------------'
       printf, 12, format='(a20,i22)',   '=  Data Area Total: ', area_data
       printf, 12, '  '
       printf, 12, format='(a20,i22)',   '         Data Area: ', area_data
       printf, 12, format='(a20,i22)',   '+          Missing: ', ct_qmiss
       printf, 12, '--------------------------------------------------------------------------------'
       printf, 12, format='(a20,i22)',   '= Image Area Total: ', area_image
       printf, 12, '  '
       printf, 12, '  '
       printf, 12, '================================================================================'
       printf, 12, '           Category    Proportion [%]: '
       printf, 12, '================================================================================'
       if ev2 eq 'spa2' then begin
         printf, 12, format='(a20,f11.4)', '   Contiguous/Data: ', area_contiguous * conv1
         printf, 12, format='(a20,f11.4)', '+         SLF/Data: ', area_margin * conv1
         printf, 12, '--------------------------------------------------------------------------------'
         printf, 12, format='(a20,f11.4)',   '           FG/Data: ', area_fg * conv1
         printf, 12, '--------------------------------------------------------------------------------'
         printf, 12, format='(a20,f11.4)', '     Contiguous/FG: ', area_contiguous * conv2
         printf, 12, format='(a20,f11.4)', '+           SLF/FG: ', area_margin * conv2
         goto, spa2skipb2
       endif
       printf, 12, format='(a20,f11.4)',   ' Core-Opening/Data: ', area_holes * conv1
       printf, 12, '--------------------------------------------------------------------------------'
       printf, 12, format='(a20,f11.4)',   '         Core/Data: ', area_cores * conv1
       if ev2 eq 'spa3' then begin
         printf, 12, format='(a20,f11.4)', '       Margin/Data: ', area_margin * conv1
       endif else begin
         if ev2 eq 'spa6' then $
           printf, 12, format='(a20,f11.4)', '        Islet/Data: ', area_islet * conv1
         printf, 12, format='(a20,f11.4)', '         Edge/Data: ', area_edge * conv1
         printf, 12, format='(a20,f11.4)', '  Perforation/Data: ', area_perf * conv1
         printf, 12, format='(a20,f11.4)', '       Margin/Data: ', area_margin * conv1
         printf, 12, format='(a20,f11.4)', '   Contiguous/Data: ', area_contiguous * conv1
       endelse
       printf, 12, '--------------------------------------------------------------------------------'
       printf, 12, format='(a20,f11.4)',   '           FG/Data: ', area_fg * conv1
       printf, 12, '--------------------------------------------------------------------------------'
       printf, 12, format='(a20,f11.4)',   '           Core/FG: ', area_cores * conv2
       if ev2 eq 'spa3' then begin
         printf, 12, format='(a20,f11.4)', '         Margin/FG: ', area_margin * conv2
       endif else begin
         if ev2 eq 'spa6' then $
           printf, 12, format='(a20,f11.4)', '          Islet/FG: ', area_islet * conv2
         printf, 12, format='(a20,f11.4)', '           Edge/FG: ', area_edge * conv2
         printf, 12, format='(a20,f11.4)', '    Perforation/FG: ', area_perf * conv2
         printf, 12, format='(a20,f11.4)', '         Margin/FG: ', area_margin * conv2
         printf, 12, format='(a20,f11.4)', '     Contiguous/FG: ', area_contiguous * conv2
         printf, 12, format='(a20,f11.4)', '          Porosity: ', porosity
       endelse
       spa2skipb2:
       printf, 12, '================================================================================'
       printf, 12, '  '
       printf, 12, '  '
       printf, 12, '================================================================================'
       printf, 12, '           Category          Count [#]: '
       printf, 12, '================================================================================'
       if ev2 eq 'spa2' then begin
         printf, 12, format='(a20,i15)',   '        Contiguous: ', nr_cores
         printf, 12, format='(a20,i15)',   '        FG Objects: ', nr_fg
         printf, 12, format='(a20,i15)',   '               SLF: ', nr_margin
         goto, spa2skipb3
       endif
       printf, 12, format='(a20,i15)',   '      Core-Opening: ', nr_holes
       printf, 12, format='(a20,i15)',   '        FG Objects: ', nr_fg
       printf, 12, '--------------------------------------------------------------------------------'
       printf, 12, format='(a20,i15)',   '              Core: ', nr_cores
       if ev2 eq 'spa3' then begin
         printf, 12, format='(a20,i15)', '            Margin: ', nr_margin
       endif else begin
         if ev2 eq 'spa6' then $
          printf, 12, format='(a20,i15)', '             Islet: ', nr_islet
         printf, 12, format='(a20,i15)', '              Edge: ', nr_edge
         printf, 12, format='(a20,i15)', '       Perforation: ', nr_perf
         printf, 12, format='(a20,i15)', '            Margin: ', nr_margin
         printf, 12, format='(a20,i15)', '        Contiguous: ', nr_contiguous
       endelse
       spa2skipb3:
       printf, 12, '================================================================================'
       close, 12
              
       ;; update the log-file
       okfile = okfile + 1
       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'File: ' + input
       printf, 9, spax + ' comp.time [sec]: ', systime( / sec) - time0
       close, 9

       skip_spa:
       stepn = (fidx + 1.0)/nr_im_files * 100.0
       progressBar -> Update, stepn
     ENDFOR
     progressBar -> Destroy
     Obj_Destroy, progressBar


     ;; inform that batch is done
     proct = systime( / sec) - time00
     IF proct GT 3600.0 THEN BEGIN
       proct2 = proct - ulong(proct/3600)*3600
       proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDIF ELSE BEGIN
       proctstr = strtrim(ulong(proct/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDELSE
     IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
     openw, 9, fn_logfile, /append
     printf, 9, ''
     printf, 9, '==============================================='
     printf, 9, spax + ' Batch Processing total comp.time: ', proctstr
     printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
     printf, 9, '==============================================='
     close, 9

     msg = spax + ' Batch Processing finished.' + string(10b) + $
       'Total computation time: ' + proctstr + string(10b) + $
       'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
       'More information can be found in the logfile: ' + string(10b) + fn_logfile
     res = dialog_message(msg, / information)

     ;; reset the colortable to the settings before the batch processing
     tvlct, rini, gini, bini
     goto,fin
   END

   ;;*****************************************************************************************************

   'mspa':  BEGIN
      ;; check for input compliance:
      ;; 1) if already a mspa image then quit
      IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_cs22 EQ 1 OR info.is_nw EQ 1 OR info.is_contort GT 0 OR info.is_influ gt 0 OR info.is_cost EQ 1 THEN BEGIN
         res = dialog_message(info.wronginput, / information)
         GOTO, fin
      ENDIF

      ;; 2) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
         info.selsubregion_id = 0
         ;; deactivate zoomfactor selector
         widget_control, info.w_zoomfac, sensitive = 1
         widget_control, info.w_selsubregion, $
                         set_value = 'Zoom Mode'
         ;; restore the prezoomed process image
         * info.process = * info.prezoomprocess
         ;; disable button and enable motion events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 1
         widget_control, info.w_draw, Draw_Button_Events = 0
         info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF

      ;; 3) check input compliance
      MSPA_Compliance, info.fname_input, * info.fr_image, info.immaxsize, 1, result
      IF result EQ 0 THEN GOTO, fin  ;; invalid input

      ;; we must process the full resolution image
      image0 = * info.fr_image

      ;; needed params, defaults
      tmp4conn = ['8', '4']
      c_FGconn = tmp4conn(1 - info.mspa_param1_id)
      c_size = info.mspa_size_current
      if long(c_size) gt 100 then begin
        res = dialog_message('MSPA parameter2 EdgeWidth must be in [1, 100].' + string(10b) + $
          'Please adjust accordingly and press Enter TWICE.' + string(10b) + 'Returning...', / error)
        goto, fin     
      endif    
      c_trans = strtrim(info.mspa_param3_id - 0, 2)
      c_intext = strtrim(info.mspa_param4_id - 0, 2)

      tmp_in = info.dir_tmp + 'inputmorph.tif'
      tmp_out = info.dir_tmp + 'outputmorph.tif'
      FGp = ulong64(total(image0 eq 2b)) ;; FG-pixels
      ;; rotate image back to original orintation for MSPA!!!
      image0 = rotate(image0,7)
      write_tiff, tmp_in, temporary(image0), compression = 1


      ;; execute the segmentation,  pipe the mia shell verbose output
      ;; to 'log' so it will not be seen
      IF info.my_os EQ 'windows' THEN BEGIN
         pushd, info.dir_guidossub
         cmd = 'mspa.exe -graphfg ' + c_FGconn + $
               ' -eew ' + c_size + ' -internal ' + c_intext + $
               ' -disk -transition ' + c_trans + $
               ' -i mspatmp\inputmorph.tif' + $
               ' -o outputmorph.tif -odir mspatmp\'
         time0 = systime( / sec)
         widget_control, / hourglass
         spawn, cmd, log, / hide
         popd
      ENDIF ELSE BEGIN
         pushd, info.dir_tmp
         IF info.my_os EQ 'linux' THEN mspa_os = 'mspa_lin' ELSE mspa_os = 'mspa_mac'
         cmd = info.dir_guidossub + mspa_os + ' -graphfg ' + c_FGconn + $
               ' -eew ' + c_size + ' -internal ' + c_intext + ' -disk -transition ' + c_trans + $
               ' -i inputmorph.tif -o outputmorph.tif -odir ./'
         time0 = systime( / sec)
         widget_control, / hourglass
         spawn, cmd, log
         popd
      ENDELSE

      print, 'MSPA comp.time [sec]: ', systime( / sec) - time0

      ;;get the result, update the GUIDOS info, clean dir_tmp
      pushd, info.dir_tmp
      ;; Fedora-fix, for whatever reason they rename the output.tif to something else
      fedora=(file_search('*outputmorph.tif'))[0]
      file_move, fedora, 'outputmorph.tif',/overwrite,/allow_same
      image0 = read_tiff('outputmorph.tif')
      file_delete, 'inputmorph.tif', 'outputmorph.tif', / quiet
      ;;
      ;; rotate image back to orintation in Guidos!!!
      ;;
      image0 = rotate(image0,7)
      iFG = ulong64(total(image0 eq 100b or image0 eq 220b)) + FGp

      popd
      * info.process = temporary(image0)
      * info.fr_image = * info.process

      IF info.mspa_param3_id EQ 1b THEN $
       restore, info.dir_guidossub + 'mspacolorston.sav' ELSE $
       restore, info.dir_guidossub + 'mspacolorstoff.sav'
      tvlct, r, g, b
      info.ctbl = - 1 & info.disp_colors_id = 3
      widget_control, info.w_labelstr, set_value = 'MSPA-Core pixels: '
      widget_control, info.w_label_t1, set_value = ['X','1000', '4500','10000']
      widget_control, info.w_label_t2, set_value = ['X','4600', '11000','25000']
      widget_control, info.w_label_t1, set_combobox_select = 1 & info.label_t1 = 1000
      widget_control, info.w_label_t2, set_combobox_select = 1 & info.label_t2 = 4600

      c_trans = strtrim(fix(info.mspa_param3_id), 2) & c_intext = strtrim(fix(info.mspa_param4_id), 2)
      c_FG = ', FG_area: ' + strtrim(FGp,2) + ', iFG_area: ' + strtrim(iFG,2)
      info.add_title = ' (MSPA: ' + c_FGconn + '_' + c_size + '_' + c_trans + '_' + c_intext + c_FG + ')'
      info.is_mspa = 1
      skip_mspa:

   END
   
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;                  C O N E F O R   I N P U T S     B A T C H
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   'batch_ci':  BEGIN
      tit = 'Select raster image-file(s)'
      filters = [['*.tif;*.tiff','*.png','*gif','*.bmp','*.jpg;*.jpeg','*.jp2;*.jpx','*.*'], $
      ['TIFF','PNG','GIF','BITMAP','JPEG','JPEG2000','All files']]
      im_file = $
        dialog_pickfile(Title = tit, get_path = path2file, $
        path = info.dir_data, default_extension = 'tif', / fix_filter, $
        / must_exist, / multiple_files, FILTER = filters)
      IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
      
      ;; test that the directory of the selected files has no sub-directories
      ;; this will also ensure no output file is opened in excel or thelike
      pushd, path2file
      list = file_search() & nl = n_elements(list) & nr_dir = 0
      for idx = 0, nl-1 do begin
        q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
      endfor
      IF nr_dir GT 0 THEN BEGIN
        msg = 'The directory of your Batch ConeforInputs input files contains sub-directories.'  +  string(10b) +  string(10b) + $
          'Please set up a new directory having Batch ConeforInputs input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF
      popd
      
      ;; test that we can write into the parent directory or if it exists already
      batch_type = 'batch_ConeforInputs'
      dd = file_dirname(im_file[0], / mark_directory)
      dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
      res = file_test(dir_batch, /directory, /write)
      if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
        res = dialog_message(msg,/question)
        If res eq 'No' then goto, fin
        ;; empty it
        pushd, dir_batch
        list = file_search() & nl = n_elements(list)
        if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
        popd
      endif else begin ;; does not exist yet, create it
        file_mkdir, dir_batch
      endelse

   
      title = 'ConeforInputs Batch Processing'
      goto, resetfront
      
      backto_batch_ci:
      ;;========================================================================
      ;; ok, the files are selected, get the  CI-params
      ;;========================================================================
      cancel = ptr_new(1b) & CI1 = ptr_new('8') & CI2 =ptr_new('Edge2Edge')
      get_CIparams, cancel = cancel, Group_Leader = event.top, $
         title = title, CI1 = CI1, CI2 = CI2

      ;; check if cancel was selected then do nothing else start
      ;; batch processing with the selected settings
      IF * cancel EQ 0b THEN BEGIN ;; get the values
         CI_FGconn = * CI1 & CI_dist = * CI2         
         ;; free and delete the temporary pointers
         ptr_free, cancel & cancel = 0b
         ptr_free, CI1 & CI1 = 0b & ptr_free, CI2 & CI2 = 0b
      ENDIF ELSE BEGIN  ;; cancel was selected
         ptr_free, cancel & cancel = 0b
         ptr_free, CI1 & CI1 = 0b & ptr_free, CI2 & CI2 = 0b
         GOTO, fin
      ENDELSE
      ;;========================================================================

      ;; validate and process the images in a loop
      nr_im_files = n_elements(im_file) & verbose = nr_im_files eq 1
      fn_logfile = dir_batch + batch_type + '.log'
      time00 = systime( / sec) & okfile = 0l
      ;; initiate log-file
      openw, 9,fn_logfile
      printf, 9, 'ConeforInputs logfile: ', systime()
      printf, 9, 'Number of files to be processed: ', nr_im_files
      printf, 9, '==============================================='
      close, 9
      msg = 'Processing selected images for ConeforInputs, please wait...'
      progressBar = Obj_New("SHOWPROGRESS", message = msg, title=title, /cancel)
      progressBar -> Start
      
      ;; supported image file types 
      ftypes='TIFF, PNG, GIF, BITMAP, JPEG, JPEG2000'
 
      FOR fidx = 0, nr_im_files - 1 DO BEGIN
        counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)

        IF progressBar -> CheckCancel() THEN BEGIN
          res = Dialog_Message('Batch-processing cancelled by user.')
          openw, 9, fn_logfile, /append
          printf, 9, 'Batch-processing cancelled by user.'
          close, 9
          progressBar -> Destroy
          Obj_Destroy, progressBar
          tvlct, rini, gini, bini
          GOTO, fin
        ENDIF
   
         ;; validate the input, if not skip it without message
         fname = im_file(fidx) & res = query_image(fname, inpinfo) & msgr=''
         openw, 9, fn_logfile, /append
         printf, 9, strtrim(fidx+1,2)+') ' + fname + ': '
         close, 9
         
         ;; check for empty filename
         ;;============================
         q = strpos(fname,' ') ge 0
         IF q EQ 1 THEN BEGIN
           msgr = 'Empty space in directory path or input filename.'
           openw, 9, fn_logfile, /append
           printf, 9,msgr & printf, 9,'Skipping invalid ConeforInputs input file.'
           close, 9
           GOTO, skip_batch_CI  ;; invalid CI input
         ENDIF
         
         ;; check if image can be read
         ;;===========================       
         IF res EQ 0 THEN BEGIN
            msgr = 'Input image file format is not of type: ' + ftypes
            openw, 9, fn_logfile, /append
            printf, 9,msgr & printf, 9,'Skipping invalid ConeforInputs input file.'
            close, 9
            GOTO, skip_batch_CI  ;; invalid CI input
         ENDIF
         
         ;; check for single image in file
         ;;===========================
         IF inpinfo.num_images GT 1 THEN BEGIN
            msgr = 'Input file has more than 1 image. Please load a non-stacked image.'
            openw, 9, fn_logfile, /append
            printf, 9,msgr & printf, 9,'Skipping invalid ConeforInputs input file.'
            close, 9
            GOTO, skip_batch_CI  ;; invalid CI input
         ENDIF
         
         ;; check for single channel image
         ;;===========================
         IF inpinfo.channels GT 1  THEN BEGIN
            msgr = 'Input image has more than 1 band. ' + string(10b) + $
                  "Try using General Tools: Preprocessing: RGB -> Single Band" 
            openw, 9, fn_logfile, /append
            printf, 9,msgr & printf, 9,'Skipping invalid ConeforInputs input file.'
            close, 9
            GOTO, skip_batch_CI  ;; invalid CI input
         ENDIF         
         
         ;; check min/max value in image
         ;;===========================
         image0 = read_image(fname) & image0 = abs(image0) & mxx = max(image0, min = mii)
         ;; rotate the image
         image0 = rotate(image0,7)

         IF mxx EQ mii THEN BEGIN
            msgr = 'Image has no objects.'
            openw, 9, fn_logfile, /append
            printf, 9,msgr & printf, 9,'Skipping invalid ConeforInputs input file.'
            close, 9
            GOTO, skip_batch_CI  ;; invalid CI input       
         ENDIF ELSE IF mxx LT 2 THEN BEGIN
            msgr = 'Image has no valid foreground objects. ' + string(10b) + $
                  'ConeforInputs will calculate area and distance ONLY'  + string(10b) + $
                  'for foreground objects having a value of 2.' 
            openw, 9, fn_logfile, /append
            printf, 9,msgr & printf, 9,'Skipping invalid ConeforInputs input file.'
            close, 9
            GOTO, skip_batch_CI  ;; invalid CI input            
         ENDIF

         ;; check for maximum image size 
         ;; 65000 x 65000 (so we can use ulong for revind, defined up to 2.0^32-1)
         ;; constrain to maximum of 5000 x 5000
         ;;===============================
         sz = inpinfo.dimensions & fsz = float(sz[0])*sz[1] & mxfsz=25000100 
         IF fsz GT mxfsz THEN BEGIN
           msgr = 'Exceeded ConeforInputs maximum image dimensions: 5000x5000' 
            openw, 9, fn_logfile, /append
            printf, 9,msgr & printf, 9,'Skipping invalid ConeforInputs input file.'
            close, 9
            GOTO, skip_batch_CI  ;; invalid CI input
         ENDIF

         IF CI_dist EQ 'Edge2Edge' THEN CI_dist2 = 'edge' ELSE CI_dist2 = 'centroid'
         fx =  file_basename(fname) & pp=strpos(fx,'.',/reverse_search) & fx = strmid(fx,0,pp)
         fn_outbase = fx + '_' + CI_FGconn + '_' + CI_dist2 

         ;; now all is ok for processing
         time0 = systime( / sec) 
 
         ;;  A) Node file
         ;;
         ;; labeling must be done on extended image to avoild
         ;; zeroed boundaries, go back to original dimension later                           
         ext = uintarr(sz(0) + 2, sz(1) + 2) & sz2=size(ext,/dim)
         ext[1:1 + sz(0) - 1, 1:1 + sz(1) - 1] = temporary(image0) eq 2
         all_n = CI_FGconn EQ '8'
         widget_control, / hourglass
         objects = label_region(ext, all_neighbors=all_n, / ulong)
         n_obj=max(objects)
         IF n_obj LT 2 THEN BEGIN
           msgr = 'Image has less than 2 objects.'
           openw, 9, fn_logfile, /append
           printf, 9,msgr & printf, 9,'Skipping invalid ConeforInputs input file.'
           close, 9
           objects=0 & ext=0
           GOTO, skip_batch_CI  ;; invalid CI input
         ENDIF
         
         obj_area = histogram(objects, reverse_indices = revind, / l64)        
     
         ;; write the final result to the initial input dir
         fn_out = dir_batch + 'nodes_' + fn_outbase + '.txt'
         openw, 1, fn_out
         FOR is = 1l, n_obj DO printf, 1, strtrim(is,2), obj_area(is)
         close, 1

         ;;  B) Distance file
         ;; calculate the distance in the objects image 
         ;; (that image already has the user-selected fg-conn)
         ;; FG-connectivity: 8 <=> euclidean distance;  4 <=> cityblock
         write_tiff, dir_batch + 'objects_' + fn_outbase + '.tif', objects, long=n_obj gt 255, compression = 1
         ;;write_tiff, dir_input + 'objects_' + fn_outbase + '.tif', rotate(objects,7), long=n_obj gt 255, compression = 1
         fn_out = dir_batch + 'distance_' + fn_outbase + '.txt' & openw, 1, fn_out        
         obj_last=max(objects)
         
         IF CI_dist2 EQ 'edge' THEN BEGIN
           ;;================================================================
           ;;                 edge to edge distance
           ;;================================================================       
           ;; loop over objects           
           FOR il = 1ul, obj_last-1 DO BEGIN
             ;; euclidean bg-distance field from object a
             dist_a = objects EQ il
             dist_a = morph_distance(dist_a, / background, neighbor = 3, / no_copy)
             pa = revind[revind[il]:revind[il+1]-1] ;; area indices of A
             pa = Find_Boundary(pa, XSize=sz2(0), YSize=sz2(1)) ;; x/y-coord of boundary of A
          
             FOR jl = il+1ul, obj_last DO BEGIN
               pb = revind[revind[jl]:revind[jl+1]-1]
               ;; find minimum distance and its pixel
               q=(sort(dist_a[pb]))[0] & loc_b=array_indices(dist_a,pb[q]) ;; dd = min(dist_a[pb])
               
               ;; find minimum distance from loc_b to pa             
               ;; and account for outside to outside edge distance
               dx2 = ( (abs(pa(0,*)-loc_b(0)) > 1.0) - 1.0)^2 & dy2 = ( (abs(pa(1,*)-loc_b(1)) > 1.0) - 1.0)^2
               dd = min(sqrt( dx2 + dy2 ))                     
               printf, 1, strtrim(il,2), jl, dd                
            ENDFOR
          ENDFOR ; end loop over objects
          close,1
 
         ENDIF ELSE BEGIN
           ;;================================================================
           ;;                 centroid to centroid distance
           ;;================================================================
           centroids=fltarr(2)
           FOR is = 1ul, n_obj DO BEGIN
             p = revind[revind[is]:revind[is+1]-1]
             a = Find_Boundary(p, XSize=sz2(0), YSize=sz2(1), center=center)
             centroids=[ [centroids], [center] ]
           ENDFOR
           ;; compute centroid distances
           dist = distance_measure(centroids[*,1:*]) & di = -1l
           ;; write centroid distances to the initial input dir          
           FOR il = 1ul, obj_last-1 DO BEGIN         
             FOR jl = il+1ul, obj_last DO BEGIN
               di=di+1 & printf, 1, strtrim(il,2), jl, dist[di]                
             ENDFOR
           ENDFOR
           close,1
           
           ;; compute cluster distances and dendrogram
           clusters = cluster_tree(dist, link_dist, linkage=2)
           fn_clust = dir_batch + 'dendrogram_' + fn_outbase + '.txt' & openw, 1, fn_clust        
           ;; write cluster distances to the initial input dir   
           printf,1,'Hierarchical Clustering of ' + strtrim(n_obj,2) + ' objects.'
           printf,1,'There are n_object-1 (' + strtrim(n_obj-1,2) + $
             ') clusters, starting with ID: n_object+1 (' + strtrim(n_obj+1,2)+').'
           printf,1,'    ID    Cluster_ID  Object_ID  Object_ID    Distance'
           FOR jl = 0, n_elements(link_dist)-1 DO printf, 1, FORMAT='(i6, 3(I11), F15.5)',$
                 strtrim(jl+1,2), strtrim(n_obj+jl+1,2), clusters[*,jl], link_dist[jl]
           close,1
                     
           
         ENDELSE 
         
         openw, 9, fn_logfile, /append
         printf, 9, 'ConeforInputs comp.time [sec]: ', systime( / sec) - time0
         close, 9
         okfile = okfile + 1
         skip_batch_CI:
         stepn = (fidx + 1.0)/nr_im_files * 100.0
         progressBar -> Update, stepn
         
         openw, 9, fn_logfile, /append
         printf, 9, '==============================================='
         close, 9
      ENDFOR
      progressBar -> Destroy
      Obj_Destroy, progressBar

      ;; reset the colortable to the settings before the batch processing
      tvlct, rini, gini, bini
      proct = systime( / sec) - time00 
      IF proct GT 3600.0 THEN BEGIN
        proct2 = proct - ulong(proct/3600)*3600
        proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
      ENDIF ELSE BEGIN 
        proctstr = strtrim(ulong(proct/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
      ENDELSE
      IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs' 
      openw, 9, fn_logfile, /append
      printf, 9, 'Batch ConeforInputs total comp.time: ', proctstr 
      printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
      printf, 9, '==============================================='
      close, 9 
      
      IF verbose EQ 1 AND msgr NE "" THEN res = dialog_message(msgr, / information)
      msg = 'Batch ConeforInputs processing finished.' + string(10b) + $
        'Total computation time: ' + proctstr + string(10b) + $
        'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
        'More information can be found in the logfile: ' + string(10b) + fn_logfile
      res = dialog_message(msg, / information)
     
      ;; Show the dendrogram if these conditions are met
      ;DENDRO_PLOT, clusters, link_dist, $
      ;XSTYLE = 9, YSTYLE = 9, XTITLE = 'Leaf', YTITLE = 'Distance'
      ;
;      condition = CI_dist2 EQ 'centroid' AND n_obj LT 300 AND verbose eq 1
;      IF condition THEN BEGIN
;        ;; use new function dendro_plot instead of dendrogram
;        DENDROGRAM, clusters, link_dist, outverts, outconn, LEAFNODES = LEAFNODES
;        OPOLY = OBJ_NEW('IDLgrPolyline', outverts, POLYLINES = outconn)
;        LOC = FLTARR(2, n_obj) & LOC[0, *] = FINDGEN(n_obj)
;        OTEXT = OBJ_NEW('IDLgrText', STRTRIM(LEAFNODES,2), $
;           ALIGNMENT = 1, VERTICAL_ALIGN = 0.5, BASELINE = [0,1,0], UPDIR = [-1,0,0], $
;           CHAR_DIM = [1,1], LOCATIONS = loc)
;        OAXIS = OBJ_NEW('IDLgrAxis', 1, /EXACT, LOCATION = [-1,0,0], RANGE = [0, MAX(link_dist)])
;        OAXIS -> GetProperty, TICKTEXT = oTick
;        OTICK -> SetProperty, CHAR_DIM = [1,1]
;        OMODEL = OBJ_NEW('IDLgrModel')
;        OMODEL -> Add, oPoly
;        OMODEL -> Add, oText
;        OMODEL -> Add, oAxis
;        XOBJVIEW, oModel,title='Hierarchical Cluster of Centroid distances'
;      ENDIF
      
      GOTO, fin
   END    

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;        M S P A - based  B A T C H
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   'batch_mspanw':  BEGIN
     tit = 'Please select MSPA-geotiff raster image-file(s)'
     filters = [['*.tif;*.tiff', 'TIF', 'TIFF']]
     im_file = dialog_pickfile(Title = tit, get_path = path2file, $
       path = info.dir_data, default_extension = 'tif', / fix_filter, $
       / must_exist, / multiple_files, FILTER = filters)
     IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
     
     ;; test that the directory of the selected files has no sub-directories
     ;; this will also ensure no output file is opened in excel or thelike
     pushd, path2file
     list = file_search() & nl = n_elements(list) & nr_dir = 0
     for idx = 0, nl-1 do begin
       q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
     endfor
     IF nr_dir GT 0 THEN BEGIN
       msg = 'The directory of your Batch MSPA-Network input files contains sub-directories.'  +  string(10b) +  string(10b) + $
         'Please set up a new directory having Batch MSPA-Network input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     popd

     
     case eventValue2 of
       'batch_mspaci':  begin
         batch_type = 'batch_MSPA_ConeforInputs'
         title = 'MSPA ConeforInputs Batch Processing'
         logext = batch_type + '.log'
         headtxt = 'MSPA ConeforInputs logfile: '
         guitit = 'MSPA ConeforInputs'
        end
       'batch_nwcomp':  begin
         batch_type = 'batch_MSPA_NWComponents'
         title = 'Network Components Batch Processing'
         logext = batch_type + '.log'
         headtxt = 'NW Components logfile: '
         guitit = 'Network Components'
        end
       'batch_nlimp':  begin
         batch_type = 'batch_MSPA_NWNLimportance'
         title = 'Node/Link Importance Batch Processing'
         logext = batch_type + '.log'
         headtxt = 'NW Node/Link Importance logfile: '
         guitit = 'Node/Link Importance'
        end
     endcase   
     
     ;; test that we can write into the parent directory or if it exists already
     dd = file_dirname(im_file[0], / mark_directory)
     dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
     res = file_test(dir_batch, /directory, /write)
     if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
       res = dialog_message(msg,/question)
       If res eq 'No' then goto, fin
       ;; empty it
       pushd, dir_batch
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd
     endif else begin ;; does not exist yet, create it
       file_mkdir, dir_batch
     endelse
      
     goto, resetfront

     backto_batch_mspanw:
     ;;========================================================================
     ;; ok, the files are selected, validate and process the images in a loop
     ;;========================================================================
     nr_im_files = n_elements(im_file) & verbose = nr_im_files eq 1
     fn_logfile = dir_batch + logext
     time00 = systime( / sec) & okfile = 0l

     ;; initiate log-file
     openw, 9,fn_logfile
     printf, 9, headtxt, systime()
     printf, 9, 'Number of files to be processed: ', nr_im_files
     printf, 9, '==============================================='
     close, 9
     ;; supported image file types
     ftypes='TIFF'
     msg = 'Processing selected images for ' + guitit + ', please wait...'
     progressBar = Obj_New("SHOWPROGRESS", message = msg, title=title, /cancel)
     progressBar -> Start

     ;; begin of file loop 
     FOR fidx = 0, nr_im_files - 1 DO BEGIN
       counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
       IF progressBar -> CheckCancel() THEN BEGIN
         res = Dialog_Message('Batch-processing cancelled by user.')
         openw, 9, fn_logfile, /append
         printf, 9, 'Batch-processing cancelled by user.'
         close, 9
         progressBar -> Destroy
         Obj_Destroy, progressBar
         tvlct, rini, gini, bini
         GOTO, fin
       ENDIF

       ;; validate the input, if not skip it without message
       fname = im_file(fidx) & res = query_image(fname, inpinfo) & msgr=''
       openw, 9, fn_logfile, /append
       printf, 9, strtrim(fidx+1,2)+') ' + fname + ': '
       close, 9

       ;; check for empty filename
       ;;============================
       q = strpos(fname,' ') ge 0
       IF q EQ 1 THEN BEGIN
         msgr = 'Empty space in directory path or input filename.'
         openw, 9, fn_logfile, /append
         printf, 9,msgr & printf, 9,'Skipping invalid ' + guitit + ' input file.'
         close, 9
         GOTO, skip_batch_mspaCI  ;; invalid CI input
       ENDIF

       
       ;; check if image can be read
       ;;===========================
       IF res EQ 0 THEN BEGIN
         msgr = 'Input image file format is not of type: ' + ftypes
         openw, 9, fn_logfile, /append
         printf, 9,msgr & printf, 9,'Skipping invalid ' + guitit + ' input file.'
         close, 9
         GOTO, skip_batch_mspaCI  ;; invalid CI input
       ENDIF

       ;; check for single image in file
       ;;===========================
       IF inpinfo.num_images GT 1 THEN BEGIN
         msgr = 'Input file has more than 1 image. Please load a non-stacked image.'
         openw, 9, fn_logfile, /append
         printf, 9,msgr & printf, 9,'Skipping invalid ' + guitit + ' input file.'
         close, 9
         GOTO, skip_batch_mspaCI  ;; invalid CI input
       ENDIF

       ;; check for single channel image
       ;;===========================
       IF inpinfo.channels GT 1  THEN BEGIN
         msgr = 'Input image has more than 1 band. ' + string(10b) + $
           "Try using General Tools: Preprocessing: RGB -> Single Band"
         openw, 9, fn_logfile, /append
         printf, 9,msgr & printf, 9,'Skipping invalid ' + guitit + ' input file.'
         close, 9
         GOTO, skip_batch_mspaCI  ;; invalid CI input
       ENDIF

       ;; check for mspa in image
       ;;===========================
       ;; check for geotiff
       IF info.my_os EQ 'windows' THEN BEGIN
         cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalinfo -noct "' + fname + '"'
       ENDIF ELSE BEGIN
         if strlen(info.sysgdal) gt 0 then $
           cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + fname + '"' else $
           cmd = info.dir_fwtools + 'gdalinfo -noct "' + fname + '"'
       ENDELSE

       IF info.my_os EQ 'windows' THEN spawn, cmd, log, / hide ELSE spawn, cmd, log & q = log[0]
       ftype = strmid(q, strpos(q, ': ') + 2, 13)
       IF ftype NE 'GTiff/GeoTIFF' THEN BEGIN
         msgr = 'Input image is not of type Geotiff. '
         openw, 9, fn_logfile, /append
         printf, 9,msgr & printf, 9,'Skipping invalid ' + guitit + ' input file.'
         close, 9
         GOTO, skip_batch_mspaCI  ;; invalid CI input
       ENDIF   
       
       mspaext = ''
       qq=where(strmid(log,0,27) EQ "  TIFFTAG_SOFTWARE=JRC MSPA") & qq=qq[0] & nx = 0
       IF qq GT 0 THEN BEGIN ;; get the MSPA parameters
         q=log(qq) & res=strsplit(q,' ',/extract,count=nx)
         if nx eq 4 then begin
           newimis_mspa=res(nx-1)
           z=strsplit(newimis_mspa, '_', /extract, count=zn)
           m4=strtrim(fix(z[zn-1]),2) & m3=strtrim(fix(z[zn-2]),2) 
           m2=strtrim(fix(z[zn-3]),2) & m1=strtrim(fix(z[zn-4]),2)
           mspaext = '_' + m1 + '_' + m2 + '_' + m3 + '_' + m4
         endif
       ENDIF   

       ;; the new way from 2.702
       qq=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_MSP") & qq=qq[0]
       if qq gt 0 then begin
         q=log(qq) & res=strsplit(q,' ',/extract,count=nx)
         if nx eq 3 then begin
           newimis_mspa=res(nx-1)
           z=strsplit(newimis_mspa, '_', /extract, count=zn)
           m4=strtrim(fix(z[zn-1]),2) & m3=strtrim(fix(z[zn-2]),2)
           m2=strtrim(fix(z[zn-3]),2) & m1=strtrim(fix(z[zn-4]),2)
           mspaext = '_' + m1 + '_' + m2 + '_' + m3 + '_' + m4
         endif
       endif      
       
       IF mspaext eq '' THEN BEGIN
         msgr = 'Input image is not MSPA.'
         openw, 9, fn_logfile, /append
         printf, 9,msgr & printf, 9,'Skipping invalid ' + guitit + ' input file.'
         close, 9
         GOTO, skip_batch_mspaCI  ;; invalid CI input
       ENDIF
       IF m1 EQ 4 AND (eventValue2 EQ 'batch_mspaci') THEN BEGIN
         msgr = 'Foreground connectivity must be 8 for ' + guitit + ' image.'
         openw, 9, fn_logfile, /append
         printf, 9,msgr & printf, 9,'Skipping invalid ' + guitit + ' input file.'
         close, 9
         GOTO, skip_batch_mspaCI  ;; invalid CI input
       ENDIF
       
       fx =  file_basename(fname) & pp=strpos(fx,'.',/reverse_search) & fx = strmid(fx,0,pp)
       fn_outbase = fx 

       ;; now all is ok for processing
       ;;===========================
       time0 = systime( / sec)
       
       ;; read the image
       image0 = read_tiff(fname, geotiff = geotiffz) & image0 = rotate(image0,7) & sz = size(image0, / dim)

       ;; labeling must be done on extended image to avoid zeroed boundaries
       eew = m2 & eew2 = eew * 2
       ext = bytarr(sz(0) + eew2, sz(1) + eew2)
       ext[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1] = temporary(image0)

       ;; cores + bridges, uniq networks and isolated cores
       corex = (ext GE 16b AND ext LE 18b) OR (ext GE 116b AND ext LE 118b)
       bridgex = (ext GT 30b AND ext LT 40b) OR (ext GT 130b AND ext LT 140b)

       ;; the networks on the extended image
       ext = corex + bridgex * 2b  
       
       IF eventValue2 EQ 'batch_mspaci' then begin
        ;;==========================================================================================
        ;;                                    MSPA ConeforInputs
        ;;==========================================================================================
         lbl_bridgex = label_region(ext EQ 2b, / all, / ulong)
         lbl_corex = label_region(ext EQ 1b, / all, / ulong)
         nr_bridge = max(lbl_bridgex) & nr_core = max(lbl_corex)

         IF nr_bridge EQ 0 THEN BEGIN
           msgr = 'Network without links.'
           openw, 9, fn_logfile, /append
           printf, 9,msgr & printf, 9,'Skipping invalid ' + guitit + ' input file.'
           close, 9
           GOTO, skip_batch_mspaCI  ;; invalid CI input
         ENDIF
         IF nr_core EQ 0 THEN BEGIN
           msgr = 'Network without nodes.'
           openw, 9, fn_logfile, /append
           printf, 9,msgr & printf, 9,'Skipping invalid ' + guitit + ' input file.'
           close, 9
           GOTO, skip_batch_mspaCI  ;; invalid CI input
         ENDIF

         ;; print table of unique objects and their areas in pixels, bridge
         ;; area is not considered. These are the unique "nodes" = cores + bridges
         h_core = histogram(lbl_corex, / l64)
         cs_nodes_file = dir_batch + fn_outbase +'_nodes_mspa.txt'
         openw, 1, cs_nodes_file
         ;;printf, 1, '         Object      Pixels'
         FOR i = 1l, nr_core DO printf, 1, strtrim(-i,2), h_core(i)
         FOR i = 1l, nr_bridge DO printf, 1, strtrim(i,2), '           0'
         close, 1

         ;; detect 8-connected neighboring different objects by looking in the
         ;; 8-con neighborhood of each bridge for unique core IDs
         ;; meaning: each bridge connects to which core IDs?
         se8 = replicate(1, 3, 3) ;; sel for 8-conn

         ;; dilate core into bridges to retrieve the edges of bridges
         ext = dilate(lbl_corex, se8, / gray, / ulong) * (lbl_bridgex GT 0)
         ;; the bridgeedge coordinate in lbl_bridge is the label of the bridge
         ;; se8 on this coordinate contains the core it connects to
         qb = where(ext GT 0, ct_b, /l64)
         fn_tmp = info.dir_tmp + 'cs22_tmp.txt'
         openw, 1, fn_tmp
         FOR idx = 0l, ct_b - 1 DO BEGIN
           bridge = lbl_bridgex(qb(idx)) + nr_core
           xy = array_indices(ext, qb(idx))
           vals = lbl_corex[xy(0) - 1:xy(0) + 1, xy(1) - 1:xy(1) + 1]
           uvals = vals[uniq(vals, sort(vals))] & uvals = uvals[1: * ]
           FOR i = 0l, n_elements(uvals) - 1 DO printf, 1, strtrim(bridge,2), uvals(i)
         ENDFOR
         close, 1 &  ext = 0

         ;; get the result and filter out duplicates
         res = lonarr(2, file_lines(fn_tmp))
         openr, 1, fn_tmp & readf, 1, res & close, 1 & file_delete, fn_tmp, / quiet
         cs_links_file = dir_batch + fn_outbase + '_links_mspa.txt'
         openw, 1, cs_links_file
         FOR idx = 1l, nr_bridge DO BEGIN
           id = idx + nr_core & q = where(res(0, * ) EQ id, ct, /l64)
           IF ct GT 0 THEN BEGIN
             vals = res(1, q) & uvals = vals[uniq(vals, sort(vals))]
             FOR bb = 0l, n_elements(uvals) - 1 DO printf, 1, strtrim(idx,2), -uvals(bb), '     1'
           ENDIF
         ENDFOR
         close, 1
       ENDIF ELSE IF eventValue2 EQ 'batch_nwcomp' then begin
       ;;==========================================================================================
       ;;                                Network Components
       ;;==========================================================================================
         qm = where(ext EQ 129b, ctqm, /l64)
         cl = byte([1, 5, 9, 17, 33, 65, 80, 150, 176])
         image0 = temporary(ext)
         ;; add ECA info
         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
         ;; MSPA components
         lbl_comp = label_region(image0, / all, / ulong)
         nr_comp = max(lbl_comp)

         ;; set area of links in components to zero and get area by component
         h_comp_area = histogram(lbl_comp * (image0 NE 2b), / l64)

         ;; PCnum:= overall connectivity. Sum of [ (core-areas per component)^2 ]
         pcnum = total(h_comp_area(1: * )^2, / double)

         ;; ECA: equivalent connected (core) area = sqrt(pcnum) [unit area, hectares]
         ECA = sqrt(pcnum)

         ;; ECA_rel: normalised/relative ECA, also known as DOC or
         ;; ARH: amount of reachable habitat (%)
         ;; PRH: percentage of reachable habitat
         ECA_max = total(h_comp_area[1:*])
         ECA_rel = ECA/ECA_max * 100.0
         
         nw_ids = label_region(image0, / all, / ulong)
         IF ctqm GT 0 THEN image0(qm) = 129b
         qm = 0
         nw_hnw = histogram(nw_ids, reverse_indices = r, / l64) ;; area of components
         nw_hnwb = nw_hnw * 0
         ;; assign random color to components with bridges and black for
         ;; those without bridges = isolated core components
         FOR i = 1l, n_elements(nw_hnw) - 1 DO BEGIN
           t = ulong(total(bridgex[r[r[i]:r[i + 1] - 1]]))
           nw_hnwb(i) = t & clx = i MOD 9
           IF t GT 0 THEN $
             image0[r[r[i]:r[i + 1] - 1]] = cl(clx) ELSE $
             image0[r[r[i]:r[i + 1] - 1]] = 103b
         ENDFOR
         mxn = strtrim(n_elements(nw_hnw) - 1, 2) & nw_mxinw = long(mxn)

         ;; load the colors-on table
         restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b
         
         ;; go back to original size
         nw_ids = nw_ids[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1]
         image0 = image0[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1]        
         result_title = ' [NW components: ' + mxn + ', ECA: ' + $
          strtrim(round(eca),2) + ', DOC: ' + strtrim(eca_rel,2) + '%]'
          
         ;; write out the results: 3 files: nw (viewport), nw_nwdata (area), nw_stat
         ;; 1) nw (viewport) = image0
         qq = strpos(fn_outbase,mspaext) & if qq lt 0 then fn_outbase = fn_outbase + mspaext
         fn = dir_batch + fn_outbase + '_nw.tif'
         write_tiff, fn, rotate(image0,7), red = r, green = g, blue = b, geotiff = geotiffz, compression = 1
                 
         ;; 2) nw_nwdata (area) = nw_ids
         fn = dir_batch + fn_outbase + '_nw_nwdata.tif'
         write_tiff, fn, rotate(nw_ids,7), /long, geotiff = geotiffz, compression = 1        
         
         ;; 3) nw_stat
         fn = dir_batch + fn_outbase + '_nw.txt'
         openw, 1, fn
         printf, 1, 'Network analysis results using: ' + fn_outbase
         printf, 1, result_title
         printf, 1, '============================================================================'
         printf, 1, '  Component           Size: total                links'
         printf, 1, '============================================================================'
         FOR idx = 1, nw_mxinw DO printf, 1, idx, nw_hnw[idx], nw_hnwb[idx]
         printf, 1, ' '
         close, 1         

       ENDIF ELSE BEGIN ;; 'batch_nlimp'
       ;;==========================================================================================
       ;;                                Node/Link - importance 
       ;;==========================================================================================
         image0 = temporary(ext)
         lbl_links = label_region(image0 EQ 2b, / all, / ulong) & nr_links = max(lbl_links)
         lbl_nodes = label_region(image0 EQ 1b, / all, / ulong) & nr_nodes = max(lbl_nodes)
  
         IF nr_links EQ 0 THEN BEGIN
           msgr = 'Network without links.'
           openw, 9, fn_logfile, /append
           printf, 9,msgr & printf, 9,'Skipping invalid ' + guitit + ' input file.'
           close, 9
           GOTO, skip_batch_mspaCI  ;; invalid CI input
         ENDIF
         IF nr_nodes EQ 0 THEN BEGIN
           msgr = 'Network without nodes.'
           openw, 9, fn_logfile, /append
           printf, 9, msgr & printf, 9,'Skipping invalid ' + guitit + ' input file.'
           close, 9
           GOTO, skip_batch_mspaCI  ;; invalid CI input
         ENDIF
         
         lbl_comp = label_region(image0, / all, / ulong) & nr_comp = max(lbl_comp)
         
         ;; set area of links in components to zero and get area by component
         h_comp_area = histogram(lbl_comp * (image0 NE 2b), / l64)
         ;; PCnum:= overall connectivity. Sum of [ (core-areas per component)^2 ]
         pcnum = total(h_comp_area(1: * )^2, / double)
         nw_hnw = histogram(lbl_comp, / l64) ;; area of components
         mxn = strtrim(n_elements(nw_hnw) - 1, 2) & nw_hnw = 0 & nw_mxinw = long(mxn)

        
         ;; detect 8-connected neighboring different objects by looking in the
         ;; 8-con neighborhood of each bridge for unique core IDs
         ;; meaning: each bridge connects to which core IDs?
         se8 = replicate(1, 3, 3) ;; sel for 8-conn

         time0 = systime( / sec)
         ;; dilate core into bridges to retrieve the edges of bridges
         tmp = dilate(lbl_nodes, se8, / gray, / ulong) * (lbl_links GT 0)
         ;; the bridgeedge coordinate in lbl_bridge is the label of the bridge
         ;; se8 on this coordinate contains the core it connects to
         qb = where(tmp GT 0, ct_b, /l64) & fn_tmp = info.dir_tmp + 'cs22_tmp.txt'
         openw, 1, fn_tmp
         FOR idx = 0l, ct_b - 1 DO BEGIN
           bridge = lbl_links(qb(idx)) + nr_nodes
           xy = array_indices(tmp, qb(idx))
           vals = lbl_nodes[xy(0) - 1:xy(0) + 1, xy(1) - 1:xy(1) + 1]
           uvals = vals[uniq(vals, sort(vals))] & uvals = uvals[1: * ]
           FOR i = 0l, n_elements(uvals) - 1 DO printf, 1, bridge, uvals(i)
         ENDFOR
         close, 1 &  tmp = 0
         
         ;; filter out duplicates
         res = lonarr(2, file_lines(fn_tmp))
         openr, 1, fn_tmp & readf, 1, res & close, 1 & file_delete, fn_tmp, / quiet
         openw, 1, fn_tmp
         FOR idx = 1l, nr_links DO BEGIN
           id = idx + nr_nodes & q = where(res(0, * ) EQ id, ct, /l64)
           IF ct GT 0 THEN BEGIN
             vals = res(1, q) & uvals = vals[uniq(vals, sort(vals))]
             FOR bb = 0l, n_elements(uvals) - 1 DO $
               printf, 1, id - nr_nodes, uvals(bb)
           ENDIF
         ENDFOR
         close, 1
         
         ;; links and their nodes
         linknodes = lonarr(2, file_lines(fn_tmp))
         openr, 1, fn_tmp & readf, 1, linknodes & close, 1
         file_delete, fn_tmp, / quiet
         importance = image0 * 0.0
         
         FOR idc = 1l, nr_comp DO BEGIN  ;; loop over components
           ;;=============================================
           ;; properties of component sub-arrays
           ;;=============================================
           qc = where(lbl_comp EQ idc) ;; component pixels
           x = where(histogram(lbl_links(qc)) GT 0, ct)
           ;; skip calculation for component with no links
           IF ct EQ 1 THEN GOTO, skipit2_batnl
           lids = x[1: * ] ;; the link and node IDs of this component
           x = where(histogram(lbl_nodes(qc)) GT 0) & nids = x[1: * ]

           ;; setup connection table
           n_nids = n_elements(nids) & n_lids = n_elements(lids)
           ctab = replicate(0l, n_nids, n_nids)

           FOR ilin = 0l, n_lids - 1 DO BEGIN
             ;; this link connects these nodes
             qn = where(linknodes(0, * ) EQ lids(ilin), ctn)
             nodes = reform(linknodes(1, qn))
             ;; find the seed node
             x = where(nids EQ nodes(0)) & x = x[0]
             ;; get the connected node array indices
             FOR iy = 1l, ctn - 1 DO BEGIN
               y = where(nids EQ nodes(iy)) & y = y[0]
               ctab(x, y) = lids(ilin)
             ENDFOR
           ENDFOR
           ;; the full matrix is the original + transposed:
           ctab = transpose(ctab) + ctab

           ;; calculate only those nodes connecting to more than one other node
           x = where(total(ctab GT 0, 1) gt 1.5, ct, complement = y)
           skipnodes = 0
           IF ct EQ 0 THEN skipnodes = 1 ELSE nidsc = nids(x)

           ;; sub-arrays of the component
           ww = array_indices(lbl_comp, qc)
           x1 = min(ww(0, * ), max = x2) & y1 = min(ww(1, * ), max = y2)
           x1 = x1 - 1 & x2 = x2 + 1 & y1 = y1 - 1 & y2 = y2 + 1
           maskcomp =  (lbl_comp[x1:x2, y1:y2] EQ idc)
           hh = h_comp_area & hh_idc = hh(idc) & hh(idc)= 0
           hh = total(hh(1: * )^2, / double)
           subimportance = importance[x1:x2, y1:y2]  ;; define subimportance area
           subim = image0[x1:x2, y1:y2] & subl0 = subim NE 2b & subim = subim * maskcomp
           sub = lbl_links[x1:x2, y1:y2]

           ;; importance of links
           FOR il = 0l, n_elements(lids) - 1 DO BEGIN
             tmp = subim & q = where(sub EQ lids(il)) & tmp(q) = 0b
             hca = histogram(label_region(tmp, / all, / ulong) * subl0, / l64)
             pcnew = total(hca(1: * )^2, / double) + hh
             imp = (pcnum - pcnew) / pcnum * 100.0 & subimportance(q) = imp
           ENDFOR

           ;; importance of nodes
           IF skipnodes EQ 1 THEN GOTO, skipit_batnl
           sub = lbl_nodes[x1:x2, y1:y2] ;* maskcomp
           tmp2 = maskcomp * subl0
           FOR il = 0l, n_elements(nidsc) - 1 DO BEGIN
             tmp = subim & q = where(sub EQ nidsc(il)) & tmp(q) = 0b
             hca = histogram(label_region(tmp, / all, / ulong) * subl0, / l64)
             pcnew1 = total(hca(1: * )^2, / double)
             ;; set removed node area to zero: set node to link
             tmp = tmp2 & tmp(q) = 0b & hca = histogram(tmp, / l64)
             pcnew2 = total(hca(1: * )^2, / double)
             imp = (pcnew2 - pcnew1) / pcnum * 100.0 & subimportance(q) = - imp  
           ENDFOR
           skipit_batnl:
           importance[x1:x2, y1:y2] = importance[x1:x2, y1:y2] + $
             subimportance * maskcomp
           skipit2_batnl:
         ENDFOR ;; end of loop over components
         
         ;; display the top 1,5, 10% relative importance for
         ;; bridge (red: 192, 194, 195 byte) and core (green: 208, 210, 211 byte)
         mx_bridge = max(importance) & mx_core = min(importance)

         ;; 1% [192b, 208b]
         htop = mx_bridge * 0.99 & qb01 = where(importance GE htop)
         htop = mx_core * 0.99 & qc01 = where(importance LE htop)

         ;; 5% [194b, 210b]
         htop = mx_bridge * 0.95 & qb05 = where(importance GE htop)
         htop = mx_core * 0.95 & qc05 = where(importance LE htop)

         ;; 10% [195b, 211b]
         htop = mx_bridge * 0.9 & qb10 =  where(importance GE htop)
         htop = mx_core * 0.9 & qc10 = where(importance LE htop)

         ;; build the image for the display
         ;; core in water color and bridges in black:
         ;; load the colors-on table
         restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b

         ;; go back to original size
         image0 = lbl_links - long64(lbl_nodes) ;; the node IDs
         cs22_nodes = image0[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1]

         image0 = (lbl_nodes GT 0) * 176b + (lbl_links GT 0) * 103b
         ;; the hot 10, 5, 1% bridges
         image0(qb10) = 195b & image0(qb05) = 194b & image0(qb01) = 192b
         image0(qc10) = 211b & image0(qc05) = 210b & image0(qc01) = 208b
         image0 = temporary(image0[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1])

         cs22_conn = temporary(importance[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1])
         lbl_comp = lbl_comp[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1]
         lbl_links = lbl_links[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1]
         lbl_nodes = lbl_nodes[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1]

         add_title = ': Connectivity Importance(Node_max=' + strtrim(abs(mx_core), 2) + $
           ', Link_max=' + strtrim(mx_bridge, 2) + ')'
           
         ;; write out the results: 4 files: cs (viewport), cs_nodes, cs_conn, cs_stat
         ;; 1) cs (viewport) = image0
         qq = strpos(fn_outbase,mspaext) & if qq lt 0 then fn_outbase = fn_outbase + mspaext
         fn = dir_batch + fn_outbase + '_cs.tif'
         write_tiff, fn, rotate(image0,7), red = r, green = g, blue = b, geotiff = geotiffz, compression = 1
         
         ;; 2) + 3) cs_nodes, cs_conn
         imfilebase = dir_batch + fn_outbase + '_cs'
         suffix = ['_ids.tif', '_conn.tif']
         FOR isuf = 0, 1 DO BEGIN
           IF isuf EQ 0 THEN image0 = cs22_nodes ELSE image0 = cs22_conn
           image0 = rotate(image0, 7) ;; needed?
           IF isuf EQ 0 THEN write_tiff, imfilebase + suffix(isuf), image0, /long, /signed, $
               geotiff = geotiffz, compression = 1 ELSE write_tiff, $
               imfilebase + suffix(isuf), image0, /float, geotiff = geotiffz, compression = 1
         ENDFOR
         
         ;; 4) cs.txt
         fname = imfilebase + '.txt'
         openw, 1, fname
         printf, 1, fn_outbase + add_title
         printf, 1, '(NOTE: node ID & importance in the actual image data are'
         printf, 1, 'NEGATIVE to distinguish them from link ID & importance)'
         printf, 1, '===================================================================='
         xx = strcompress(nw_mxinw) + ' /' + strcompress(nr_links) + $
           ' /' + strcompress(nr_nodes)
         printf, 1, 'Total number of components/links/nodes: ' + xx
         printf, 1, '===================================================================='

         FOR idc = 1l, nw_mxinw DO BEGIN ;; loop over components
           qnw = where(lbl_comp EQ idc) ;; component pixels
           lids = lbl_links(qnw) & hlids = histogram(lids)
           lids_ids = where(hlids GT 0) & lx = n_elements(lids_ids)
           nids = lbl_nodes(qnw) & hnids = histogram(nids)
           nids_ids = where(hnids GT 0) & nx = n_elements(nids_ids)
           IF lx EQ 1 THEN nr_lids = 1 ELSE nr_lids = lx - 1
           IF total(lids) EQ 0.0 THEN nr_lids = 0  ;; reset for no links
           IF nx EQ 1 THEN nr_nids = 1 ELSE nr_nids = nx - 1
           IF total(nids) EQ 0.0 THEN nr_nids = 0
           q = where(lids GT 0, alids) & q = where(nids GT 0, anids)
           ;connids = cs22_conn[qnw]
           printf, 1, '                   Component: ' + strcompress(idc)
           printf, 1, '================================================================'
           printf, 1, '# of links/nodes: ' + strcompress(nr_lids) + $
             ' /' + strcompress(nr_nids)
           printf, 1, 'Pixels of component/links/nodes: ', + $
             strcompress(n_elements(qnw)) + ' /' + $
             strcompress(alids) + ' /' + strcompress(anids)

           IF nr_lids GT 0 THEN BEGIN
             printf, 1, '================================================================'
             printf, 1, '     Link ID        pixels          dPC      normalized.importance'
             printf, 1, '----------------------------------------------------------------'
             FOR i = 1l, nr_lids DO BEGIN
               IF nr_lids EQ 1 THEN BEGIN
                 idx = max(lids) & q = where(lids EQ idx, aa)
               ENDIF ELSE BEGIN
                 idx = lids_ids[i] & aa = hlids(idx)
               ENDELSE
               imp = (cs22_conn(where(lbl_links EQ idx)))[0]
               impp =  imp / mx_bridge * 100.0
               printf, 1, idx, aa,'    ', imp,'      ', impp
             ENDFOR
           ENDIF
           IF nr_nids GT 0 THEN BEGIN
             printf, 1, '================================================================'
             printf, 1, '     Node ID        pixels          dPC      normalized.importance'
             printf, 1, '----------------------------------------------------------------'
             FOR i = 1l, nr_nids DO BEGIN
               IF nr_nids EQ 1 THEN BEGIN
                 idx = max(nids) & q = where(nids EQ idx, aa)
               ENDIF ELSE BEGIN
                 idx = nids_ids[i] & aa = hnids(idx)
               ENDELSE
               imp = abs((cs22_conn(where(lbl_nodes EQ idx)))[0])
               impp = imp / abs(mx_core) * 100.0
               idx=long(idx)
               printf, 1, -idx, aa,'    ', imp,'      ', impp
             ENDFOR
           ENDIF
           printf, 1, '================================================================'
         ENDFOR ;; component loop
         close, 1
       ENDELSE
       ;;==========================================================================================
       
       openw, 9, fn_logfile, /append
       printf, 9, guitit + ' comp.time [sec]: ', systime( / sec) - time0
       close, 9
       okfile = okfile + 1
       skip_batch_mspaCI:
       stepn = (fidx + 1.0)/nr_im_files * 100.0
       progressBar -> Update, stepn
       openw, 9, fn_logfile, /append
       printf, 9, '==============================================='
       close, 9
     ;; end of file loop
     ENDFOR
     progressBar -> Destroy
     Obj_Destroy, progressBar

     ;; reset the colortable to the settings before the batch processing
     tvlct, rini, gini, bini
     proct = systime( / sec) - time00
     IF proct GT 3600.0 THEN BEGIN
       proct2 = proct - ulong(proct/3600)*3600
       proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDIF ELSE BEGIN
       proctstr = strtrim(ulong(proct/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDELSE
     IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
     openw, 9, fn_logfile, /append
     printf, 9, guitit + ' batch total comp.time: ', proctstr
     printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
     printf, 9, '==============================================='
     close, 9


     IF verbose EQ 1 AND msgr NE "" THEN res = dialog_message(msgr, / information)
     msg = guitit + ' batch processing finished.' + string(10b) + $
       'Total computation time: ' + proctstr + string(10b) + $
       'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
       'More information can be found in the logfile: ' + string(10b) + fn_logfile
     res = dialog_message(msg, / information)
     
   GOTO, fin
 END
   
   
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;                              M S P A    B A T C H
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   'batch_mspa':  BEGIN
      tit = 'Select (Geo-)Tif-files'
      im_file = dialog_pickfile(Title = tit, get_path = path2file, $
        path = info.dir_data, default_extension = 'tif', / fix_filter, $
        / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
      IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
      
      ;; test that the directory of the selected files has no sub-directories
      ;; this will also ensure no output file is opened in excel or thelike
      pushd, path2file
      list = file_search() & nl = n_elements(list) & nr_dir = 0
      for idx = 0, nl-1 do begin
        q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
      endfor
      IF nr_dir GT 0 THEN BEGIN
        msg = 'The directory of your Batch MSPA input files contains sub-directories.'  +  string(10b) +  string(10b) + $
          'Please set up a new directory having Batch MSPA input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF
      popd
      
      ;; test that we can write into the parent directory or if it exists already
      batch_type = 'batch_MSPA'
      dd = file_dirname(im_file[0], / mark_directory)
      dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
      res = file_test(dir_batch, /directory, /write)
      if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
        res = dialog_message(msg,/question)
        If res eq 'No' then goto, fin
        ;; empty it
        pushd, dir_batch
        list = file_search() & nl = n_elements(list)
        if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
        popd
      endif else begin ;; does not exist yet, create it
        file_mkdir, dir_batch
      endelse


      ;;========================================================================
      ;; reset the front image and block any events
      ;;========================================================================
      title = 'MSPA Batch Processing'
      goto, resetfront

      backto_batch_mspa:

      ;;========================================================================
      ;; ok, the files are selected, get the  MSPA-params
      ;;========================================================================
      cancel = ptr_new(1b) & ms1 = ptr_new('8') & ms2 = ptr_new('1')
      ms3 = ptr_new('on') & ms4 = ptr_new('on') & ms5 = ptr_new('no')
      get_MSPAparams, $
       cancel = cancel, Group_Leader = event.top, title = title, $
        / msstats, ms1 = ms1, ms2 = ms2, ms3 = ms3, ms4 = ms4, ms5 = ms5

      ;; check if cancel was selected then do nothing else start
      ;; batch processing with the selected settings
      IF * cancel EQ 0b THEN BEGIN ;; get the values
         c_FGconn = * ms1
         c_size =  * ms2 
         IF * ms3 EQ 'on' THEN BEGIN
            c_trans = '1' & ttrans = 1b
            restore, info.dir_guidossub + 'mspacolorston.sav'
         ENDIF ELSE BEGIN
            c_trans = '0' & ttrans = 0b
            restore, info.dir_guidossub + 'mspacolorstoff.sav'
         ENDELSE
         tvlct, r, g, b
         IF * ms4 EQ 'on' THEN BEGIN
            c_intext = '1' & tintext = 1b
         ENDIF ELSE BEGIN
          c_intext = '0' & tintext = 0b
         ENDELSE
         ;; for the statistics
         IF c_FGconn EQ '8' THEN fconn = 1b ELSE fconn = 0b ;; value for foreground
         statsout = * ms5 EQ 'yes'
         ;; free and delete the temporary pointers
         ptr_free, cancel & cancel = 0b & ptr_free, ms1 & ms1 = 0b
         ptr_free, ms2 & ms2 = 0b & ptr_free, ms3 & ms3 = 0b
         ptr_free, ms4 & ms4 = 0b
         ptr_free, ms5 & ms5 = 0b
      ENDIF ELSE BEGIN  ;; cancel was selected
         ptr_free, cancel & cancel = 0b
         ptr_free, ms1 & ms1 = 0b
         ptr_free, ms2 & ms2 = 0b
         ptr_free, ms3 & ms3 = 0b
         ptr_free, ms4 & ms4 = 0b
         ptr_free, ms5 & ms5 = 0b
         GOTO, fin
      ENDELSE
      ;;========================================================================
      ;; validate and process the images in a loop
      desc = 'GTB_MSPA, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
      ;; open logfile
      fn_logfile = dir_batch + batch_type + '.log'
      nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
      openw, 9, fn_logfile
      printf, 9, 'MSPA batch processing logfile: ', systime()
      printf, 9, 'Number of files to be processed: ', nr_im_files
      printf, 9, '==============================================='
      close, 9
      msg = 'Processing selected images for MSPA, please wait...'
      progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
      progressBar -> Start

      FOR fidx = 0, nr_im_files - 1 DO BEGIN
         counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
         
         IF progressBar -> CheckCancel() THEN BEGIN
           res = Dialog_Message('Batch-processing cancelled by user.')
           openw, 9, fn_logfile, /append
           printf, 9, 'Batch-processing cancelled by user.'
           close, 9
           progressBar -> Destroy
           Obj_Destroy, progressBar
           tvlct, rini, gini, bini
           GOTO, fin                    
         ENDIF       
         
         ;; validate the input, if not skip it without message
         input = im_file(fidx)
         res = strpos(input,' ') ge 0
         IF res EQ 1 THEN BEGIN
           openw, 9, fn_logfile, /append
           printf, 9, ' '
           printf, 9, '==============   ' + counter + '   =============='
           printf, 9, 'Skipping invalid MSPA input (empty space in directory path or input filename): ', input
           close, 9
           GOTO, skip_batch_mspa  ;; invalid input
         ENDIF  
         
         type = '' & res = query_image(input, type=type)
         IF type NE 'TIFF' THEN BEGIN
           openw, 9, fn_logfile, /append
           printf, 9, ' '
           printf, 9, '==============   ' + counter + '   =============='
           printf, 9, 'Skipping invalid MSPA input (not a TIFF image): ', input
           close, 9
           GOTO, skip_batch_mspa  ;; invalid input
         ENDIF
             
         res = query_tiff(input, tiffinfo, geotiff = geotiffinfo)
         ss = tiffinfo.dimensions & ssct = n_elements(ss) & ss3 = ulong64(ss[0]) * ss[1]  / (1024.0^2)

         IF res EQ 0 or ssct ne 2 THEN BEGIN ;;invalid file, wrong dimensions, image too big  
           openw, 9, fn_logfile, /append
           printf, 9, ' '
           printf, 9, '==============   ' + counter + '   =============='
           printf, 9, 'Skipping invalid MSPA input file: ', input
           close, 9
           GOTO, skip_batch_mspa  ;; invalid input
         ENDIF

         IF ss3 GT info.immaxsize THEN BEGIN ;;invalid file , wrong dimensions, image too big
           openw, 9, fn_logfile, /append
           printf, 9, ' '
           printf, 9, '==============   ' + counter + '   =============='
           printf, 9, 'Skipping invalid MSPA input file (image too big): ', input
           close, 9
           GOTO, skip_batch_mspa  ;; invalid input
         ENDIF

         image0 = read_tiff(input)  ;; read and check it
         MSPA_Compliance, input, image0, info.immaxsize, 0, result
         IF result EQ 0 THEN BEGIN
            openw, 9, fn_logfile, /append
            printf, 9, ' '
            printf, 9, '==============   ' + counter + '   =============='
            printf, 9, 'Skipping invalid MSPA input file: ', input
            close, 9
            GOTO, skip_batch_mspa  ;; invalid input
         ENDIF

         ;; now all is ok for processing
         time0 = systime( / sec)
         tmp_in = info.dir_tmp + 'inputmorph.tif'
         tmp_out = info.dir_tmp + 'outputmorph.tif'
         write_tiff, tmp_in, temporary(image0), compression = 1

         ;; execute the segmentation
         IF info.my_os EQ 'windows' THEN BEGIN
            pushd, info.dir_guidossub
            cmd = 'mspa.exe -graphfg ' + c_FGconn + $
              ' -eew ' + c_size + ' -internal ' + c_intext + $
              ' -disk -transition ' + c_trans + $
              ' -i mspatmp\inputmorph.tif' + $
              ' -o outputmorph.tif -odir mspatmp\'
            time0 = systime( / sec)
            widget_control, / hourglass
            spawn, cmd, log, / hide
            popd
         ENDIF ELSE BEGIN
            pushd, info.dir_tmp
            IF info.my_os EQ 'linux' THEN $
             mspa_os = 'mspa_lin' ELSE mspa_os = 'mspa_mac'
            cmd = info.dir_guidossub + mspa_os + ' -graphfg ' + c_FGconn + $
                  ' -eew ' + c_size + ' -internal ' + c_intext + $
                  ' -disk -transition ' + c_trans + $
                  ' -i inputmorph.tif -o outputmorph.tif -odir ./'
            time0 = systime( / sec)
            widget_control, / hourglass
            spawn, cmd, log
            popd
         ENDELSE
         
         ;; write the final result 
         res = file_basename(input, '.tif')
         fn_out = dir_batch + res + '_' + c_FGconn + '_' + c_size + $
           '_' + c_trans + '_' + c_intext + '.tif'

         ;; add the statistics if they were set in the GUI
         IF statsout EQ 1b THEN BEGIN
            image0 = read_tiff(info.dir_tmp + 'outputmorph.tif')
            simplestats, image0, fconn, ttrans, tintext, info.do_label_groups_id, st
            fn_out_stats = dir_batch + res + '_' + c_FGconn + '_' + c_size + $
                           '_' + c_trans + '_' + c_intext + '.txt'            
            row_lab = $
              ['CORE(s) [green]', 'CORE(m) [green]', 'CORE(l) [green]', 'ISLET [brown]', 'PERFORATION [blue]', $
              'EDGE [black]', 'LOOP [yellow]', 'BRIDGE [red]', 'BRANCH [orange]', 'Background [grey]', $
              'Missing [white]', 'Opening [grey]', 'Core-Opening [darkgrey]', 'Border-Opening [grey]'] 
            
            ;; calculate FG and iFG for output statistics
            ;; fg_area = image area - BG - missing 
            fg_area = ulong64(ss[0])*ss[1] - ulong64((strsplit(st(1,9),'/',/extract))[1]) - ulong64((strsplit(st(1,10),'/',/extract))[1])
            if tintext eq 0b then xx = 0 else xx = ulong64((strsplit(st(1,11),'/',/extract))[1])
            iFG_area = fg_area + xx
            ;; convert to string
            fg_area = strtrim(fg_area,2) & iFG_area = strtrim(iFG_area,2)
              
            openw, 1, fn_out_stats
            printf, 1, 'MSPA results using: ' 
            printf, 1, res + ' (MSPA: ' + c_FGconn + '_' + c_size + '_' + c_trans + '_' + $
              c_intext + ', FG_area: ' + fg_area + ', iFG_area: ' + iFG_area + ')'
            printf, 1, ' '
            ;; write a tile line
            printf, 1, '   MSPA-class [color]:  FG/data pixels [%]  #/BGarea'
            printf, 1, '============================================================'
            ;; write the statistics
            FOR is = 0, n_elements(row_lab) - 1 DO $
                      printf, 1, format = '(a24,a15,a5,a)', row_lab(is) + ':  ', st(0, is), '', st(1, is)                              
            close, 1
         ENDIF
         
         ;;get the result and clean dir_tmp
         pushd, info.dir_tmp
           image0 = read_tiff('outputmorph.tif')
           file_delete, 'inputmorph.tif', 'outputmorph.tif', / quiet
         popd

         ;; add the MSPA SW remark and the geotiff info if available
         m1=strtrim(info.mspa_param1_id * 4 + 4,2)
         m2=info.mspa_size_current
         m3=strtrim(fix(info.mspa_param3_id),2)
         m4=strtrim(fix(info.mspa_param4_id),2)
         zz=' '+m1+'_'+m2+'_'+m3+'_'+m4
         desc1 = desc + zz
         IF (size(geotiffinfo))[0] gt 0 THEN BEGIN
           write_tiff, fn_out, image0, geotiff = geotiffinfo, description = desc1, $
             compression = 1, red = r, green = g, blue = b
         ENDIF ELSE BEGIN
           write_tiff, fn_out, image0, description = desc1, compression = 1, red = r, green = g, blue = b
         ENDELSE         
         image0 = 0

         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'File: ' + input
         printf, 9, 'MSPA comp.time [sec]: ', systime( / sec) - time0
         close, 9
         okfile = okfile + 1

         skip_batch_mspa:
         stepn = (fidx + 1.0)/nr_im_files * 100.0 
         progressBar -> Update, stepn         
      ENDFOR
      progressBar -> Destroy
      Obj_Destroy, progressBar
      
      ;; inform that batch is done
      proct = systime( / sec) - time00
      IF proct GT 3600.0 THEN BEGIN
        proct2 = proct - ulong(proct/3600)*3600
        proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
          ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
      ENDIF ELSE BEGIN
        proctstr = strtrim(ulong(proct/60.),2) + $
          ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
      ENDELSE
      IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
      openw, 9, fn_logfile, /append
      printf, 9, ''
      printf, 9, '==============================================='
      printf, 9, 'MSPA Batch Processing total comp.time: ', proctstr
      printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
      printf, 9, '==============================================='
      close, 9

      msg = 'MSPA Batch Processing finished.' + string(10b) + $
        'Total computation time: ' + proctstr + string(10b) + $
        'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
        'More information can be found in the logfile: ' + string(10b) + fn_logfile
      res = dialog_message(msg, / information)

      ;; reset the colortable to the settings before the batch processing
      tvlct, rini, gini, bini
      GOTO, fin
   END

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;                      M S P A T I L E
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   'mspatile':  BEGIN ;; Purpose: automatic tiling for MSPA
      
      msg = 'MSPA Tiling is a less than ideal solution, it will:' + string(10b) + $
       '1) cut the entire image into subtiles buffered by 2000 pixels,' + string(10b) + $
       '2) process the buffered subtiles for MSPA,' + string(10b) + $
       '3) reassemble the subtiles to the final result.' + string(10b) + $
       'This procedure is time-consuming and NOT guaranteed to provide correct results.'+ string(10b) + string(10b) + $
       'Instead, please ALWAYS use GWB (Help->GTB Online->GWB) for MSPA processing of large images!' + string(10b)
      res = dialog_message(msg, / information, title = 'IMPORTANT: use GWB for MSPA processing of large images')

      tit = 'Select large (Geo-)Tif-file'
      fname = $
        dialog_pickfile(Title = tit, get_path = path2file, $
                        path = info.dir_data, $
                        default_extension = 'tif', / fix_filter, $
                        / must_exist, filter = ['*.tif', '*.tiff','*.TIF', '*.TIFF'])
      IF fname EQ '' THEN GOTO, fin ;; 'cancel' selected
      type = '' & res = query_image(fname, type=type)
      IF type NE 'TIFF' THEN BEGIN
        msg = 'Input is not a TIFF image.' + string(10b) + $
            'Please load MSPA-compliant GeoTiff-image.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information) & GOTO, fin
      ENDIF

      ;;========================================================================
      ;; reset the front image and block any events
      ;;========================================================================
      title = 'MSPA Tiling'
      goto, resetfront

      backto_mspatile:

      ;;========================================================================
      ;; ok, now let's start
      ;;========================================================================
      dir_dat = file_dirname(fname, / mark)
      qq = file_info(dir_dat)
      IF qq.write NE 1b THEN BEGIN
         msg = 'No write access in the directory: ' + string(10b) + $
               dir_dat  + string(10b) + 'Returning...'
         res = dialog_message(msg, / information) & GOTO, fin
      ENDIF

      ;;====================================================================
      ;; check for MSPA compliant input image
      ;;====================================================================
      ;; check if input is an image format
      res = query_tiff(fname, inpinfo, geotiff = geotiffx)
      IF res EQ 0 THEN BEGIN ;; or IDL/ENVI file
         msg = 'Input file could not be read.' + string(10b) + $
               'Please load MSPA-compliant GeoTiff-image.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information) & GOTO, fin
      ENDIF
      ;; check for single image in file
      ;;===========================
      IF inpinfo.num_images GT 1 THEN BEGIN
         msg = 'Input file has more than 1 image.' + string(10b) + $
               'Please load MSPA-compliant GeoTiff-image.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information) & GOTO, fin
      ENDIF
      ;; check for single channel image
      ;;===========================
      IF inpinfo.channels NE 1 THEN BEGIN
         msg = 'Input image has more than 1 layer.' + string(10b) + $
               'Please load MSPA-compliant GeoTiff-image.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information) & GOTO, fin
      ENDIF
      ;; check for byte array
      ;;===========================
      IF inpinfo.pixel_type NE 1 THEN BEGIN
         msg = 'Input image is not of type Byte.' + string(10b) + $
               'Please load MSPA-compliant GeoTiff-image.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information) & GOTO, fin
      ENDIF
      ;; check for type tiff
      ;;===========================
      IF inpinfo.type NE 'TIFF' THEN BEGIN
         msg = 'Input image is not of type TIFF.' + string(10b) + $
               'Please load MSPA-compliant GeoTiff-image.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information) & GOTO, fin
      ENDIF
      ;; check for type GeoTiff
      ;;===========================
      IF (size(geotiffx))[0] EQ 0 THEN BEGIN
         msg = 'Input image is not of type GeoTiff.' + string(10b) + $
               'Please load MSPA-compliant GeoTiff-image.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information) & GOTO, fin
      ENDIF
      ;; check for minimum image size: > info.immaxsize
      ;;===========================
      imsize = inpinfo.dimensions[0] / (1024.0^2) * inpinfo.dimensions[1]
      IF imsize LE (info.immaxsize) THEN BEGIN
         msg = 'Input file can be processed via ' + string(10b) + $
               'File -> Read Image -> GeoTiff' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information) & GOTO, fin
      ENDIF
      ;; check for GeoTiff and for minimum/maximum value
      ;;=================================
      IF info.my_os EQ 'windows' THEN BEGIN
         cmd = 'cd "' + info.dir_fwtools + $
               '" & setfw.bat & gdalinfo -noct -nomd -mm "' + $
               fname + '"'
      ENDIF ELSE BEGIN
         if strlen(info.sysgdal) gt 0 then cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct -nomd -mm "' + fname + '"' else $
          cmd = info.dir_fwtools + 'gdalinfo -noct -nomd -mm "' + fname + '"'
      ENDELSE

      ;; show window: verify input image
      msg = 'Verifying MSPA compliance. Please wait...'
      progressBar = Obj_New("SHOWPROGRESS", message = msg)
      progressBar -> Start
      
      IF info.my_os EQ 'windows' THEN spawn, cmd, log, / hide ELSE spawn, cmd, log
      ftype = strmid(log[0], strpos(log[0], ': ') + 2, 13)
      IF ftype NE 'GTiff/GeoTIFF' THEN BEGIN
         msg = 'This image is not a GeoTiff file.' + string(10b) + $
               'Please load MSPA-compliant GeoTiff-image.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         progressBar -> Destroy
         Obj_Destroy, progressBar
         GOTO, fin
      ENDIF

      ;; check for MSPA compliant image values
      ;;===========================
      ss = 'Computed Min/Max=' & res = where(strpos(log, ss) GT 0) & res = log(res[0])
      mm = strmid(res, strpos(res, ss)) & mm = strsplit(mm, '=', / extract)
      mm = mm[1] &  mm = strsplit(mm, ',', / extract)
      mii = byte(fix(mm(0))) & mxx = byte(fix(mm(1)))
      IF mxx GT 2b THEN BEGIN
         msg = 'Image maximum is larger than 2 BYTE.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         progressBar -> Destroy
         Obj_Destroy, progressBar
         GOTO, fin
      ENDIF ELSE IF mxx LT 2b THEN BEGIN
         msg = 'Image has no foreground (2 BYTE).' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         progressBar -> Destroy
         Obj_Destroy, progressBar
         GOTO, fin
      ENDIF
      IF mii GT 1b THEN BEGIN
         msg = 'Image has no background (1 BYTE).' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         progressBar -> Destroy
         Obj_Destroy, progressBar
         GOTO, fin
      ENDIF
      progressBar -> Destroy
      Obj_Destroy, progressBar

      ;;====================================================================
      ;; now we are MSPA compliant!
      ;;====================================================================
      ;; get the current MSPA-params
      cancel = ptr_new(1b) & ms1 = ptr_new('8') & ms2 = ptr_new('1')
      ms3 = ptr_new('on') & ms4 = ptr_new('on') & ms5 = ptr_new('no')
      get_MSPAparams, $
       cancel = cancel, Group_Leader = event.top, title = 'MSPA Tiling', $
       ms1 = ms1, ms2 = ms2, ms3 = ms3, ms4 = ms4, ms5 = ms5

      ;; check if cancel was selected then do nothing else start
      ;; batch processing with the selected settings
      IF * cancel EQ 0b THEN BEGIN ;; get the values
         c_FGconn = * ms1
         c_size = * ms2
         IF * ms3 EQ 'on' THEN BEGIN
            c_trans = '1' & ttrans = 1b
            restore, info.dir_guidossub + 'mspacolorston.sav'
         ENDIF ELSE BEGIN
            c_trans = '0' & ttrans = 0b
            restore, info.dir_guidossub + 'mspacolorstoff.sav'
         ENDELSE
         tvlct, r, g, b
         IF * ms4 EQ 'on' THEN c_intext = '1' ELSE c_intext = '0'
         ;; for the statistics
         IF c_FGconn EQ '8' THEN fconn = 1b ELSE fconn = 0b ;; value for foreground
         statsout = * ms5 EQ 'yes'
         ;; free and delete the temporary pointers
         ptr_free, cancel & cancel = 0b & ptr_free, ms1 & ms1  = 0b
         ptr_free, ms2 & ms2 = 0b & ptr_free, ms3 & ms3 = 0b
         ptr_free, ms4 & ms4 = 0b
         ptr_free, ms5 & ms5 = 0b
      ENDIF ELSE BEGIN  ;; cancel was selected
         ptr_free, cancel & cancel = 0b
         ptr_free, ms1 & ms1 = 0b
         ptr_free, ms2 & ms2 = 0b
         ptr_free, ms3 & ms3 = 0b
         ptr_free, ms4 & ms4 = 0b
         ptr_free, ms5 & ms5 = 0b
         GOTO, fin
      ENDELSE

      ;; now we are ready for processing
      time0 = systime( / sec)

      ;;====================================================================
      ;; define gdal commands, overlay, olt-stepsize
      ;;====================================================================
      ;; gdal_translate, buildvrt
      IF info.my_os EQ 'windows' THEN BEGIN
         gtrans = info.windrive + ' & cd "' + info.dir_fwtools + '" & setfw.bat & ' + 'cd "' + $
          info.dir_tmp + '" & gdal_translate -co "COMPRESS=LZW" -srcwin '
         gbuildvrt = info.windrive + ' & cd "' + info.dir_fwtools + '" & setfw.bat & ' + 'cd "' + $
          info.dir_tmp + '" & gdalbuildvrt -input_file_list '
      ENDIF ELSE BEGIN ;; linux, osx
         if strlen(info.sysgdal) gt 0 then gtrans = 'unset LD_LIBRARY_PATH; gdal_translate -co "COMPRESS=LZW" -srcwin ' else $
          gtrans = info.dir_fwtools + 'gdal_translate -co "COMPRESS=LZW" -srcwin '
         if strlen(info.sysgdal) gt 0 then gbuildvrt = 'unset LD_LIBRARY_PATH; gdalbuildvrt ' else $
          gbuildvrt = info.dir_fwtools + 'gdalbuildvrt '
      ENDELSE      
          
      ;;[-srcwin xoff yoff xsize ysize] and yoffset is counted from top
      ;; the entire image is xsize, ysize
      ;; sub-tile into tiles of 10000x10000 with an overlay of 2000 so the
      ;; final adjacent tiles will be of size 8000x8000
      ;; - stepx/y: tilesize including the overlay area
      ;; - dx/y: tilesize without overlay (8000x8000)
      ;; - nrtx/y = number of tiles in x and y

      ;; dimensions in x and y
      xtot = inpinfo.dimensions[0] & ytot = inpinfo.dimensions[1]
      overlay = 2000l  ;; shift of common overlay

      ;; settings for the olts and the final tiles to merge back
      stepx = 6500 ;; for MS-Windows
      IF info.my_os EQ 'linux' THEN stepx = 9500
      IF info.my_os EQ 'apple' THEN stepx = 8500
      stepy = stepx
      dx = stepx - overlay & dy = dx ;; actual stepsize of olts
      ;; border to remove from overlays
      border = overlay / 2 & sborder = ' ' + strtrim(border, 2)
      ;; dimension of merger tiles
      mex = ' ' + strtrim(stepx - overlay, 2) & mey = mex

      ;; mspa parameters
      suffix = '_' + strtrim(c_FGconn, 2) + '_' + strtrim(c_size, 2) + '_' + $
               strtrim(c_trans, 2) + '_' + strtrim(c_intext, 2) + '.tif'
      ;;=================================================================
      ;; Part 1: automatic loop of cutting overlays for MSPA
      ;;=================================================================
      ;; inform
      msg = '1) Cutting buffered sub-tiles. Please wait...'
      progressBar = Obj_New("SHOWPROGRESS", message = msg)
      progressBar -> Start

      ;; start with an empty tmp folder
      pushd, info.dir_tmp
      list = file_search() & nl = n_elements(list)
      IF list[0] NE '' THEN FOR i = 0, nl - 1 DO file_delete, list[i], / allow_nonexistent, / quiet, / recursive

      iy = - 1 & lasty = 0
      yloop:
      iy = iy + 1

      ix = - 1
      xloop:
      ix = ix + 1

      ;; start/end points of overlay tile
      xx1 = strtrim(ix * dx) & xx2 = ix * dx + stepx
      yy1 = strtrim(iy * dy) & yy2 = iy * dy + stepy
      ddx = strtrim(stepx) & ddy = strtrim(stepy)
      subt = 'olt_' + strtrim(ix + 1, 2) + '_' + strtrim(iy + 1, 2) + '.tif'

      ;; check for last tiles in Y which is not necessarily full size
      IF yy2 GE ytot THEN BEGIN ;; we are in the last tile in Y
         ddy = strtrim(ytot - yy1) & lasty = 1
      ENDIF

      ;; check for last tile in X which is not necessarily full size
      IF xx2 GE xtot THEN BEGIN ;; we are in the last tile in X
         ddx = strtrim(xtot - xx1)
         cmd = gtrans + xx1 + yy1 + ddx + ddy + ' ' + fname + ' ' + subt
         IF info.my_os EQ 'windows' THEN $
          spawn, cmd, log, / hide ELSE spawn, cmd, log
         IF lasty EQ 0 THEN GOTO, yloop ELSE GOTO, olayend
      ENDIF

      ;; cut the overlays
      cmd = gtrans + xx1 + yy1 + ddx + ddy + ' "' + fname + '" ' + subt
      IF info.my_os EQ 'windows' THEN $
       spawn, cmd, log, / hide ELSE spawn, cmd, log
      GOTO, xloop

      olayend:
      progressBar -> Destroy
      Obj_Destroy, progressBar

      ;; list of tiles in x and y for part 3
      list_oltx = file_search('olt_*_1.tif', count = nr_oltx)
      list_olty = file_search('olt_1_*.tif', count = nr_olty)
      popd ;; back to the roots
      ;;=================================================================
      ;; Part 1 finished: cutting olay tiles
      ;;=================================================================

      part2:
      ;;=================================================================
      ;; Part 2: do mspa
      ;;=================================================================
      ;; get the list of tiles for MSPA processing
      list_olt = $
       file_search(info.dir_tmp + 'olt*.tif', count = nr_olt)


      msg = 'Processing buffered sub-tiles for MSPA, please wait...'
      progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title='MSPA Tiling', /cancel)
      progressBar -> Start

      FOR isub = 0, nr_olt - 1 DO BEGIN      
          IF progressBar -> CheckCancel() THEN BEGIN
            res = Dialog_Message('MSPA-Tiling cancelled by user.')
            progressBar -> Destroy
            Obj_Destroy, progressBar
            tvlct, rini, gini, bini
            GOTO, fin
          ENDIF

         fbase0 = file_basename(list_olt(isub))
         fbase1 = 'out' + strmid(fbase0, 3)

         ;; test if MSPA processing can be skipped
         ;;========================================       
         ;; gdal statistics will not calculate min/max if only nodata is present!   
         ;; since in that case gdalinfo -mm does not work we have to read the image 
         res = read_tiff(list_olt(isub)) & mxx=max(res,min=mii) & res = 0
         
         IF mxx EQ 0b THEN BEGIN
            ;; the entire olt is Nodata [0]
            pushd, info.dir_tmp
            res = query_tiff(fbase0, inpinfo, geotiff = geotiffx)
            imtmp = bytarr(inpinfo.dimensions[0], inpinfo.dimensions[1]) + 129b
            write_tiff, fbase1, imtmp, geotiff = geotiffx, $
                        compression = 1, red = r, green = g, blue = b
            imtmp = 0 & popd & GOTO, skipmsapt
         ENDIF
         
         IF mii EQ 2b THEN BEGIN
            ;; the entire olt is FG [2]
            pushd, info.dir_tmp
            res = query_tiff(fbase0, inpinfo, geotiff = geotiffx)
            imtmp = bytarr(inpinfo.dimensions[0], inpinfo.dimensions[1]) + 17b
            write_tiff, fbase1, imtmp, geotiff = geotiffx, $
                        compression = 1, red = r, green = g, blue = b
            imtmp = 0 & popd & GOTO, skipmsapt
         ENDIF

         IF mxx EQ 1b AND mii LE 1b THEN BEGIN
            ;; either the entire olt is BG [1] or a part of it
            pushd, info.dir_tmp
            imtmp = read_tiff(fbase0, geotiff = geotiffx)
            imtmp = (imtmp EQ 0b) * 129b           
            write_tiff, fbase1, imtmp, geotiff = geotiffx, $
                        compression = 1, red = r, green = g, blue = b
            imtmp = 0 & popd & GOTO, skipmsapt
         ENDIF

         imtmp = read_tiff(list_olt(isub), geotiff = geotiffx)
         qq = where(imtmp EQ 1b, nr_qq, /l64) & qq = 0
         
         IF nr_qq EQ 0 THEN BEGIN
            ;; there is only Nodata and FG [0,2]
            pushd, info.dir_tmp
            imtmp = (imtmp EQ 2b) * 17b + (imtmp EQ 0b) * 129b
            write_tiff, fbase1, imtmp, geotiff = geotiffx, $
                        compression = 1, red = r, green = g, blue = b
            imtmp = 0 & popd & GOTO, skipmsapt
         ENDIF
         widget_control, / hourglass
         IF info.my_os EQ 'windows' THEN BEGIN
            ;; all 3 or BG/FG: normal MSPA processing [0,1,2] or [1,2]
            pushd, info.dir_guidossub
            cmd = 'mspa.exe -graphfg ' + c_FGconn + $
                  ' -eew ' + c_size + ' -internal ' + c_intext + $
                  ' -disk -transition ' + c_trans + $
                  ' -i mspatmp\' + fbase0 + $
                  ' -o ' + fbase1 + ' -odir mspatmp\'
             spawn, cmd, log, / hide
            popd
         ENDIF ELSE BEGIN
            pushd, info.dir_tmp
            IF info.my_os EQ 'linux' THEN $
             mspa_os = 'mspa_lin' ELSE mspa_os = 'mspa_mac'
            cmd = info.dir_guidossub + mspa_os + ' -graphfg ' + c_FGconn + $
                  ' -eew ' + c_size + ' -internal ' + c_intext + $
                  ' -disk -transition ' + c_trans + $
                  ' -i ' + fbase0 + ' -o ' + fbase1 + ' -odir ./'
             spawn, cmd, log
            popd
         ENDELSE
         ;; get the result and add colortable and geotiff info
         pushd, info.dir_tmp
         res = query_tiff(fbase0, inpinfo, geotiff = geotiffx)
         imtmp = read_tiff(fbase1)
         write_tiff, fbase1, imtmp, geotiff = geotiffx, $
                     compression = 1, red = r, green = g, blue = b
         imtmp = 0
         popd

         skipmsapt:
         stepn = (isub + 1.0)/nr_olt * 100.0
         progressBar -> Update, stepn
      ENDFOR
      
      progressBar -> Destroy
      Obj_Destroy, progressBar


      ;;=================================================================
      ;; Part 2 finished: do mspa
      ;;=================================================================

      ;;=================================================================
      ;; Part 3: remove overlay and merge back to one image
      ;;=================================================================
      ;; we can have 3 options denoted in [columns, rows]
      ;; 1) long single row [n, 1] or long single column [1, n]; n ge 2
      ;; 2) long double row [n, 2] or long double column [2, n]; n ge 2
      ;; 3) with center tile(s) [m, n]; m and/or n gt 2
      ;;
      msg = '3) Reassembling final image, please wait...'
      progressBar = Obj_New("SHOWPROGRESS", message = msg)
      progressBar -> Start
      pushd, info.dir_tmp

      ;; case 1a) one long single row
      ;;----------------------------------
      IF nr_olty EQ 1 THEN BEGIN
         ;; leftmost olt
         fn_in = 'out_1_1.tif'
         fn_out = ' res_1_1.tif'
         cmd = gtrans + '0 0 ' + strtrim(mex + border, 2) + ' ' + $
               strtrim(ytot, 2) + ' ' + fn_in + fn_out
         IF info.my_os EQ 'windows' THEN $
          spawn, cmd, log, / hide ELSE spawn, cmd, log

         ;; rightmost olt
         fn_in = 'out_' + strtrim(nr_oltx, 2) + '_1.tif'
         fn_out = ' res_' + strtrim(nr_oltx, 2) + '_1.tif'
         q = query_tiff(fn_in, infox) & sztr = infox.dimensions
         cmd = gtrans + sborder + ' 0 ' + strtrim(sztr(0) - border, 2) + $
               ' ' + strtrim(ytot, 2) + ' ' + fn_in + fn_out
         IF info.my_os EQ 'windows' THEN $
          spawn, cmd, log, / hide ELSE spawn, cmd, log

         ;; center olts: we need to cut tile 2 to nr_oltx - 1 olt-tiles
         IF nr_oltx GT 2 THEN BEGIN
            FOR idx = 2, nr_oltx - 1 DO BEGIN
               fn_in = 'out_' + strtrim(idx, 2) + '_1.tif'
               fn_out = ' res_' + strtrim(idx, 2) + '_1.tif'
               cmd = gtrans + sborder + ' 0' + mex + ' ' + $
                     strtrim(ytot, 2) + ' ' + fn_in + fn_out
               IF info.my_os EQ 'windows' THEN $
                spawn, cmd, log, / hide ELSE spawn, cmd, log
            ENDFOR
         ENDIF
         GOTO, finalmerge
      ENDIF


      ;; case 1b) one long single column
      ;;----------------------------------
      IF nr_oltx EQ 1 THEN BEGIN
         ;; top olt
         fn_in = 'out_1_1.tif'
         fn_out = ' res_1_1.tif'
         cmd = gtrans + '0 0 ' + strtrim(xtot, 2) + ' ' + $
               strtrim(mey + border, 2) + ' ' + fn_in + fn_out
         IF info.my_os EQ 'windows' THEN $
          spawn, cmd, log, / hide ELSE spawn, cmd, log

         ;; bottom olt
         fn_in = 'out_1_' + strtrim(nr_olty, 2) + '.tif'
         fn_out = ' res_1_' + strtrim(nr_olty, 2) + '.tif'
         q = query_tiff(fn_in, infox) & szbl = infox.dimensions
         cmd = gtrans + '0' + sborder + ' ' + strtrim(xtot, 2) + ' ' + $
               strtrim(szbl(1) - border, 2) + ' ' + fn_in + fn_out
         IF info.my_os EQ 'windows' THEN $
          spawn, cmd, log, / hide ELSE spawn, cmd, log

         ;; center olts: we need to cut tile 2 to nr_olty - 1 olt-tiles
         IF nr_olty GT 2 THEN BEGIN
            FOR idy = 2, nr_olty - 1 DO BEGIN
               fn_in = 'out_1_' + strtrim(idy, 2) + '.tif'
               fn_out = ' res_1_' + strtrim(idy, 2) + '.tif'
               cmd = gtrans + '0' + sborder + ' ' + strtrim(xtot, 2) + $
                     mey + ' ' + fn_in + fn_out
               IF info.my_os EQ 'windows' THEN $
                spawn, cmd, log, / hide ELSE spawn, cmd, log
            ENDFOR
         ENDIF
         GOTO, finalmerge
      ENDIF

      ;; case 2)
      ;;----------------------------------
      ;; if we arrive here we have at least a 2x2 tiling

      ;; 1) cut the corner olts only
      ;;----------------------------------
      ;; top left: 1/1
      fn_in = 'out_1_1.tif'
      fn_out = ' res_1_1.tif'
      cmd = gtrans + '0 0 ' + strtrim(mex + border, 2) + ' ' + $
            strtrim(mey + border, 2) + ' ' + fn_in + fn_out
      IF info.my_os EQ 'windows' THEN $
       spawn, cmd, log, / hide ELSE spawn, cmd, log

      ;; top right: nr_oltx/1
      fn_in = 'out_' + strtrim(nr_oltx, 2) + '_1.tif'
      fn_out = ' res_' + strtrim(nr_oltx, 2) + '_1.tif'
      q = query_tiff(fn_in, infox) & sztr = infox.dimensions
      cmd = gtrans + sborder + ' 0 ' + strtrim(sztr(0) - border, 2) + $
            ' ' + strtrim(mey + border, 2) + ' ' + fn_in + fn_out
      IF info.my_os EQ 'windows' THEN $
       spawn, cmd, log, / hide ELSE spawn, cmd, log

      ;; bottom left: 1/nr_olty
      fn_in = 'out_1_' + strtrim(nr_olty, 2) + '.tif'
      fn_out = ' res_1_' + strtrim(nr_olty, 2) + '.tif'
      q = query_tiff(fn_in, infox) & szbl = infox.dimensions
      cmd = gtrans + '0' + sborder + ' ' + strtrim(mex + border, 2) + ' ' + $
            strtrim(szbl(1) - border, 2) + ' ' + fn_in + fn_out
      IF info.my_os EQ 'windows' THEN $
       spawn, cmd, log, / hide ELSE spawn, cmd, log

      ;; bottom right: nr_oltx/nr_olty
      fn_in = 'out_' + strtrim(nr_oltx, 2) + '_' + strtrim(nr_olty, 2) + '.tif'
      fn_out = ' res_' + strtrim(nr_oltx, 2) + '_' + $
               strtrim(nr_olty, 2) + '.tif'
      q = query_tiff(fn_in, infox) & szbr = infox.dimensions
      cmd = gtrans + sborder + sborder + ' ' + $
            strtrim(szbr(0) - border, 2) + ' ' + $
            strtrim(szbr(1) - border, 2) + ' ' + fn_in + fn_out
      IF info.my_os EQ 'windows' THEN $
       spawn, cmd, log, / hide ELSE spawn, cmd, log

      ;; so far we are ok for a 2x2, now check for more olts
      ;;  cut the boundary frame olts only
      ;;----------------------------------
      IF nr_oltx GT 2 THEN BEGIN ;; cut top and bottom row
         ;; top row: we need to cut tile 2 to nr_oltx - 1 olt-tiles
         FOR idx = 2, nr_oltx - 1 DO BEGIN
            fn_in = 'out_' + strtrim(idx, 2) + '_1.tif'
            fn_out = ' res_' + strtrim(idx, 2) + '_1.tif'
            cmd = gtrans + sborder + ' 0' + mex + ' ' + $
                  strtrim(mey + border, 2) + ' ' + fn_in + fn_out
            IF info.my_os EQ 'windows' THEN $
             spawn, cmd, log, / hide ELSE spawn, cmd, log
         ENDFOR
         ;; bottom row: we need to cut nr_oltx - 2 olt-tiles
         FOR idx = 2, nr_oltx - 1 DO BEGIN
            str2 = strtrim(idx, 2) + '_' + strtrim(nr_olty, 2)
            fn_in = 'out_' + str2 + '.tif'
            fn_out = ' res_' + str2 + '.tif'
            cmd = gtrans + sborder + sborder + mex + ' ' + $
                  strtrim(szbr(1) - border, 2) + ' ' + fn_in + fn_out
            IF info.my_os EQ 'windows' THEN $
             spawn, cmd, log, / hide ELSE spawn, cmd, log
         ENDFOR
      ENDIF

      IF nr_olty GT 2 THEN BEGIN ;; cut left and right column
         ;; left column: we need to cut nr_olty - 2 olt-tiles
         FOR idy = 2, nr_olty - 1 DO BEGIN
            fn_in = 'out_1_' + strtrim(idy, 2) + '.tif'
            fn_out = ' res_1_' + strtrim(idy, 2) + '.tif'
            cmd = gtrans + '0' + sborder + ' ' + strtrim(mex + border, 2) + $
                  mey + ' ' + fn_in + fn_out
            IF info.my_os EQ 'windows' THEN $
             spawn, cmd, log, / hide ELSE spawn, cmd, log
         ENDFOR
         ;; right column: we need to cut nr_olty - 2 olt-tiles
         FOR idy = 2, nr_olty - 1 DO BEGIN
            str2 = strtrim(nr_oltx, 2) + '_' + strtrim(idy, 2)
            fn_in = 'out_' + str2 + '.tif'
            fn_out = ' res_' + str2 + '.tif'
            cmd = gtrans + sborder + sborder + ' ' + $
                  strtrim(szbr(0) - border, 2) + mey + ' ' + fn_in + fn_out
            IF info.my_os EQ 'windows' THEN $
             spawn, cmd, log, / hide ELSE spawn, cmd, log
         ENDFOR
      ENDIF

      IF nr_oltx GT 2 AND nr_olty GT 2 THEN BEGIN
         ;; cut the remaining 'normal' olts inside the frame
         FOR idy = 2, nr_olty - 1 DO BEGIN
            FOR idx = 2, nr_oltx - 1 DO BEGIN
               str2 = strtrim(idx, 2) + '_' + strtrim(idy, 2)
               fn_in = 'out_' + str2 + '.tif'
               fn_out = ' res_' + str2 + '.tif'
               cmd = gtrans + sborder + sborder + mex + mey + $
                     ' ' + fn_in + fn_out
               IF info.my_os EQ 'windows' THEN $
                spawn, cmd, log, / hide ELSE spawn, cmd, log
            ENDFOR
         ENDFOR
      ENDIF

      finalmerge:
      popd ;; leave tmp
      ;;=================================================================
      ;; removal of overlays finished
      ;;=================================================================
      ;; go up to dir_dat and merge into one big image
      zz = file_basename(fname) & zz = strmid(zz,0,strpos(zz,'.',/reverse_search))
      fn_out = dir_dat + zz + suffix
      ;; the MSPA settings watermark
      wm = ' ' + strmid(file_basename(suffix,'.tif'),1)

      ;;===================================
      IF info.my_os EQ 'windows' THEN BEGIN
         pushd, info.dir_tmp
	       qq = file_search('res*.tif')
	       openw, 1, 'reslist.txt' & for i = 0l, n_elements(qq)-1 do printf,1,qq[i] & close,1
	       ;; setup vrt image
	       spawn, gbuildvrt + 'reslist.txt xx.vrt', /hide
	       ;; cmd for watermark and merging	       
	       cmd = info.windrive + ' & cd "' + info.dir_fwtools + '" & setfw.bat & cd "' + $
	         info.dir_tmp + '" & gdal_translate -mo ' + $
	         '"TIFFTAG_IMAGEDESCRIPTION=GTB_MSPA, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/' + $
	         wm + '" -co "COMPRESS=LZW" xx.vrt "' + fn_out + '"' 
         popd
      ;;=================================
      ENDIF ELSE BEGIN
         ;; OSX and Linux
         ;; setup vrt image
         spawn, gbuildvrt + info.dir_tmp + 'xx.vrt ' + info.dir_tmp + 'res*.tif'             
         ;; cmd for watermark and merging  
         if strlen(info.sysgdal) gt 0 then cmd = 'unset LD_LIBRARY_PATH; gdal_translate -mo ' else $
          cmd = info.dir_fwtools + 'gdal_translate -mo '
         cmd = cmd + '"TIFFTAG_IMAGEDESCRIPTION=GTB_MSPA, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/' + $
          wm + '" -co "COMPRESS=LZW" "' + info.dir_tmp + 'xx.vrt" "' + fn_out + '"'
      ENDELSE
      IF info.my_os EQ 'windows' THEN spawn, cmd, log, / hide ELSE spawn, cmd, log


      ;; remove the intermediate files
      pushd, info.dir_tmp
      list = file_search() & nl = n_elements(list)
      IF list[0] NE '' THEN FOR i = 0, nl -1 DO file_delete, list[i], / allow_nonexistent, / quiet, / recursive
      popd ;; back to the roots
      ;;=================================================================
      ;; Part 3 finished: remove overlay and merge back to one image
      ;;=================================================================
      progressBar -> Destroy
      Obj_Destroy, progressBar

      ;; final message
      mt =  round((systime( / sec) - time0) / 60.0 * 100.0) / 100.0
      qq = strsplit(mt, '.', / extract)
      mt = strtrim(qq(0), 2) + '.' + strmid(qq(1), 0, 2)

      msg =  'MSPA tile comp.time [min]: ' + mt + $
             string(10b) + string(10b) + $
             "The MSPA processed image has been saved to:" + $
             string(10b) + fn_out + string(10b) + string(10b) + $
             '(to get information on statistics and openings load' + string(10b) + $
             'the image into GTB and activate: MSPA statistics)' + string(10b) + string(10b) + $
             'Please use GWB instead of MSPA-Tiling.' + string(10b)
      result = dialog_message(msg, / information)
      widget_control, info.w_file, / sensitive

      ;; reset the colortable to the settings before the batch processing
      tvlct, rini, gini, bini

      GOTO, fin
   END

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;                              M S P A S T A T S
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   'do_mspa_stats':  BEGIN
      ;; if the currently selected setting for do_mspa_stats is 0,
      ;; then reset everything
      widget_control, / hourglass
      info.do_mspa_stats_id = (event.select EQ 1)

      info.mspa_stats_show = info.do_mspa_stats_id
      IF info.mspa_stats_show EQ 0b THEN BEGIN
         info.is_mspa = 1
         IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
            info.selsubregion_id = 0
            ;; deactivate zoomfactor selector
            widget_control, info.w_zoomfac, sensitive = 1
            widget_control, info.w_selsubregion, $
                            set_value = 'Zoom Mode'
            ;; restore the prezoomed process image
            * info.process = * info.prezoomprocess
            ;; disable button and enable motion events in w_draw
            widget_control, info.w_draw, Draw_Motion_Events = 1
            widget_control, info.w_draw, Draw_Button_Events = 0
            info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
         ENDIF
         GOTO, skip_stats
      ENDIF

      image0 = * info.fr_image ;;& sz = size(image0)

      ;; if in zoom mode, quit the zoom mode to make clear that
      ;; statistics are for the entire image
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
         info.selsubregion_id = 0
         ;; deactivate zoomfactor selector
         widget_control, info.w_zoomfac, sensitive = 1
         widget_control, info.w_selsubregion, $
                         set_value = 'Zoom Mode'
         ;; restore the prezoomed process image
         * info.process = * info.prezoomprocess
         ;; disable button and enable motion events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 1
         widget_control, info.w_draw, Draw_Button_Events = 0
         info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF

      ;; enable this part below to make statistics for the viewport
      ;;  rsf = info.resfac
      ;; x/y coordinates of our viewport are:
      ;;IF info.selsubregion_id EQ 1 THEN BEGIN ;; zoom-mode
      ;; x = info.x * rsf & y = info.y * rsf
      ;; ENDIF ELSE BEGIN ;; viewport corresponds to full image
      ;;   x = [0, sz(1) - 1] & y = [0, sz(2) - 1]
      ;; ENDELSE
      ;; apply the viewport area to the data
      ;; image0 = image0[x(0):x(1),y(0):y(1)]

      ;; determine the current forground connectivity for label_region
      fconn = info.mspa_param1_id  ;; current value for foreground
      ttrans = info.mspa_param3_id ;; current value for transition
      tintext = info.mspa_param4_id  ;; current value for Intext
      
      simplestats, image0, fconn, ttrans, tintext, info.do_label_groups_id, st
      widget_control, info.w_mspa_stats, set_value = st
      info.is_mspa = 1 & info.mspa_stats_show = 1
      skip_stats:
   END
     
   ;;*****************************************************************************************************

   'do_label_groups':  BEGIN
   ;; if the currently selected setting for do_mspa_stats is 0,
   ;; then reset everything
   info.do_label_groups_id = (event.select EQ 1)
   label_group_reset:
   fconn = info.mspa_param1_id  ;; current value for foreground
   ;; delete any previously defined marker.sav file
   testfile = info.dir_tmp + 'marker.sav' & res=file_info(testfile)
   IF res.exists GT 0 THEN file_delete, testfile, / quiet

   widget_control, / hourglass
   
   if info.do_label_groups_id eq 1 then begin
     if info.is_influ then goto, influ_cont     
    
     image0 = * info.fr_image
     ;; backup original data for restore when label is unchecked
     save, image0, filename=info.dir_guidossub + 'fragmtmp.sav'

      ;; label MSPA
      ;;=============================================
      if info.is_mspa eq 1 then begin 
        ;; label core areas into groups
        image0 = (image0 eq 17b) or (image0 eq 117b) & sz=size(image0,/dim)
        ext = uintarr(sz(0) + 2, sz(1) + 2) & sz2=size(ext,/dim)
        ext[1:1 + sz(0) - 1, 1:1 + sz(1) - 1] = temporary(image0)
        objects = label_region(ext, / ulong, all_neighbors = fconn)
        ;; go back to original size
        objects = objects[1:sz(0), 1:sz(1)]
        obj_area = histogram(objects, reverse_indices = revind, / l64)
        ;; small, medium, large objects, exclude the background
        obj_area[0] = 9000000000000000000
        qsmall = where(obj_area lt info.label_t1,c_small)
        obj_area[0] = 1
        qlarge = where(obj_area gt info.label_t2, c_large)
        image0 = * info.fr_image

        if c_small gt 0 then begin
          for id = 0, c_small-1 do begin
            il = qsmall[id] & q = revind[revind[il]:revind[il+1]-1] & image0[q] = image0[q]-1b
            ;;q = where(objects eq qsmall[id])& image0[q] = image0[q]-1b
          endfor
        endif
        if c_large gt 0 then begin
          FOR id = 0l, c_large-1 DO BEGIN
            il = qlarge[id] & q = revind[revind[il]:revind[il+1]-1] & image0[q] = image0[q]+1b
            ;;q = where(objects eq qlarge[id])& image0[q] = image0[q]+1b
          endfor
        endif
        ;; end of label MSPA
        ;;=============================================
        
      ;;endif else if info.is_fragm eq 1 then begin 
      endif else if info.is_fragm gt 0 then begin
        ;; label Fragm or P2, P22, P23
        ;;=============================================
        ;; label fragm areas into groups
        qsmall = where(image0 lt info.label_t1,c_small)
        qlarge = where(image0 gt info.label_t2 and image0 lt 101b, c_large)
        ;; set all to medium: 60b
        image0 = (image0 lt 101b)*60b + (image0 gt 100b)*image0
        ;; add small and large if present
        if c_small gt 0 then image0[qsmall] = 40b
        if c_large gt 0 then image0[qlarge] = 70b
        ;; test for spatcon plus BGmask
        if info.is_fragm gt 1 and info.mspa_param4_id eq 1 then begin
          restore, info.dir_tmp + 'mask.sav'
          image0[BGmask] = 101b
        endif
        
        ;; end of label Fragm
        ;;=============================================
        
      endif else if info.is_cost eq 1 then begin
        ;; label Cost
        ;;=============================================
        ;; label distance areas into groups
        ;; Foreground
        qsmall = where(* info.fr_image LT info.label_t1, c_small)
        qlarge = where(* info.fr_image GT info.label_t2, c_large)
                 
        ;; set all FG to medium: 60b
        image0 = (image0 ge 0b)*60b
        ;; add small and large if present
        if c_small gt 0 then image0[qsmall] = 40b
        if c_large gt 0 then image0[qlarge] = 70b

        ;; missing pixels
        q = where(* info.fr_image eq 102b, ct, /l64)
        if ct gt 0 then image0[q] = 102b

        ;; LCP pixels, make them pink
        q = where(* info.fr_image eq 103b, ct, /l64)
        if ct gt 0 then image0[q] = 103b 

        ;; unreachable pixels, make them brown
        q = where(* info.fr_image EQ 104b, ct, /l64)
        if ct gt 0 then image0[q] = 104b

        ;; target object pixels
        q = where(* info.fr_image eq 101b, ct, /l64)
        if ct gt 0 then image0[q]=101b

      endif else if info.is_dist eq 1 then begin
        ;; label Distance
        ;;=============================================
        ;; label distance areas into groups
        ;; Foreground
        qsmall = where(* info.morphdist lt info.label_t1, c_small)
        qlarge = where(* info.morphdist gt info.label_t2, c_large)
        ;; set all FG to medium: 140b
        image0 = (image0 ge 0b)*140b
        ;; add small and large if present
        if c_small gt 0 then image0[qsmall] = 155b
        if c_large gt 0 then image0[qlarge] = 180b
        
        ;; Background
        t1neg = -long(info.label_t1) & t2neg = -long(info.label_t2) 
        qsmall = where(* info.morphdist gt t1neg AND * info.morphdist lt 0.0, c_small)
        qlarge = where(* info.morphdist lt t2neg, c_large)
        ;; set all BG to medium: 110b
        image0 = (* info.morphdist lt 0.0)*110b + (* info.morphdist ge 0.0)*image0
        ;; add small and large if present
        if c_small gt 0 then image0[qsmall] = 130b
        if c_large gt 0 then image0[qlarge] = 100b
        
        ;; missing pixels
        qmiss = where(* info.fr_image eq 0b, ct_miss, /l64)
        if ct_miss gt 0 then image0[qmiss]=0b
        q = strpos(info.add_title,': ',/reverse_search)
        info.add_title = strmid(info.add_title, 0, q) + ')'

        ;; end of label Distance
        ;;=============================================    

      endif else if info.is_contort eq 1 then begin
        ;; label Contortion
        ;;=============================================
        ;; label Contortion areas into groups
        qsmall = where(image0 gt 2 AND * info.contort lt info.label_t1, c_small, /l64)
        qlarge = where(* info.contort gt info.label_t2, c_large, /l64)
        ;; set all to medium: 110b
        image0 = image0*(image0 lt 3b) + (image0 gt 2b)*110b
        ;; add small and large if present, use contortion color table
        if c_small gt 0 then image0[qsmall] = 5b
        if c_large gt 0 then image0[qlarge] = 255b
        ;; end of label contort
        ;;=============================================
      
      endif 
      
      
   endif else begin  ;; info.do_label_groups_id eq 0b
      if info.is_influ then goto, influ_cont
      if info.is_dist eq 1 then begin
        q = strpos(info.add_title,')',/reverse_search)
        zz = ': tick Divide for new distance range settings; Intext for barplot)'
;        IF strpos(info.add_title,'Frag(Hypsometry_Index)') GT 0 THEN $
;          zz = ': tick Divide for new distance range settings)'
        info.add_title = strmid(info.add_title, 0, q) + zz
      endif
    
    ;; collapse core/fragm groups -> restore original image
    ;;;================================================================================
      restore, info.dir_guidossub + 'fragmtmp.sav'
   endelse

   ;; if in zoom mode, quit the zoom mode to make clear that
   ;; statistics are for the entire image
   IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
     info.selsubregion_id = 0
     ;; deactivate zoomfactor selector
     widget_control, info.w_zoomfac, sensitive = 1
     widget_control, info.w_selsubregion, $
       set_value = 'Zoom Mode'
     ;; restore the prezoomed process image
     * info.process = * info.prezoomprocess
     ;; disable button and enable motion events in w_draw
     widget_control, info.w_draw, Draw_Motion_Events = 1
     widget_control, info.w_draw, Draw_Button_Events = 0
     info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
   ENDIF
   * info.process = temporary(image0)
   * info.fr_image = * info.process
   
   if info.is_mspa eq 1 then begin 
     info.mspa_stats_show = info.do_mspa_stats_id
     IF info.mspa_stats_show EQ 1b THEN BEGIN
     ;; determine the current forground connectivity for label_region
       ttrans = info.mspa_param3_id ;; current value for transition
       tintext = info.mspa_param4_id  ;; current value for Intext
       simplestats,  * info.process, fconn, ttrans, tintext, info.do_label_groups_id, st
       widget_control, info.w_mspa_stats, set_value = st
     ENDIF
   endif
   
   END

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;       N E T W O R K   A N A L Y S I S:  COMPONENTS
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   'nw_components':  BEGIN
      ;; 1) check if mspa
      IF info.is_mspa NE 1b THEN BEGIN
         msg = 'Image has no MSPA classes.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF

      ;; 2) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
         info.selsubregion_id = 0
         ;; deactivate zoomfactor selector
         widget_control, info.w_zoomfac, sensitive = 1
         widget_control, info.w_selsubregion, $
                         set_value = 'Zoom Mode'
         ;; restore the prezoomed process image
         * info.process = * info.prezoomprocess
         ;; disable button and enable motion events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 1
         widget_control, info.w_draw, Draw_Button_Events = 0
         info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF

      widget_control, / hourglass
      ;; assign the full resolution image
      image0 = * info.fr_image & sz = size(image0, / dim)

      ;; labeling must be done on extended image to avoild
      ;; zeroed boundaries, go back to original dimension later
      eew = fix(info.mspa_size_current) & eew2 = eew * 2
      ext = bytarr(sz(0) + eew2, sz(1) + eew2)
      ext[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1] = image0
      

      ;; cores + bridges, uniq networks and isolated cores
      corex = (ext GE 16b AND ext LE 18b) OR (ext GE 116b AND ext LE 118b)
      bridgex = (ext GT 30b AND ext LT 40b) OR (ext GT 130b AND ext LT 140b)
      qm = where(ext EQ 129b, ctqm, /l64) & ext = 0 ;; missing pixels in enlarged image
      cl = byte([1, 5, 9, 17, 33, 65, 80, 150, 176])
      image0 = corex + bridgex * 2b;; the networks

      ;; add ECA info
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; MSPA components
      lbl_comp = label_region(image0, / all, / ulong)
      nr_comp = max(lbl_comp)

      ;; set area of links in components to zero and get area by component
      h_comp_area = histogram(lbl_comp * (image0 EQ 1b), / l64)

      ;; PCnum:= overall connectivity. Sum of [ (core-areas per component)^2 ]
      pcnum = total(h_comp_area(1: * )^2, / double)

      ;; ECA: equivalent connected (core) area = sqrt(pcnum) [unit area, hectares]
      ECA = sqrt(pcnum)

      ;; ECA_rel: normalised/relative ECA
      ;; ARH: amount of reachable habitat (%)
      ;; PRH: percentage of reachable habitat
      ECA_max = total(h_comp_area[1:*])
      ECA_rel = ECA/ECA_max * 100.0

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; save them for other network analysis
      save, image0, eew, sz, ctqm, qm, lbl_comp, nr_comp, h_comp_area, pcnum, $
        eca, eca_max, eca_rel, filename = info.dir_tmp + 'nwtmp.sav',/compress
      
      nw_ids = temporary(lbl_comp) ;;;label_region(image0, / all, / ulong)
      IF ctqm GT 0 THEN image0(qm) = 129b
      qm = 0
      nw_hnw = histogram(nw_ids, reverse_indices = r, / l64) ;; area of components
      nw_hnwb = nw_hnw * 0
      ;; assign random color to components with bridges and black for
      ;; those without bridges = isolated core components
      FOR i = 1l, n_elements(nw_hnw) - 1 DO BEGIN
         t = ulong(total(bridgex[r[r[i]:r[i + 1] - 1]]))
         nw_hnwb(i) = t & clx = i MOD 9
         IF t GT 0 THEN $
          image0[r[r[i]:r[i + 1] - 1]] = cl(clx) ELSE $
          image0[r[r[i]:r[i + 1] - 1]] = 103b
      ENDFOR
      mxn = strtrim(n_elements(nw_hnw) - 1, 2)

      ;; load the colors-on table
      restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b

      ;; store stuff in the info structure
      info.autostretch_id = 0
      * info.nw_ids = nw_ids[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1]
      * info.process = image0[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1]
      nw_ids = 0 & image0 = 0 & * info.fr_image = * info.process
      info.add_title = ' [NW components: ' + mxn + ', ECA: ' + strtrim(round(eca),2) + $
        ', DOC: ' + strtrim(eca_rel,2) + '%]'

      ;; reset mspa
      info.is_mspa = 0 & info.is_fragm = 0 & info.is_contort = 0 & info.is_dist = 0 & info.is_influ = 0
      info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 & info.is_cost = 0

      ;; set is_nw to active
      info.is_nw = 1b & info.is_nwconnect = 0 & info.nw_mxinw = long(mxn)
      * info.nw_hnw = nw_hnw & nw_hnw = 0
      * info.nw_hnwb = nw_hnwb & nw_hnwb = 0
   END



   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;       N E T W O R K   A N A L Y S I S:  IMPORTANCE
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   'nw_importance':  BEGIN
      ;; 1) nw must be active

      IF total(info.is_nw + info.is_nwconnect) LT 0.9 THEN BEGIN
         msg = 'Please first run: Image Analysis -> Connectivity -> Components.' + $
               string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF

      ;; 2) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
         info.selsubregion_id = 0
         ;; deactivate zoomfactor selector
         widget_control, info.w_zoomfac, sensitive = 1
         widget_control, info.w_selsubregion, $
                         set_value = 'Zoom Mode'
         ;; restore the prezoomed process image
         * info.process = * info.prezoomprocess
         ;; disable button and enable motion events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 1
         widget_control, info.w_draw, Draw_Button_Events = 0
         info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF

      widget_control, / hourglass
      ;; get the extended fullres image of cores and bridges
      fn = info.dir_tmp + 'nwtmp.sav' & res = file_info(fn)
      IF res.exists NE 1b THEN BEGIN
         msg = 'Please first run: Image Analysis -> Connectivity -> Components.' + $
               string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      restore, fn    

      ;; links = MSPA bridges
      lbl_links = label_region(image0 EQ 2b, / all, / ulong)
      nr_links = max(lbl_links)
      
      IF nr_links EQ 0 THEN BEGIN
        msg = 'Network without links.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF

      ;; nodes = MSPA cores
      lbl_nodes = label_region(image0 EQ 1b, / all, / ulong)
      nr_nodes = max(lbl_nodes)

      IF nr_nodes EQ 0 THEN BEGIN
        msg = 'Network without nodes.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF

      ;; detect 8-connected neighboring different objects by looking in the
      ;; 8-con neighborhood of each bridge for unique core IDs
      ;; meaning: each bridge connects to which core IDs?
      se8 = replicate(1, 3, 3) ;; sel for 8-conn

      time0 = systime( / sec)
      ;; dilate core into bridges to retrieve the edges of bridges
      tmp = dilate(lbl_nodes, se8, / gray, / ulong) * (lbl_links GT 0)
      ;; the bridgeedge coordinate in lbl_bridge is the label of the bridge
      ;; se8 on this coordinate contains the core it connects to
      qb = where(tmp GT 0, ct_b, /l64) & fn_tmp = info.dir_data + 'cs22_tmp.txt'
      openw, 1, fn_tmp
      FOR idx = 0l, ct_b - 1 DO BEGIN
         bridge = lbl_links(qb(idx)) + nr_nodes
         xy = array_indices(tmp, qb(idx))
         vals = lbl_nodes[xy(0) - 1:xy(0) + 1, xy(1) - 1:xy(1) + 1]
         uvals = vals[uniq(vals, sort(vals))] & uvals = uvals[1: * ]
         FOR i = 0l, n_elements(uvals) - 1 DO printf, 1, bridge, uvals(i)
      ENDFOR
      close, 1 &  tmp = 0

      ;; filter out duplicates
      res = lonarr(2, file_lines(fn_tmp))
      openr, 1, fn_tmp & readf, 1, res & close, 1 & file_delete, fn_tmp, / quiet
      openw, 1, fn_tmp
      FOR idx = 1l, nr_links DO BEGIN
         id = idx + nr_nodes & q = where(res(0, * ) EQ id, ct, /l64)
         IF ct GT 0 THEN BEGIN
            vals = res(1, q) & uvals = vals[uniq(vals, sort(vals))]
            FOR bb = 0l, n_elements(uvals) - 1 DO $
                     printf, 1, id - nr_nodes, uvals(bb)
         ENDIF
      ENDFOR
      close, 1

      ;; links and their nodes
      linknodes = lonarr(2, file_lines(fn_tmp))
      openr, 1, fn_tmp & readf, 1, linknodes & close, 1
      file_delete, fn_tmp, / quiet
      importance = image0 * 0.0


      FOR idc = 1l, nr_comp DO BEGIN  ;; loop over components
         ;;=============================================
         ;; properties of component sub-arrays
         ;;=============================================
         qc = where(lbl_comp EQ idc, /l64) ;; component pixels
         x = where(histogram(lbl_links(qc)) GT 0, ct)
         ;; skip calculation for component with no links
         IF ct EQ 1 THEN GOTO, skipit2
         lids = x[1: * ] ;; the link and node IDs of this component
         x = where(histogram(lbl_nodes(qc)) GT 0) & nids = x[1: * ]

         ;; setup connection table
         n_nids = n_elements(nids) & n_lids = n_elements(lids)
         ctab = replicate(0l, n_nids, n_nids)

         FOR ilin = 0l, n_lids - 1 DO BEGIN
            ;; this link connects these nodes
            qn = where(linknodes(0, * ) EQ lids(ilin), ctn, /l64)
            nodes = reform(linknodes(1, qn))
            ;; find the seed node
            x = where(nids EQ nodes(0), /l64) & x = x[0]
            ;; get the connected node array indices
            FOR iy = 1l, ctn - 1 DO BEGIN
               y = where(nids EQ nodes(iy), /l64) & y = y[0]
               ctab(x, y) = lids(ilin)
            ENDFOR
         ENDFOR
         ;; the full matrix is the original + transposed:
         ctab = transpose(ctab) + ctab

         ;; calculate only those nodes connecting to more than one other node
         x = where(total(ctab GT 0, 1) gt 1.5, ct, complement = y, /l64)
         skipnodes = 0
         IF ct EQ 0 THEN skipnodes = 1 ELSE nidsc = nids(x)

         ;; sub-arrays of the component
         ww = array_indices(lbl_comp, qc)
         x1 = min(ww(0, * ), max = x2) & y1 = min(ww(1, * ), max = y2)
         x1 = x1 - 1 & x2 = x2 + 1 & y1 = y1 - 1 & y2 = y2 + 1
         maskcomp =  (lbl_comp[x1:x2, y1:y2] EQ idc)
         hh = h_comp_area & hh_idc = hh(idc) & hh(idc)= 0
         hh = total(hh(1: * )^2, / double)
         subimportance = importance[x1:x2, y1:y2]  ;; define subimportance area
         subim = image0[x1:x2, y1:y2] & subl0 = subim NE 2b & subim = subim * maskcomp
         sub = lbl_links[x1:x2, y1:y2]

         ;; importance of links
         FOR il = 0l, n_elements(lids) - 1 DO BEGIN
            tmp = subim & q = where(sub EQ lids(il), /l64) & tmp(q) = 0b
            hca = histogram(label_region(tmp, / all, / ulong) * subl0, / l64)
            pcnew = total(hca(1: * )^2, / double) + hh
            imp = (pcnum - pcnew) / pcnum * 100.0 & subimportance(q) = imp
         ENDFOR

         ;; importance of nodes
         IF skipnodes EQ 1 THEN GOTO, skipit
         sub = lbl_nodes[x1:x2, y1:y2] ;* maskcomp
         tmp2 = maskcomp * subl0
         FOR il = 0l, n_elements(nidsc) - 1 DO BEGIN
            tmp = subim & q = where(sub EQ nidsc(il), /l64) & tmp(q) = 0b
            hca = histogram(label_region(tmp, / all, / ulong) * subl0, / l64)
            pcnew1 = total(hca(1: * )^2, / double)
            ;; set removed node area to zero: set node to link
            tmp = tmp2 & tmp(q) = 0b & hca = histogram(tmp, / l64)
            pcnew2 = total(hca(1: * )^2, / double)
            imp = (pcnew2 - pcnew1) / pcnum * 100.0 & subimportance(q) = - imp  ;; -imp?
         ENDFOR
         skipit:
         importance[x1:x2, y1:y2] = importance[x1:x2, y1:y2] + $
          subimportance * maskcomp
         skipit2:
      ENDFOR


     print, 'Importance comp.time [sec]: ', systime( / sec) - time0

      ;; display the top 1,5, 10% relative importance for
      ;; bridge (red: 192, 194, 195 byte) and core (green: 208, 210, 211 byte)
      mx_bridge = max(importance) & mx_core = min(importance)

      ;; 1% [192b, 208b]
      htop = mx_bridge * 0.99 & qb01 = where(importance GE htop, /l64)
      htop = mx_core * 0.99 & qc01 = where(importance LE htop, /l64)

      ;; 5% [194b, 210b]
      htop = mx_bridge * 0.95 & qb05 = where(importance GE htop, /l64)
      htop = mx_core * 0.95 & qc05 = where(importance LE htop, /l64)

      ;; 10% [195b, 211b]
      htop = mx_bridge * 0.9 & qb10 =  where(importance GE htop, /l64)
      htop = mx_core * 0.9 & qc10 = where(importance LE htop, /l64)

      ;; build the image for the display
      ;; core in water color and bridges in black:
      image0 = lbl_links - long64(lbl_nodes) ;; the node IDs
      * info.cs22_nodes = image0[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1]
      image0 = (temporary(lbl_nodes) GT 0) * 176b + $
              (temporary(lbl_links) GT 0) * 103b

      ;; the hot 10, 5, 1% bridges
      image0(qb10) = 195b & image0(qb05) = 194b & image0(qb01) = 192b
      image0(qc10) = 211b & image0(qc05) = 210b & image0(qc01) = 208b
      IF ctqm GT 0 THEN image0[qm] = 129b & qm = 0


      ;; store stuff in the info structure
      * info.cs22_conn = temporary(importance[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1])
      * info.process = temporary(image0[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1])
      * info.fr_image = * info.process
      info.add_title = ': Connectivity Importance(Node_max=' + $
                       strtrim(abs(mx_core), 2) + $
                       ', Link_max=' + strtrim(mx_bridge, 2) + ')'
      ;; reset mspa
      info.is_nw = 0 & info.is_nwconnect = 0 & info.is_fragm = 0 & info.is_cost = 0
      info.is_mspa = 0 & info.is_contort = 0 & info.is_dist = 0 & info.is_influ = 0
      info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0
      ;; set is_cs22 to active
      info.is_cs22 = 1 & info.cs22_nr_core = nr_nodes
      info.cs22_mx_bridge = mx_bridge & info.cs22_mx_core = mx_core
   END

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; N E T W O R K   A N A L Y S I S: COMPONENT CONNECTORS
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   'nw_nwconnect':BEGIN

     ;; 1) check if nw
     IF info.is_nw NE 1b THEN BEGIN
       msg = 'Please first run: Image Analysis -> Network -> NW Components.' + $
         string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF

     ;; 2) if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF

     widget_control, / hourglass
     ;; get the extended fullres image of cores and bridges
     fn = info.dir_tmp + 'nwtmp.sav' & res = file_info(fn)
     IF res.exists NE 1b THEN BEGIN
       msg = 'Please first run: Image Analysis -> Network -> NW Components.' + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     restore, fn

     time0 = systime( / sec)
     ;; mspa FG-connectivity: 8 <=> euclidean distance;  4 <=> cityblock
     IF info.mspa_param1_id EQ 1b THEN distnbr = 3 ELSE distnbr = 2

     ;; PCnum:= overall connectivity. Sum of[ (components area)^2]
     ;; bridges have no area
     ;;
     ;; network components
     ;; btw, image0 is enlarged image with 1-core and 2-bridge

     IF nr_comp LT 5 THEN BEGIN
       msg = 'Network needs at least 5 components.' + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF

     ;; set area of links in components to zero and get area by component
     ;; this to use the 5 biggest components having the biggest core area
     ;;h_comp_area = histogram(lbl_comp * (image0 NE 2b), / l64)

     ;; 5 biggest components by area, *** not by core area ***:
     h_comp_area = histogram(lbl_comp, / l64)
     ;; overall connectivity of the current network of components before adding in anything new
     pcnum_orig = total(h_comp_area(1: * )^2, / double)

     ;; we can have 10 uniq links between the 5 largest components
     ;; from h_comp_area we exclude the first entry (= background)
     lcompidx = (reverse(sort(h_comp_area[1:*])))+1
     lcompidx = lcompidx[0:4] ;; these are the top 5 by ID

     ;;lcomparea = h_comp_area[lcompidx]
     ;tenlinks = strtrim([12, 13, 14, 15, 23, 24, 25, 34, 35, 45], 2)
     tenlinks = ['1 <-> 2', '1 <-> 3', '1 <-> 4', '1 <-> 5', '2 <-> 3', $
       '2 <-> 4', '2 <-> 5', '3 <-> 4', '3 <-> 5', '4 <-> 5']
     tenlinksimp = fltarr(10) & tenlinkslength = intarr(2, 10)

     ;; prepare image for display
     ;; load the colors-on table
     restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b
     nw_conns = image0 * 0.0 & cl = byte([1, 5, 9, 17, 33, 65, 80, 150, 176])
     image0 = (image0 GT 0b) * 150b
     FOR i = 1l, 5 DO BEGIN
       q = where(lbl_comp EQ lcompidx(i - 1), /l64) & image0[q] = cl(i)
     ENDFOR

     ;; prepare temporary output   
     statsfiletxt = info.dir_tmp + 'compconnect_tmp.txt'
     close, 11 & openw, 11, statsfiletxt
     printf, 11, format='(9(a13))', 'CCONN', 'COMP_A', 'SIZE_A', 'COMP_B', 'SIZE_B', 'LEN_TOT', 'LEN_EFF', 'GAIN'
   
     openw, 1, info.dir_tmp + 'compconnect_tmp.csv'
     printf, 1, 'CCONN, COMP_A, SIZE_A, COMP_B, SIZE_B, LEN_TOT, LEN_EFF, GAIN '

     ;; calculate importance for these new links
     FOR il = 0, 9 DO BEGIN
       ;; each link in 'tenlinks' connects the two
       ;; components laidx and lbidx. They correspond to
       ;; linka and linkb in the image
       laidx = fix(strmid(tenlinks(il), 0, 1)) & linka = lcompidx(laidx - 1)
       lbidx = fix(strmid(tenlinks(il), 6, 1)) & linkb = lcompidx(lbidx - 1)

       ;; 1) calculate the location and length of the shortest path
       ;; between the two components
       ppa = lbl_comp EQ linka
       ppa = morph_distance(ppa, / background, neighbor = distnbr, / no_copy)
       ;; get the smallest distance within component B
       ppb = lbl_comp eq linkb & ppa = ppa * ppb & ppa = ppa + (ppa LT 0.5) * 10000.0
       xb = min(ppa, min_subscript) & loc_b = array_indices(image0,  min_subscript)

       ppb = morph_distance(ppb, / background, neighbor = distnbr, / no_copy)
       ppa = lbl_comp eq linka & ppb = ppb * ppa & ppb = ppb + (ppb LT 0.5) * 10000.0
       xa = min(ppb, min_subscript) & loc_a = array_indices(image0,  min_subscript)

       ;; insert shortest path loc_a -> loc_b into the map
       q1 = loc_b & q1 = float(q1 - round(loc_a))
       ps = (q1 GE 0) * 2 - 1 & q1 = q1 * ps  ;;sign of loc_b
       fi = q1[1] GT q1[0]
       x = lindgen(round(q1[fi] + 1)) & y = round((x * q1[1 - fi]) / q1[fi])
       x = round(loc_a[fi]) + x[0: * ] * ps[fi]
       y = round(loc_a[1 - fi]) + y[0: * ] * ps[1 - fi]
       IF fi EQ 1 THEN $
         shpath = transpose([[y], [x]]) ELSE shpath = transpose([[x], [y]])
       shpathlength = n_elements(x)

       ;;res = trace_conn_grid(loc_a, loc_b, lc = 1)
       ;; assign path pixels to black
       FOR i = 1, shpathlength - 2 DO image0(shpath(0, i), shpath(1, i)) = 103b

       ;; shpath starts in linka and ends in linkb
       ;; 2) find out if this path passes through other components
       pts = lbl_comp(shpath(0, 1:shpathlength - 2), shpath(1, 1:shpathlength - 2))
       ;; the full length not accountinmg for intermediate components
       tenlinkslength(0, il) = shpathlength - 2
       ;; the length accounting for components along this path
       tenlinkslength(1, il) = fix(total(pts eq 0))
       ;; test for and add intermediate components
       h = histogram(pts) & q = where(h GT 0) & intcomp = n_elements(q) GT 1
       ;; calculate importance for this new link:
       ;; pcnum is sum [ (core-areas per component)^2 ] but we take full component area here
       ;; remove the two individual areas from pcnum_orig
       pcnum = pcnum_orig - (h_comp_area(linka))^2 - (h_comp_area(linkb))^2
       ;; if intermediate components were encountered then remove
       ;; them as well
       IF intcomp EQ 1 THEN $
         FOR i = 1, n_elements(q) - 1 DO pcnum = pcnum - (h_comp_area(q(i)))^2
       ;; add the new combined linka <-> linkb area
       ;; to get the final new pcnum for the set when this new link is included
       aaa = h_comp_area(linka) + h_comp_area(linkb)
       IF intcomp EQ 1 THEN $
         FOR i = 1, n_elements(q) - 1 DO aaa = aaa + h_comp_area(q(i))
       pcnum = pcnum + (aaa)^2
       ;; note: pcnum is the one for the set with the new link added in. 
       ;; pcnum_orig is the original set without any new links
       
       ;; option a)%-increase in overall connectivity (pcnum)
       ;tenlinksimp(il) = (pcnum - pcnum_orig) / pcnum_orig * 100.0 
       
       ;; option b)%-increase in ECA (equivalent connected area
       ;ECA_orig = sqrt(pcnum_orig) & ECA_new = sqrt(pcnum)
       ;tenlinksimp(il) = (ECA_new - ECA_orig)/ECA_orig * 100.0 ;;% increase in ECA
       
       ;; option c)%-increase in DOC
       ECA_orig = sqrt(pcnum_orig) & ECA_new = sqrt(pcnum) & ECA_max = total(h_comp_area[1:*])
       doc_orig = ECA_orig/ECA_max*100.0
       doc = ECA_new/ECA_max*100.0
       gain = doc - doc_orig
       tenlinksimp(il) = gain
       
       ;; ECA_rel: normalised/relative ECA
       ;; ARH: amount of reachable habitat (%)
       ;; PRH: percentage of reachable habitat
       ; ECA_max = total(h_comp_area[1:*])
       ; ECA_rel = ECA/ECA_max * 100.0

  
       FOR i = 1, shpathlength - 2 DO nw_conns(shpath(0, i), shpath(1, i)) = tenlinksimp(il)
;       IF intcomp EQ 0 THEN BEGIN
;           row2 = 'NONE'           
;       ENDIF ELSE BEGIN
;           row2arr = strtrim(q(1: * ), 1) & row2nr = n_elements(row2arr) & row2 = row2arr[0]
;           if row2nr gt 1 then for i = 1,row2nr-1 do row2 = row2 + ' ' + row2arr[i]
;       ENDELSE
       rowstr = tenlinks(il) + ',' + strtrim(linka, 2) + ',' + strtrim(h_comp_area(linka), 2) + ',' + $
        strtrim(linkb, 2) + ',' + strtrim(h_comp_area(linkb), 2) + ',' + $
        strtrim(tenlinkslength(0, il), 2) + ',' + strtrim(tenlinkslength(1, il), 2) + ',' + $
        strtrim(tenlinksimp(il), 2) ;; + ',' + row2
        printf, 1, rowstr      

        ;; add output for xdisplayfile
        printf, 11, format = '(9(a17))',tenlinks(il), strtrim(linka, 2), strtrim(h_comp_area(linka), 2), + $
          strtrim(linkb, 2), strtrim(h_comp_area(linkb), 2), $
          strtrim(tenlinkslength(0, il), 2), strtrim(tenlinkslength(1, il), 2), $
          strtrim(tenlinksimp(il), 2)

     ENDFOR
     close, 1, 11
     IF ctqm GT 0 THEN image0[qm] = 129b & qm = 0
     print, 'CompConnect comp.time [sec]: ', systime( / sec) - time0

     xdisplayfile, statsfiletxt, title = 'Connectors between 5 largest NW Components', width=120, /grow

     ;; go back to original dimension to be shown in the display
     ;; store stuff in the info structure
     info.autostretch_id = 0
     * info.nw_ids = lbl_comp[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1]
     * info.nw_conns = nw_conns[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1]
     * info.process = image0[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1]
     lbl_comp = 0 & image0 = 0 & nw_conns = 0 & * info.fr_image = * info.process
     info.add_title = ' (Connectors between 5 largest NW Components)'

     ;; reset mspa
     info.is_mspa = 0 & info.is_fragm = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b
     info.do_mspa_stats_id = 0 & info.is_cost = 0

     ;; set is_nwconnect to active
     info.is_nwconnect = 1 & info.is_nw = 0 & info.is_cs22 = 0
   END

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;    N E T W O R K   A N A L Y S I S:   CS-INPUT
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   'nw_cs22':  BEGIN
      ;; get the extended fullres image of cores and bridges
      fn = info.dir_tmp + 'nwtmp.sav' & res = file_info(fn)
      IF res.exists NE 1b THEN BEGIN
         msg = 'Please first run: Image Analysis -> Network -> NW Components.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDIF
      restore, fn  ;; image, eew, sz
      lbl_bridgex = label_region(image0 EQ 2b, / all, / ulong)
      lbl_corex = label_region(image0 EQ 1b, / all, / ulong)
      nr_bridge = max(lbl_bridgex) & nr_core = max(lbl_corex)

      IF nr_bridge EQ 0 THEN BEGIN
        msg = 'Network without links.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF

      IF nr_core EQ 0 THEN BEGIN
        msg = 'Network without nodes.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF

      ;; print table of unique objects and their areas in pixels, bridge
      ;; area is not considered. These are the unique "nodes" = cores + bridges
      h_core = histogram(lbl_corex, / l64)
      dir_input = file_dirname(info.fname_input,/mark)

      ;; get MSPA params from the info structure
      tmp4conn = ['8', '4'] & c_FGconn = tmp4conn(1 - info.mspa_param1_id)
      c_size = info.mspa_size_current
      c_trans = strtrim(info.mspa_param3_id - 0, 2)
      c_intext = strtrim(info.mspa_param4_id - 0, 2)
      mspaext = '_' + c_FGconn + '_' + c_size + '_' + c_trans + '_' + c_intext
      fname = file_basename(info.orig_image_title)
      qq = strpos(fname,mspaext) & if qq lt 0 then fname = fname + mspaext
      cs_nodes_file = dir_input + fname + '_nodes_mspa.txt'
      openw, 1, cs_nodes_file
      ;;printf, 1, '         Object      Pixels'
      FOR i = 1l, nr_core DO printf, 1, strtrim(-i,2), h_core(i)
      FOR i = 1l, nr_bridge DO printf, 1, strtrim(i,2), '           0'
      close, 1

      ;; detect 8-connected neighboring different objects by looking in the
      ;; 8-con neighborhood of each bridge for unique core IDs
      ;; meaning: each bridge connects to which core IDs?
      se8 = replicate(1, 3, 3) ;; sel for 8-conn

      ;; dilate core into bridges to retrieve the edges of bridges
      image0 = dilate(lbl_corex, se8, / gray, / ulong) * (lbl_bridgex GT 0)
      ;; the bridgeedge coordinate in lbl_bridge is the label of the bridge
      ;; se8 on this coordinate contains the core it connects to
      qb = where(image0 GT 0, ct_b, /l64) 
      fn_tmp = info.dir_tmp + 'cs22_tmp.txt'
      openw, 1, fn_tmp
      FOR idx = 0l, ct_b - 1 DO BEGIN
         bridge = lbl_bridgex(qb(idx)) + nr_core
         xy = array_indices(image0, qb(idx))
         vals = lbl_corex[xy(0) - 1:xy(0) + 1, xy(1) - 1:xy(1) + 1]
         uvals = vals[uniq(vals, sort(vals))] & uvals = uvals[1: * ]
         FOR i = 0l, n_elements(uvals) - 1 DO printf, 1, strtrim(bridge,2), uvals(i)
      ENDFOR
      close, 1 &  image0 = 0

      ;; get the result and filter out duplicates
      res = lonarr(2, file_lines(fn_tmp))
      openr, 1, fn_tmp & readf, 1, res & close, 1 & file_delete, fn_tmp, / quiet
      cs_links_file = dir_input + fname + '_links_mspa.txt'

      openw, 1, cs_links_file
      FOR idx = 1l, nr_bridge DO BEGIN
         id = idx + nr_core & q = where(res(0, * ) EQ id, ct, /l64)
         IF ct GT 0 THEN BEGIN
            vals = res(1, q) & uvals = vals[uniq(vals, sort(vals))]
            FOR bb = 0l, n_elements(uvals) - 1 DO printf, 1, strtrim(idx,2), -uvals(bb), '     1'
         ENDIF
      ENDFOR
      close, 1

      msg = 'The input files for Conefor ' + string(10b) + $
            '(' + file_basename(cs_nodes_file) + ', ' + file_basename(cs_links_file) + $
            ')' + string(10b) + 'have been saved in the directory: ' + string(10b) + $
            dir_input + string(10b) + 'Returning...'
      res = dialog_message(msg, / information)

      ;; reset mspa and cs22
      info.is_mspa = 0 & info.is_fragm = 0 & info.is_contort = 0 & info.is_dist = 0 & info.is_influ = 0
      info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0 & info.selsubregion_id = 0 & info.is_cost = 0
      widget_control, info.w_selsubregion, set_value = 'Zoom Mode', / sensitive
      GOTO, fin
   END

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;             D I S T A N C E
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   'accounting':  BEGIN
     
     LM_Compliance, info.fname_input, * info.fr_image, 'fad', info.immaxsizeg, 1, result
     IF result EQ 0 THEN GOTO, fin  ;; invalid input

     msg = 'Calculating min/max object area, please wait...'
     progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title='Accounting')
     progressBar -> Start
     
     ;; assign the full resolution image
     im = * info.fr_image & sz=size(im,/dim)
    
     ;; set mspa_params to default
     info.mspa_param1_id = 1
     widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id, sensitive=0
     info.mspa_size_current = '1'
     widget_control, info.w_mspa_param2, set_value = ['x','1','2','3','4','5','6','7','8','9','10']
     widget_control, info.w_mspa_param2, set_combobox_select = 1
     info.mspa_param3_id = 1
     widget_control, info.w_mspa_param3, set_value = info.mspa_param3_id
     info.mspa_param4_id = 1
     widget_control, info.w_mspa_param4, set_value = info.mspa_param4_id
     
     ;; check if we have a geotiff image
     fname = info.fname_input 
     geotiff_log = '' ;; gdal geotiff-information
     if info.is_geotiff gt 0 then begin  ;; we have a geotiff image
       IF info.my_os EQ 'windows' THEN BEGIN
         cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalinfo -noct "' + fname + '"'
       ENDIF ELSE BEGIN
         if strlen(info.sysgdal) gt 0 then $
           cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + fname + '"' else $
           cmd = info.dir_fwtools + 'gdalinfo -noct "' + fname + '"'
       ENDELSE
       IF info.my_os EQ 'windows' THEN spawn, cmd, geotiff_log, / hide ELSE spawn, cmd, geotiff_log
     endif

     ;; test if pixel-resolution is available from gdal g_ps: gdal pixel size
     gdal = 'gdalinfo: no details on the pixel resolution.'
     IF (size(geotiff_log))[0] NE 0 THEN BEGIN
       gps = geotiff_log[WHERE(STRMATCH(geotiff_log, 'Pixel Size*', /FOLD_CASE) EQ 1)]
       gps = gps[0] & p =strlen(gps)
       if p gt 0 then gdal = 'gdalinfo: ' + gps
     ENDIF

     ;; define required pointers for FGobj
     cancel = ptr_new(1b)
     o_saveopt = ptr_new(0b)
     o_fgconn = ptr_new(1b) ;; fgconn
     o_pixres = ptr_new(25) ;; pixel resolution
     o_big3pink = ptr_new(0b) ;; big3pink switch: 0-no: do not show, 1-yes
     o_cl1 = ptr_new(5)
     o_cl2 = ptr_new(5)
     o_cl3 = ptr_new(5)
     o_cl4 = ptr_new(5)
     o_cl5 = ptr_new(5)
     widget_control, / hourglass
     
     ;; extend the image with background so label_region can do a flood-fill in the BG
     ;; we do this already here to get oba_max, needed for scaled_cl_arr
     ext=bytarr(sz[0]+10,sz[1]+10)
     ext[5:sz[0]+4,5:sz[1]+4]=im eq 2b & tot_area = total(ext,/double)
     cl = byte([103, 33, 65, 1, 9, 17]) ;; colors to be used for the 6 size classes
     cl_name = ['black', 'red', 'yellow', 'orange', 'brown', 'green']
     nw_ids = label_region(ext, all=1, / ulong) ;; use the default 8-conn here. Should the user select 4 then we need to redo nw_ids
     tot_ids = max(nw_ids) ;; total # of objects, the first one does not count because it is the background
     obj_area = histogram(nw_ids, reverse_indices = revind, / l64)
     oba_max = max(obj_area[1:*]) ;; neglect background and get the area of the largest object
     obj_area[0] = 9000000000000000000  ;; set BG to a high number so we can search for size classes in one statement
     oba_min = min(obj_area) ;; area of the smallest object
     oba_range = oba_max - oba_min  
          
     ;; scaled_cl_arr: thesholds based on the size range [1, max_object_area]
     scaled_cl_arr = strarr(6) & scaled_cl_arr[0] = 'X' 
     scaled_cl_arr[1:5] = strtrim(ulong64(oba_min + [0.001, 0.01, 0.1, 0.5, 0.9]*oba_range),2)      
     ;; area class arrary
     ;cl_arr = ['X', '50', '250', '1000', '5000', '20000']

     progressBar -> Destroy
     Obj_Destroy, progressBar
     ;; get the fgobj settings 
     pushd, info.dir_data    
     get_fgobj, o_saveopt = o_saveopt, o_fgconn = o_fgconn, o_pixres = o_pixres, o_big3pink = o_big3pink, scaled_cl_arr = scaled_cl_arr, oba_min = oba_min, $
       o_cl1 = o_cl1, o_cl2 = o_cl2, o_cl3 = o_cl3, o_cl4 = o_cl4, o_cl5 = o_cl5, $  
       gdal = gdal, cancel = cancel, saveopt = '0', Group_Leader = event.top  
     popd
     
     ;; check if cancel was selected then do nothing else apply the selected settings
     IF * cancel NE 0b THEN BEGIN
       ptr_free, cancel & cancel = 0b
       ptr_free, o_saveopt & o_saveopt = 0b
       ptr_free, o_fgconn & o_fgconn = 0b
       ptr_free, o_pixres & o_pixres = 0b
       ptr_free, o_big3pink & o_big3pink = 0b
       ptr_free, o_cl1 & o_cl1 = 0b
       ptr_free, o_cl2 & o_cl2 = 0b
       ptr_free, o_cl3 & o_cl3 = 0b
       ptr_free, o_cl4 & o_cl4 = 0b
       ptr_free, o_cl5 & o_cl5 = 0b       
       GOTO, fin
     ENDIF
     
     ;; assign settings
     conn8 = (* o_fgconn) eq '8' & conn8_str = * o_fgconn   ;; must be 1 for 8-conn   
     info.mspa_param1_id = conn8
     widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id   
     pixres = float(* o_pixres) & pixres_str = * o_pixres
     big3pink = (* o_big3pink) & big3pink_str = * o_big3pink
     cl1 = ulong64(* o_cl1) & cl1_str = * o_cl1
     cl2 = ulong64(* o_cl2) & cl2_str = * o_cl2
     cl3 = ulong64(* o_cl3) & cl3_str = * o_cl3
     cl4 = ulong64(* o_cl4) & cl4_str = * o_cl4
     cl5 = ulong64(* o_cl5) & cl5_str = * o_cl5
     ;; free and delete the temporary pointers
     ptr_free, cancel & cancel = 0b
     ptr_free, o_fgconn & o_fgconn = 0b
     ptr_free, o_pixres & o_pixres = 0b
     ptr_free, o_big3pink & o_big3pink = 0b
     ptr_free, o_cl1 & o_cl1 = 0b
     ptr_free, o_cl2 & o_cl2 = 0b
     ptr_free, o_cl3 & o_cl3 = 0b
     ptr_free, o_cl4 & o_cl4 = 0b
     ptr_free, o_cl5 & o_cl5 = 0b          
     
  
     ;; 2) if in zoom mode, quit zoom mode
     widget_control, info.w_selsubregion, get_value = ssr
     IF ssr EQ 'Quit Zoom' THEN BEGIN
     ;;IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0       
     ENDIF
            
     ;; ext2 = nw_ids in original size
     ;;====================================================================================
     ;; check if user selected the non-default 4-connectivity, then redo nw_ids
     if conn8 eq 0 then begin
       nw_ids = label_region(ext, all=conn8, / ulong) ;; use the default 8-conn here. Should the user select 4 then we need to redo nw_ids
       tot_ids = max(nw_ids) ;; total # of objects, the first one does not count because it is the background
       obj_area = histogram(nw_ids, reverse_indices = revind, / l64)
       oba_max = max(obj_area[1:*])
       obj_area[0] = 9000000000000000000  ;; set BG to a high number so we can search for size classes in one statement     
     endif
     ext2 = long(nw_ids[5:sz[0]+4,5:sz[1]+4]) 
     
     ;;====================================================================================
     ;; statistical summary of nw_id image
     ;;====================================================================================
     cat = [cl1, cl2, cl3, cl4, cl5] ;; the defined size category thresholds
     cat_idlast = 0 & cat_arealast = 0
     q = where(cat GE 1, /l64)
     cat = cat[q] & cat = cat(uniq(cat))  ;; remove potential double entries
     nr_cat = n_elements(cat)
     cat_ID = cat*0    ;; # of objects in each cateory
     cat_area = cat*0   ;; total area of objects in each cateory
     oba = histogram(ext2, / l64) ;; oba has only the valid objects !!!
     oba = oba[1:*] ;; remove the background

     ;; first category
     q = where(oba LE cat[0], ct, /l64)
     if ct gt 0 then begin
       cat_id[0] = ct & cat_area[0] = total(oba[q],/double)
     endif
     ;; other categories
     for idx = 1, nr_cat do begin
       if idx lt nr_cat then begin ;; not the last category
         q = where(oba GT cat[idx-1] and oba LE cat[idx], ct, /l64)
         if ct gt 0 then begin
           cat_id[idx] = ct & cat_area[idx] = total(oba[q],/double)
         endif
       endif else begin ;; the last category
         q = where(oba GT cat[idx-1], ct, /l64)
         if ct gt 0 then begin
           cat_idlast = ct & cat_arealast = ulong64(total(oba[q],/double))
         endif
       endelse
     endfor    
        
     ;; write txt summary output
     z = info.dir_tmp + 'acc.txt'
     hec = ((pixres)^2) / 10000.0
     acr = hec * 2.47105

     openw,1, z
     printf, 1, 'Accounting size classes result using: '
     printf, 1, info.title + info.add_title
     printf, 1, 'Base settings: ' + conn8_str + '-connectivity, pixel resolution: ' + pixres_str + ' [m]'
     printf, 1, 'Conversion factor: pixel_to_hectare: ' + strtrim(hec,2) + ', ' + 'pixel_to_acres: ' + strtrim(acr,2)
     printf, 1, '--------------------------------------------------------------------------------------------- '
     printf, 1, ' Size class 1: [1 - ' + strtrim(cat[0],2) + '] pixels; color: ' + cl_name[0]
     printf, 1, '          # Objects      Area[pixels]     % of all objects  % of total FGarea'
     printf, 1, format='(4(a18))', strtrim(cat_id[0],2), strtrim(cat_area[0],2), strtrim(cat_id[0]*100.0/tot_ids,2), strtrim(cat_area[0]*100.0/tot_area,2)
     printf, 1, '--------------------------------------------------------------------------------------------- '
     if nr_cat ge 2 then begin
       printf, 1, ' Size class 2: [' + strtrim(cat[0]+1,2) + ' - ' + strtrim(cat[1],2) + '] pixels; color: ' + cl_name[1]
       printf, 1, '          # Objects      Area[pixels]     % of all objects  % of total FGarea'
       printf, 1, format='(4(a18))', strtrim(cat_id[1],2), strtrim(cat_area[1],2), strtrim(cat_id[1]*100.0/tot_ids,2), strtrim(cat_area[1]*100.0/tot_area,2)
       printf, 1, '--------------------------------------------------------------------------------------------- '
     endif
     if nr_cat ge 3 then begin
       printf, 1, ' Size class 3: [' + strtrim(cat[1]+1,2) + ' - ' + strtrim(cat[2],2) + '] pixels; color: ' + cl_name[2]
       printf, 1, '          # Objects      Area[pixels]     % of all objects  % of total FGarea'
       printf, 1, format='(4(a18))', strtrim(cat_id[2],2), strtrim(cat_area[2],2), strtrim(cat_id[2]*100.0/tot_ids,2), strtrim(cat_area[2]*100.0/tot_area,2)
       printf, 1, '--------------------------------------------------------------------------------------------- '
     endif
     if nr_cat ge 4 then begin
       printf, 1, ' Size class 4: [' + strtrim(cat[2]+1,2) + ' - ' + strtrim(cat[3],2) + '] pixels; color: ' + cl_name[3]
       printf, 1, '          # Objects      Area[pixels]     % of all objects  % of total FGarea'
       printf, 1, format='(4(a18))', strtrim(cat_id[3],2), strtrim(cat_area[3],2), strtrim(cat_id[3]*100.0/tot_ids,2), strtrim(cat_area[3]*100.0/tot_area,2)
       printf, 1, '--------------------------------------------------------------------------------------------- '
     endif
     if nr_cat ge 5 then begin
       printf, 1, ' Size class 5: [' + strtrim(cat[3]+1,2) + ' - ' + strtrim(cat[4],2) + '] pixels; color: ' + cl_name[4]
       printf, 1, '          # Objects      Area[pixels]     % of all objects  % of total FGarea'
       printf, 1, format='(4(a18))', strtrim(cat_id[4],2), strtrim(cat_area[4],2), strtrim(cat_id[4]*100.0/tot_ids,2), strtrim(cat_area[4]*100.0/tot_area,2)
       printf, 1, '--------------------------------------------------------------------------------------------- '
     endif
     ;; the last class
     if cat_idlast gt 0 then begin
       printf, 1, ' Size class ' + strtrim(nr_cat + 1,2) + ': [' + strtrim(cat[nr_cat-1]+1,2) + ' -> ] pixels; color: ' + cl_name[nr_cat]
       printf, 1, '          # Objects      Area[pixels]     % of all objects  % of total FGarea'
       printf, 1, format='(4(a18))', strtrim(cat_idlast,2), strtrim(cat_arealast,2), strtrim(cat_idlast*100.0/tot_ids,2), strtrim(cat_arealast*100.0/tot_area,2)
       printf, 1, '--------------------------------------------------------------------------------------------- '
     endif
     printf, 1, '--------------------------------------------------------------------------------------------- '
     printf, 1, 'Sum of all classes:'
     printf, 1, '          # Objects      Area[pixels]     % of all objects  % of total FGarea'
     allid = ulong64(total(cat_id,/double) + cat_idlast)
     allarea = ulong64(total(cat_area,/double) + cat_arealast)
     ss = moment(oba, sdev=sdev, mean=aps) & medps = long64(median(oba))
     printf, 1, format='(4(a18))', strtrim(allid,2), strtrim(allarea,2), strtrim(allid*100.0/tot_ids,2), strtrim(allarea*100.0/tot_area,2)
     printf, 1, ' '
     printf, 1, format='(a20,a16)', 'Median Patch Size: ', strtrim(medps,2)
     printf, 1, format='(a20,a16)', 'Average Patch Size: ', strtrim(aps,2)
     printf, 1, format='(a20,a16)', 'Standard Deviation: ', strtrim(sdev,2)
     printf, 1, ' '
     ;;====================================================================================
     ;; ext3 = nw_area per ID in extended size
     ;;====================================================================================
     ext3=long(0)*temporary(nw_ids)           
     ;; assign object area to object polygon
     nr_obj = n_elements(obj_area)
     FOR i = 1l, nr_obj - 1 DO ext3[revind[revind[i]:revind[i + 1] - 1]] = obj_area(i)
     if nr_obj gt 3 then save, obj_area, filename = info.dir_tmp + 'obj_area.sav'
      
     ;; ext = viewport image, assign colors for up to 6 area classes 
     for i_class = 0, nr_cat do begin
       if i_class eq nr_cat then begin
         qsmall = where(obj_area NE 9000000000000000000,c_small, /l64)
       endif else begin
         qsmall = where(obj_area LE cat(i_class),c_small, /l64) ;; where the histogram area is in area class
       endelse             
         if c_small gt 0 then begin
           for id = 0, c_small-1 do begin
             il = qsmall[id] & q = revind[revind[il]:revind[il+1]-1] & ext[q] = cl(i_class)
           endfor
           ;; set qsmall to a high number
           if i_class eq nr_cat then obj_area = 0 else obj_area[qsmall] = 9000000000000000000
         endif     
     endfor
     
     ;; show the 3 largest objects in pink (80b)
     if nr_obj gt 3 and (big3pink eq 1) then begin
       restore, info.dir_tmp + 'obj_area.sav'
       oba_max1 = oba_max & id_max1 = 0 & oba_max2 = 0 & id_max2 = 0 & oba_max3 = 0 & id_max3 = 0
       ;; the biggest object
       qsmall = where(obj_area eq oba_max1, c_small, /l64)
       if c_small gt 0 then begin
         for id = 0, c_small-1 do begin
           il = qsmall[id] & q = revind[revind[il]:revind[il+1]-1] & ext[q] = 80b
         endfor
         ;; set qsmall to a high number
         obj_area[qsmall] = 9000000000000000000
         id_max1 = qsmall
         printf, 1, 'Three largest object IDs and area[pixels]; color: pink'
         printf, 1, 'These 3 objects overlay objects listed above' 
         printf, 1, format='(a3,a18, a18)', '1) ', strtrim(id_max1,2), strtrim(oba_max1,2)
       endif
       ;; the second biggest object
       oba_max2 = max((obj_area lt 9000000000000000000)*obj_area)
       qsmall = where(obj_area eq oba_max2, c_small, /l64)
       if c_small gt 0 then begin
         for id = 0, c_small-1 do begin
           il = qsmall[id] & q = revind[revind[il]:revind[il+1]-1] & ext[q] = 80b
         endfor
         ;; set qsmall to a high number
         obj_area[qsmall] = 9000000000000000000
         id_max2 = qsmall
         printf, 1, format='(a3,a18, a18)', '2) ', strtrim(id_max2,2), strtrim(oba_max2,2)
       endif
       ;; the third biggest object
       oba_max3 = max((obj_area lt 9000000000000000000)*obj_area)
       qsmall = where(obj_area eq oba_max3, c_small, /l64)
       if c_small gt 0 then begin
         for id = 0, c_small-1 do begin
           il = qsmall[id] & q = revind[revind[il]:revind[il+1]-1] & ext[q] = 80b
         endfor
         ;; set qsmall to a high number
         obj_area[qsmall] = 9000000000000000000
         id_max3 = qsmall
         printf, 1, format='(a3,a18, a18)', '3) ', strtrim(id_max3,2), strtrim(oba_max3,2)
       endif
     endif else begin
       printf,1, 'Largest object:     ', strtrim(oba_max, 2)
     endelse     
     ;; close the txt statistics file
     close, 1
     
     ;; write csv summary output
     fx = info.dir_tmp + 'acc.csv' & file_delete,fx,/allow_nonexistent,/quiet
     openw,12,fx
     printf,12, 'Accounting size classes result using: ' + info.title + info.add_title + ' (more info in: acc.txt), , , , , ,'
     printf,12, ', Size class [pixels], Color, # Objects, Area[pixels], % of all objects, % of total FGarea'
     printf,12,  ', 1: [1 - ' + strtrim(cat[0],2) + '],' + cl_name[0] + ', ' + $
       strtrim(cat_id[0],2) + ', ' + strtrim(cat_area[0],2) + ', ' + $
       strtrim(cat_id[0]*100.0/tot_ids, 2) + ', ' + strtrim(cat_area[0]*100.0/tot_area, 2)
     if nr_cat ge 2 then printf,12, ', 2: [' + strtrim(cat[0]+1,2) + ' - ' + strtrim(cat[1],2) + '],' + $
       cl_name[1] + ', ' + strtrim(cat_id[1], 2) + ', ' + strtrim(cat_area[1],2) + ', ' + $
       strtrim(cat_id[1]*100.0/tot_ids, 2) + ', ' + strtrim(cat_area[1]*100.0/tot_area, 2)
     if nr_cat ge 3 then printf,12, ', 3: [' + strtrim(cat[1]+1,2) + ' - ' + strtrim(cat[2],2) + '], ' + $
       cl_name[2] + ', ' + strtrim(cat_id[2], 2) + ', '  + strtrim(cat_area[2],2) + ', ' + $
       strtrim(cat_id[2]*100.0/tot_ids, 2) + ', ' + strtrim(cat_area[2]*100.0/tot_area, 2)
     if nr_cat ge 4 then printf,12, ', 4: [' + strtrim(cat[2]+1,2) + ' - ' + strtrim(cat[3],2) + '],' + $
       cl_name[3] + ', ' + strtrim(cat_id[3], 2) + ', ' + strtrim(cat_area[3],2) + ', ' + $
       strtrim(cat_id[3]*100.0/tot_ids, 2) + ', ' + strtrim(cat_area[3]*100.0/tot_area, 2)
     if nr_cat ge 5 then printf,12, ', 5: [' + strtrim(cat[3]+1,2) + ' - ' + strtrim(cat[4],2) + '], ' + $
       cl_name[4] + ', ' + strtrim(cat_id[4], 2) + ', ' + strtrim(cat_area[4],2) + ', ' + $
       strtrim(cat_id[4]*100.0/tot_ids, 2) + ', ' + strtrim(cat_area[4]*100.0/tot_area, 2)
     ;; the last class
     if cat_idlast gt 0 then begin
       printf,12, ', ' + strtrim(nr_cat + 1,2) + ': [' + strtrim(cat[nr_cat-1]+1,2) + ' -> ], ' + $
         cl_name[nr_cat] + ', ' + strtrim(cat_idlast, 2) + ', ' + strtrim(cat_arealast,2) + ', ' + $
         strtrim(cat_idlast*100.0/tot_ids, 2) + ', ' + strtrim(cat_arealast*100.0/tot_area, 2)
     endif
     close,12
         
     ;; cut back to original
     ext = temporary(ext[5:sz[0]+4,5:sz[1]+4])
     ext3 = temporary(ext3[5:sz[0]+4,5:sz[1]+4])
          
     ;; put back missing
     q=where(im eq 0b, ct_q, /l64) 
     IF ct_q GT 0 THEN BEGIN
       ext(q) = 129b ; image in viewport
       ext2(q)= -1   ; id of object
       ext3(q)= -1   ; area of object
     ENDIF
     q = where(im eq 3b, ct_q, /l64) ;; water bodies - blue
     IF ct_q GT 0 THEN BEGIN
       ext(q) = 105b ; image in viewport
       ext2(q)= -3   ; id of object
       ext3(q)= -3   ; area of object
     ENDIF
     q = where(im eq 4b, ct_q, /l64) ;; special BG - pale-blue
     IF ct_q GT 0 THEN BEGIN
       ext(q) = 176b ; image in viewport
       ext2(q)= -4   ; id of object
       ext3(q)= -4   ; area of object
     ENDIF
     im = 0
     
     ;; store stuff in the info structure
     * info.nw_conns = temporary(ext3)
     * info.nw_ids = temporary(ext2)
     * info.process = temporary(ext)
     * info.fr_image = * info.process 

     ;; restore the the colors-on table
     restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b
  
     ;; reset mspa etc
     info.is_mspa = 0 & info.is_fragm = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b
     info.do_mspa_stats_id = 0 & info.is_cs22 = 0 & info.is_nw = 0 & info.do_label_groups_id = 0 & info.is_cost = 0
     info.ctbl = - 1 & info.disp_colors_id = 3 & info.autostretch_id = 0 & info.is_dist = 0 & info.is_influ = 2
     info.add_title = ' (Accounting: ' + conn8_str + '-conn. objects: ' + strtrim(tot_ids,2) + ')'

     ;; show the statistics
     fx = 'acc.txt'
     pushd, info.dir_tmp & xdisplayfile, fx, height=file_lines(fx)+1 & popd
   END

   ;;*****************************************************************************************************

   'batch_accounting': BEGIN   
     ;; select the images to be processed     
     tit = 'Select (Geo-)Tif-files'
     im_file = $
       dialog_pickfile(Title = tit, get_path = path2file, $
       path = info.dir_data, default_extension = 'tif', / fix_filter, $
       / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
     IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
     
     ;; test that the directory of the selected files has no sub-directories
     ;; this will also ensure no output file is opened in excel or thelike
     pushd, path2file
     list = file_search() & nl = n_elements(list) & nr_dir = 0
     for idx = 0, nl-1 do begin
       q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
     endfor
     IF nr_dir GT 0 THEN BEGIN
       msg = 'The directory of your Batch Accounting input files contains sub-directories.'  +  string(10b) +  string(10b) + $
         'Please set up a new directory having Batch Accounting input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     popd
     
     ;; test that we can write into the parent directory or if it exists already
     batch_type = 'batch_ACC' ;;'batch_Accounting'
     dd = file_dirname(im_file[0], / mark_directory)
     dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
     res = file_test(dir_batch, /directory, /write)
     if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
       res = dialog_message(msg,/question)
       If res eq 'No' then goto, fin
       ;; empty it
       pushd, dir_batch
         list = file_search() & nl = n_elements(list)
         if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd       
     endif else begin ;; does not exist yet, create it
       file_mkdir, dir_batch
     endelse

     ;; files are now selected, reset the GUI
     ;;========================================================================
     ;; reset the front image and block any events
     ;;========================================================================
     title = 'Accounting Batch Processing'
     goto, resetfront

     backto_batch_accounting:
     desc = 'GTB_ACC, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
     ;; start the GUI
     ;; define required pointers for FGobj
     cancel = ptr_new(1b)
     o_saveopt = ptr_new(0b)
     o_fgconn = ptr_new(1b) ;; fgconn
     o_pixres = ptr_new(25) ;; pixel resolution
     o_big3pink = ptr_new(0b) ;; big3pink switch: 0-no: do not show, 1-yes
     o_cl1 = ptr_new(5)
     o_cl2 = ptr_new(5)
     o_cl3 = ptr_new(5)
     o_cl4 = ptr_new(5)
     o_cl5 = ptr_new(5)
     
     scaled_cl_arr = ['X', '50', '250', '1000', '5000', '20000'] & oba_min = 1
     ;; get the fgobj settings
     pushd, info.dir_data
     get_fgobj, o_saveopt = o_saveopt, o_fgconn = o_fgconn, o_pixres = o_pixres, o_big3pink = o_big3pink, scaled_cl_arr = scaled_cl_arr, oba_min = oba_min, $
       o_cl1 = o_cl1, o_cl2 = o_cl2, o_cl3 = o_cl3, o_cl4 = o_cl4, o_cl5 = o_cl5, $
       gdal = gdal, title = title, cancel = cancel, saveopt = '1', Group_Leader = event.top
     popd
     ;; check if cancel was selected then do nothing else apply the selected settings
     IF * cancel NE 0b THEN BEGIN
       ptr_free, cancel & cancel = 0b
       ptr_free, o_saveopt & o_saveopt =0b
       ptr_free, o_fgconn & o_fgconn = 0b
       ptr_free, o_pixres & o_pixres = 0b
       ptr_free, o_big3pink & o_big3pink = 0b
       ptr_free, o_cl1 & o_cl1 = 0b
       ptr_free, o_cl2 & o_cl2 = 0b
       ptr_free, o_cl3 & o_cl3 = 0b
       ptr_free, o_cl4 & o_cl4 = 0b
       ptr_free, o_cl5 & o_cl5 = 0b
       GOTO, fin
     ENDIF

     ;; assign settings
     saveopt = (* o_saveopt)
     conn8 = (* o_fgconn) eq '8' & conn8_str = * o_fgconn   ;; must be 1 for 8-conn
     pixres = float(* o_pixres) & pixres_str = * o_pixres
     big3pink = (* o_big3pink) & big3pink_str = * o_big3pink
     cl1 = ulong64(* o_cl1) & cl1_str = * o_cl1
     cl2 = ulong64(* o_cl2) & cl2_str = * o_cl2
     cl3 = ulong64(* o_cl3) & cl3_str = * o_cl3
     cl4 = ulong64(* o_cl4) & cl4_str = * o_cl4
     cl5 = ulong64(* o_cl5) & cl5_str = * o_cl5
     ;; free and delete the temporary pointers
     ptr_free, cancel & cancel = 0b
     ptr_free, o_saveopt & o_saveopt =0b
     ptr_free, o_fgconn & o_fgconn = 0b
     ptr_free, o_pixres & o_pixres = 0b
     ptr_free, o_big3pink & o_big3pink = 0b
     ptr_free, o_cl1 & o_cl1 = 0b
     ptr_free, o_cl2 & o_cl2 = 0b
     ptr_free, o_cl3 & o_cl3 = 0b
     ptr_free, o_cl4 & o_cl4 = 0b
     ptr_free, o_cl5 & o_cl5 = 0b    
        
     ;; do the loop processing now
     ;;==========================================================================================
     ;; validate and process the images in a loop
     fn_logfile = dir_batch + batch_type + '.log'
     nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
     openw, 9, fn_logfile
     printf, 9, 'Accounting batch processing logfile: ', systime()
     printf, 9, 'Number of files to be processed: ', nr_im_files
     printf, 9, '==============================================='
     close, 9

     msg = 'Processing selected images for accounting, please wait...'
     progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
     progressBar -> Start


     FOR fidx = 0, nr_im_files - 1 DO BEGIN
       counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
       ;; validate the input, if not skip it without message
       IF progressBar -> CheckCancel() THEN BEGIN
         res = Dialog_Message('Batch-processing cancelled by user.')
         openw, 9, fn_logfile, /append
         printf, 9, 'Batch-processing cancelled by user.'
         close, 9
         progressBar -> Destroy
         Obj_Destroy, progressBar
         tvlct, rini, gini, bini
         GOTO, fin
       ENDIF

       input = im_file(fidx)
       res = strpos(input,' ') ge 0
       IF res EQ 1 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid  input (empty space in directory path or input filename): ', input
         close, 9
         GOTO, skip_batch_acc  ;; invalid input
       ENDIF

       type = '' & res = query_image(input, type=type)
       IF type NE 'TIFF' THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid  input (not a TIFF image): ', input
         close, 9
         GOTO, skip_batch_acc  ;; invalid input
       ENDIF


       res = query_tiff(input, geotiff = geotiffinfo)
       IF res EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid  input file: ', input
         close, 9
         GOTO, skip_batch_acc  ;; invalid input
       ENDIF
       is_geotiff = (size(geotiffinfo))[0]

       im = read_tiff(input)  ;; read and check it
       sz = size(im,/dim) & xdim = sz[0] & ydim = sz[1] & imgminsize=(xdim<ydim)
       ;; in batch mode we can process larger images compared to the GUI
       LM_Compliance, input, im, 'fad', info.immaxsizeg * 1000, 0, result    
       IF result EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid  input file: ', input
         close, 9
         GOTO, skip_batch_acc  ;; invalid input
       ENDIF

       ;; now all is ok for processing
       ;;===========================================================================
       time0 = systime( / sec)
       ;; restore the the colors-on table
       restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b

       widget_control, / hourglass
       ;; rotate the image to be compliant with Guidos results!
       im = rotate(im,7)
       
       ;; extend the image with background so label_region can do a flood-fill in the BG
       ext = bytarr(sz[0]+10,sz[1]+10)
       ext[5:sz[0]+4,5:sz[1]+4]=im eq 2b & tot_area = total(ext)
       cl = byte([103, 33, 65, 1, 9, 17]) ;; colors to be used for the 6 size classes
       cl_name = ['black', 'red', 'yellow', 'orange', 'brown', 'green']
       nw_ids = label_region(ext, all=conn8, / ulong)
       tot_ids = max(nw_ids) ;; total # of objects, the first one does not count because it is the background
       obj_area = histogram(nw_ids, reverse_indices = revind, / l64)
       oba_max = max(obj_area[1:*])
       obj_area[0] = 9000000000000000000  ;; set BG to a high number so we can search for size classes in one statement
       
       ;; ext2 = nw_ids in original size
       ;;====================================================================================
       ext2 = long(nw_ids[5:sz[0]+4,5:sz[1]+4])

       ;;====================================================================================
       ;; statistical summary of nw_id image
       ;;====================================================================================
       cat = [cl1, cl2, cl3, cl4, cl5] ;; the defined size category thresholds
       cat_idlast = 0 & cat_arealast = 0
       q = where(cat GE 1, /l64)
       cat = cat[q] & cat = cat(uniq(cat))  ;; remove potential double entries
       nr_cat = n_elements(cat)
       cat_ID = cat*0    ;; # of objects in each cateory
       cat_area = cat*0   ;; total area of objects in each cateory
       oba = histogram(ext2, / l64) ;; oba has only the valid objects !!!
       oba = oba[1:*] ;; remove the background

       ;; first category
       q = where(oba LE cat[0], ct, /l64)
       if ct gt 0 then begin
         cat_id[0] = ct & cat_area[0] = total(oba[q],/double)
       endif
       ;; other categories
       for idx = 1, nr_cat do begin
         if idx lt nr_cat then begin ;; not the last category
           q = where(oba GT cat[idx-1] and oba LE cat[idx], ct, /l64)
           if ct gt 0 then begin
             cat_id[idx] = ct & cat_area[idx] = total(oba[q],/double)
           endif
         endif else begin ;; the last category
           q = where(oba GT cat[idx-1], ct, /l64)
           if ct gt 0 then begin
             cat_idlast = ct & cat_arealast = ulong64(total(oba[q],/double))
           endif
         endelse
       endfor

       z = info.dir_tmp + 'acc.txt'
       hec = ((pixres)^2) / 10000.0
       acr = hec * 2.47105

       openw,1, z
       printf, 1, 'Accounting size classes result using: '
       printf, 1, input
       printf, 1, 'Base settings: ' + conn8_str + '-connectivity, pixel resolution: ' + pixres_str + ' [m]'
       printf, 1, 'Conversion factor: pixel_to_hectare: ' + strtrim(hec,2) + ', ' + 'pixel_to_acres: ' + strtrim(acr,2)
       printf, 1, '--------------------------------------------------------------------------------------------- '
       printf, 1, ' Size class 1: [1 - ' + strtrim(cat[0],2) + '] pixels; color: ' + cl_name[0]
       printf, 1, '          # Objects      Area[pixels]     % of all objects  % of total FGarea'
       printf, 1, format='(4(a18))', strtrim(cat_id[0],2), strtrim(cat_area[0],2), strtrim(cat_id[0]*100.0/tot_ids,2), strtrim(cat_area[0]*100.0/tot_area,2)
       printf, 1, '--------------------------------------------------------------------------------------------- '
       if nr_cat ge 2 then begin
         printf, 1, ' Size class 2: [' + strtrim(cat[0]+1,2) + ' - ' + strtrim(cat[1],2) + '] pixels; color: ' + cl_name[1]
         printf, 1, '          # Objects      Area[pixels]     % of all objects  % of total FGarea'
         printf, 1, format='(4(a18))', strtrim(cat_id[1],2), strtrim(cat_area[1],2), strtrim(cat_id[1]*100.0/tot_ids,2), strtrim(cat_area[1]*100.0/tot_area,2)
         printf, 1, '--------------------------------------------------------------------------------------------- '
       endif
       if nr_cat ge 3 then begin
         printf, 1, ' Size class 3: [' + strtrim(cat[1]+1,2) + ' - ' + strtrim(cat[2],2) + '] pixels; color: ' + cl_name[2]
         printf, 1, '          # Objects      Area[pixels]     % of all objects  % of total FGarea'
         printf, 1, format='(4(a18))', strtrim(cat_id[2],2), strtrim(cat_area[2],2), strtrim(cat_id[2]*100.0/tot_ids,2), strtrim(cat_area[2]*100.0/tot_area,2)
         printf, 1, '--------------------------------------------------------------------------------------------- '
       endif
       if nr_cat ge 4 then begin
         printf, 1, ' Size class 4: [' + strtrim(cat[2]+1,2) + ' - ' + strtrim(cat[3],2) + '] pixels; color: ' + cl_name[3]
         printf, 1, '          # Objects      Area[pixels]     % of all objects  % of total FGarea'
         printf, 1, format='(4(a18))', strtrim(cat_id[3],2), strtrim(cat_area[3],2), strtrim(cat_id[3]*100.0/tot_ids,2), strtrim(cat_area[3]*100.0/tot_area,2)
         printf, 1, '--------------------------------------------------------------------------------------------- '
       endif
       if nr_cat ge 5 then begin
         printf, 1, ' Size class 5: [' + strtrim(cat[3]+1,2) + ' - ' + strtrim(cat[4],2) + '] pixels; color: ' + cl_name[4]
         printf, 1, '          # Objects      Area[pixels]     % of all objects  % of total FGarea'
         printf, 1, format='(4(a18))', strtrim(cat_id[4],2), strtrim(cat_area[4],2), strtrim(cat_id[4]*100.0/tot_ids,2), strtrim(cat_area[4]*100.0/tot_area,2)
         printf, 1, '--------------------------------------------------------------------------------------------- '
       endif
       ;; the last class
       if cat_idlast gt 0 then begin
         printf, 1, ' Size class ' + strtrim(nr_cat + 1,2) + ': [' + strtrim(cat[nr_cat-1]+1,2) + ' -> ] pixels; color: ' + cl_name[nr_cat]
         printf, 1, '          # Objects      Area[pixels]     % of all objects  % of total FGarea'
         printf, 1, format='(4(a18))', strtrim(cat_idlast,2), strtrim(cat_arealast,2), strtrim(cat_idlast*100.0/tot_ids,2), strtrim(cat_arealast*100.0/tot_area,2)
         printf, 1, '--------------------------------------------------------------------------------------------- '
       endif
       printf, 1, '--------------------------------------------------------------------------------------------- '
       printf, 1, 'Sum of all classes:'
       printf, 1, '          # Objects      Area[pixels]     % of all objects  % of total FGarea'
       allid = ulong64(total(cat_id,/double) + cat_idlast)
       allarea = ulong64(total(cat_area,/double) + cat_arealast)
       ss = moment(oba, sdev=sdev, mean=aps) & medps = long64(median(oba))
       printf, 1, format='(4(a18))', strtrim(allid,2), strtrim(allarea,2), strtrim(allid*100.0/tot_ids,2), strtrim(allarea*100.0/tot_area,2)
       printf, 1, ' '
       printf, 1, format='(a20,a16)', 'Median Patch Size: ', strtrim(medps,2)
       printf, 1, format='(a20,a16)', 'Average Patch Size: ', strtrim(aps,2)
       printf, 1, format='(a20,a16)', 'Standard Deviation: ', strtrim(sdev,2)
       printf, 1, ' '
       ;;====================================================================================
       ;; ext3 = nw_area per ID in extended size
       ;;====================================================================================
       ext3=long(0)*temporary(nw_ids)
       ;; assign object area to object polygon
       nr_obj = n_elements(obj_area)
       FOR i = 1l, nr_obj - 1 DO ext3[revind[revind[i]:revind[i + 1] - 1]] = obj_area(i)
       if nr_obj gt 3 then save, obj_area, filename = info.dir_tmp + 'obj_area.sav'

       ;; ext = viewport image, assign colors for up to 6 area classes
       for i_class = 0, nr_cat do begin
         if i_class eq nr_cat then begin
           qsmall = where(obj_area NE 9000000000000000000,c_small, /l64)
         endif else begin
           qsmall = where(obj_area LE cat(i_class),c_small, /l64) ;; where the histogram area is in area class
         endelse
         if c_small gt 0 then begin
           for id = 0, c_small-1 do begin
             il = qsmall[id] & q = revind[revind[il]:revind[il+1]-1] & ext[q] = cl(i_class)
           endfor
           ;; set qsmall to a high number
           if i_class eq nr_cat then obj_area = 0 else obj_area[qsmall] = 9000000000000000000
         endif
       endfor
       
       ;; show the 3 largest objects in pink (80b)
       if nr_obj gt 3 and (big3pink eq 1) then begin
         restore, info.dir_tmp + 'obj_area.sav'
         oba_max1 = oba_max & id_max1 = 0 & oba_max2 = 0 & id_max2 = 0 & oba_max3 = 0 & id_max3 = 0
         ;; the biggest object
         qsmall = where(obj_area eq oba_max1, c_small, /l64)
         if c_small gt 0 then begin
           for id = 0, c_small-1 do begin
             il = qsmall[id] & q = revind[revind[il]:revind[il+1]-1] & ext[q] = 80b
           endfor
           ;; set qsmall to a high number
           obj_area[qsmall] = 9000000000000000000
           id_max1 = qsmall
           printf, 1, 'Three largest object IDs and area[pixels]; color: pink'
           printf, 1, 'These 3 objects overlay objects listed above'
           printf, 1, format='(a3,a18, a18)', '1) ', strtrim(id_max1,2), strtrim(oba_max1,2)
         endif
         ;; the second biggest object
         oba_max2 = max((obj_area lt 9000000000000000000)*obj_area)
         qsmall = where(obj_area eq oba_max2, c_small, /l64)
         if c_small gt 0 then begin
           for id = 0, c_small-1 do begin
             il = qsmall[id] & q = revind[revind[il]:revind[il+1]-1] & ext[q] = 80b
           endfor
           ;; set qsmall to a high number
           obj_area[qsmall] = 9000000000000000000
           id_max2 = qsmall
           printf, 1, format='(a3,a18, a18)', '2) ', strtrim(id_max2,2), strtrim(oba_max2,2)
         endif
         ;; the third biggest object
         oba_max3 = max((obj_area lt 9000000000000000000)*obj_area)
         qsmall = where(obj_area eq oba_max3, c_small, /l64)
         if c_small gt 0 then begin
           for id = 0, c_small-1 do begin
             il = qsmall[id] & q = revind[revind[il]:revind[il+1]-1] & ext[q] = 80b
           endfor
           ;; set qsmall to a high number
           obj_area[qsmall] = 9000000000000000000
           id_max3 = qsmall
           printf, 1, format='(a3,a18, a18)', '3) ', strtrim(id_max3,2), strtrim(oba_max3,2)
         endif
       endif else begin
         printf,1, 'Largest object:     ', strtrim(oba_max, 2)
       endelse
       ;; close the statistics file
       close, 1
       
       ;; write csv output
       fx = info.dir_tmp + 'acc.csv' & file_delete,fx,/allow_nonexistent,/quiet
       openw,12,fx
       printf,12, 'Accounting size classes result using: ' + input + ' (more info in: acc.txt), , , , , ,'
       printf,12, ', Size class [pixels], Color, # Objects, Area[pixels], % of all objects, % of total FGarea'
       printf,12,  ', 1: [1 - ' + strtrim(cat[0],2) + '],' + cl_name[0] + ', ' + $
         strtrim(cat_id[0],2) + ', ' + strtrim(cat_area[0],2) + ', ' + $
         strtrim(cat_id[0]*100.0/tot_ids, 2) + ', ' + strtrim(cat_area[0]*100.0/tot_area, 2)
       if nr_cat ge 2 then printf,12, ', 2: [' + strtrim(cat[0]+1,2) + ' - ' + strtrim(cat[1],2) + '],' + $
         cl_name[1] + ', ' + strtrim(cat_id[1], 2) + ', ' + strtrim(cat_area[1],2) + ', ' + $
         strtrim(cat_id[1]*100.0/tot_ids, 2) + ', ' + strtrim(cat_area[1]*100.0/tot_area, 2)
       if nr_cat ge 3 then printf,12, ', 3: [' + strtrim(cat[1]+1,2) + ' - ' + strtrim(cat[2],2) + '], ' + $
         cl_name[2] + ', ' + strtrim(cat_id[2], 2) + ', '  + strtrim(cat_area[2],2) + ', ' + $
         strtrim(cat_id[2]*100.0/tot_ids, 2) + ', ' + strtrim(cat_area[2]*100.0/tot_area, 2)
       if nr_cat ge 4 then printf,12, ', 4: [' + strtrim(cat[2]+1,2) + ' - ' + strtrim(cat[3],2) + '],' + $
         cl_name[3] + ', ' + strtrim(cat_id[3], 2) + ', ' + strtrim(cat_area[3],2) + ', ' + $
         strtrim(cat_id[3]*100.0/tot_ids, 2) + ', ' + strtrim(cat_area[3]*100.0/tot_area, 2)
       if nr_cat ge 5 then printf,12, ', 5: [' + strtrim(cat[3]+1,2) + ' - ' + strtrim(cat[4],2) + '], ' + $
         cl_name[4] + ', ' + strtrim(cat_id[4], 2) + ', ' + strtrim(cat_area[4],2) + ', ' + $
         strtrim(cat_id[4]*100.0/tot_ids, 2) + ', ' + strtrim(cat_area[4]*100.0/tot_area, 2)

       ;; the last class
       if cat_idlast gt 0 then begin
         printf,12, ', ' + strtrim(nr_cat + 1,2) + ': [' + strtrim(cat[nr_cat-1]+1,2) + ' -> ], ' + $
           cl_name[nr_cat] + ', ' + strtrim(cat_idlast, 2) + ', ' + strtrim(cat_arealast,2) + ', ' + $
           strtrim(cat_idlast*100.0/tot_ids, 2) + ', ' + strtrim(cat_arealast*100.0/tot_area, 2)
       endif
       close,12

       ;; cut back to original
       ext = temporary(ext[5:sz[0]+4,5:sz[1]+4])
       ext3 = temporary(ext3[5:sz[0]+4,5:sz[1]+4])

       ;; put back missing
       q=where(im eq 0b, ct_q, /l64)
       IF ct_q GT 0 THEN BEGIN
         ext(q) = 129b ; image in viewport
         ext2(q)= -1   ; id of object
         ext3(q)= -1   ; area of object
       ENDIF
       q = where(im eq 3b, ct_q, /l64) ;; water bodies - blue
       IF ct_q GT 0 THEN BEGIN
         ext(q) = 105b ; image in viewport
         ext2(q)= -3   ; id of object
         ext3(q)= -3   ; area of object
       ENDIF
       q = where(im eq 4b, ct_q, /l64) ;; special BG -pale-blue
       IF ct_q GT 0 THEN BEGIN
         ext(q) = 176b ; image in viewport
         ext2(q)= -4   ; id of object
         ext3(q)= -4   ; area of object
       ENDIF
       im = 0 

       ;; write the final result to the initial input dir
       ;; first rotate the image back to normal
       ;; a) write_out viewport image 
       image0 = temporary(rotate(ext, 7)) ;; viewport image  input_Accounting_8conn_1.tif
       tt2 = file_basename(input) 
       tt3 = strmid(tt2, 0, strpos(tt2, '.', / reverse_search))
       imdir = dir_batch + tt3 + '_acc'
       imfilebase = tt3 + '_acc'
       file_mkdir, imdir & pushd, imdir

       ;; a) write out viewport image         
       IF is_geotiff EQ 0b THEN $
        write_tiff, imfilebase + '.tif', image0, red = r, green = g, blue = b, description = desc, compression = 1 ELSE $
        write_tiff, imfilebase + '.tif', image0, red = r, green = g, blue = b, geotiff = geotiffinfo, description = desc, compression = 1

       ;; b) write out table and csv                    
       z = imfilebase + '.txt'
       file_move, info.dir_tmp + 'acc.txt', z, /overwrite
       z = imfilebase + '.csv'
       file_move, info.dir_tmp + 'acc.csv', z, /overwrite
       ;; check to see if the user wanted   more output
       if saveopt eq 0 then goto, skip_idarea

       ;; c) image of IDs                   
       image0 = temporary(rotate(ext2, 7))
       IF is_geotiff EQ 0b THEN $
        write_tiff, imfilebase + '_ids.tif', image0, /long, /signed, description = desc, compression = 1 ELSE $
        write_tiff, imfilebase + '_ids.tif', image0, geotiff = geotiffinfo, /long, /signed, description = desc, compression = 1
         
       ;; d) image of area
       image0 = temporary(rotate(ext3, 7))
       IF is_geotiff EQ 0b THEN $
        write_tiff, imfilebase + '_pixels.tif', image0, /long, /signed, description = desc, compression = 1 ELSE $
        write_tiff, imfilebase + '_pixels.tif', image0, geotiff = geotiffinfo, /long, /signed, description = desc, compression = 1
       
       skip_idarea:
       popd
       image0 = 0
       okfile = okfile + 1
       z20 = input + ' (' + strtrim(allid,2) + ' objects)'
       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'File: ' + input
       printf, 9, 'Accounting: ' + z20
       printf, 9, 'Accounting comp.time [sec]: ', systime( / sec) - time0
       close, 9

       skip_batch_acc:
       stepn = (fidx + 1.0)/nr_im_files * 100.0
       progressBar -> Update, stepn
     ENDFOR
     progressBar -> Destroy
     Obj_Destroy, progressBar

     ;; inform that batch is done
     proct = systime( / sec) - time00
     IF proct GT 3600.0 THEN BEGIN
       proct2 = proct - ulong(proct/3600)*3600
       proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDIF ELSE BEGIN
       proctstr = strtrim(ulong(proct/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDELSE
     IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
     openw, 9, fn_logfile, /append
     printf, 9, ''
     printf, 9, '==============================================='
     printf, 9, 'Accounting Batch Processing total comp.time: ', proctstr
     printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
     printf, 9, '==============================================='
     close, 9

     msg = 'Accounting Batch Processing finished.' + string(10b) + $
       'Total computation time: ' + proctstr + string(10b) + $
       'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
       'More information can be found in the logfile: ' + string(10b) + fn_logfile
     res = dialog_message(msg, / information)

     ;; reset the colortable to the settings before the batch processing
     tvlct, rini, gini, bini
     goto,fin
   END

   ;;*****************************************************************************************************

   'distance_morph':  BEGIN
      ;; assign the full resolution image
      image0 = * info.fr_image

      ;; check for input compliance:
      ;; 1) input must not be larger than 2b
      IF max(image0) NE 2b THEN BEGIN
         res = dialog_message(info.wronginput, / information)
         GOTO, fin
      ENDIF

      ;; 2) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
         info.selsubregion_id = 0
         ;; deactivate zoomfactor selector
         widget_control, info.w_zoomfac, sensitive = 1
         widget_control, info.w_selsubregion, $
                         set_value = 'Zoom Mode'
         ;; restore the prezoomed process image
         * info.process = * info.prezoomprocess
         ;; disable button and enable motion events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 1
         widget_control, info.w_draw, Draw_Button_Events = 0
         info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF

      ;; reset mspa etc
      info.is_mspa = 0 & info.is_fragm = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b
      info.do_mspa_stats_id = 0 & info.is_cs22 = 0 & info.is_nw = 0 & info.is_cost = 0
      info.do_label_groups_id = 0
      
      ;; enforce 8-conn for dist, influence zone and proximity
      info.mspa_param1_id = 1
      widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id
      widget_control, info.w_mspa_param2, set_combobox_select = 1 ;; morphdist does not need this
      info.mspa_param3_id = 1
      widget_control, info.w_mspa_param3, set_value = info.mspa_param3_id
      info.mspa_param4_id = 1
      widget_control, info.w_mspa_param4, set_value = info.mspa_param4_id
      
      ;; save input image for later when doing hmc
      if eventValue2 eq 'frag_hmc' then image_hmc = image0
     
      widget_control, / hourglass
      ;; build the distance map for the foreground pixels
      ;; we MUST use the BACKGROUND feature in IDL to properly calculate the 
      ;; foreground distance in the image. This is because IDL sets the image
      ;; boundaries to zero
      ;; first extend the image to avoid border effects
      q = size(image0,/dim) & sim_x = q[0] & sim_y = q[1]
      sext_x = sim_x + 2 & sext_y = sim_y + 2
      ext = bytarr(sext_x, sext_y)
      ext[1:sim_x, 1:sim_y] = image0
      ext[0, 1:sim_y] = image0[0,*] ;left
      ext[1+sim_x:*, 1:sim_y] = image0[sim_x-1:*,*] ;right
      ext[1:sim_x, 0] = image0[*, 0] ;top
      ext[1:sim_x, 1+sim_y:*] = image0[*, sim_y-1:*] ;bottom
     
      ;; count FG, BG objects
      IF info.mspa_param1_id EQ 1b THEN conn8 = 1 ELSE conn8 = 0 ;; is always 8
      fgo = label_region(ext eq 2b,all_neighbors=conn8, /ulong) & fgo = max(fgo) 
      bgo = label_region(ext eq 1b,all_neighbors=1-conn8, /ulong) & bgo = max(bgo) 
      fg_pix = total(image0 eq 2b) & bg_pix = total(image0 eq 1b) & data = fg_pix+bg_pix
      pfg=fg_pix/data & pbg=bg_pix/data

      fo = morph_distance(ext EQ 1b, /background, neighbor = 3) & fo = fo[1:sim_x, 1:sim_y]
      distreal = fo * (image0 eq 2b)
      ;; calculate the average distance to boundary for foreground
      q = where(distreal gt 0.0, /l64) & adf = mean(distreal(q)) & q = 0 & adfmax = max(distreal)
      ;; limit the distance to 120 x the pixel size, convert from
      ;; float to byte, and add the offset of 130b
      fo = byte(round(distreal) < 120) + 130b
      ;; keep only the values above the threshold
      fo = fo * (fo gt 130b)

      ;; do the same for the backg pixels, we already call them
      ;; 'image0' here, and assign from 130b down
      bo =  morph_distance(ext EQ 2b, / background, neighbor = 3) & bo = bo[1:sim_x, 1:sim_y]
      image0 = temporary(bo) * (temporary(image0) eq 1b)  & adbmax = - max(image0)
      * info.morphdist = temporary(distreal) - image0 
      ;; calculate the average distance to boundary for background
      q = where(image0 gt 0.0, /l64) & adb = mean(image0(q)) & q = 0
      image0 = 130b - byte(round(temporary(image0)) < 120)
      image0 = image0 * (image0 lt 130b)

      ;; combine the foreground and backg distance maps
      * info.process = temporary(image0) + temporary(fo)
      * info.fr_image = * info.process

      ;; restore the distance color table
      if eventValue2 ne 'frag_hmc' then begin
        restore, info.dir_guidossub + 'distcolors.sav' & tvlct, r, g, b
        info.ctbl = - 1 & info.disp_colors_id = 4 & info.autostretch_id = 0 & info.is_dist = 1 
      endif
      info.is_influ = 0
      
      ;; add barplot of distance distribution
      image0 = round(* info.morphdist)
      ; build distance histogram
      fghist = histogram((image0 gt 0)*image0) & fgmax=max(image0)
      bghist = histogram(-(image0 lt 0)*image0) & bgmax=-min(image0)
      ;;bins = indgen(bgmax+fgmax)-bgmax
      ;; we need to add the 0 entry for the missing pixels
      bins = indgen(bgmax+fgmax+1)-bgmax
      ;; define xrange to be at least -40 to +40 and plot the thing
      x1 = 40 > bgmax*1.05 > fgmax/2 & x2 = 40 > fgmax*1.05 > bgmax/2
      xtit = 'Background          distance [pixels]          Foreground'
      
      ;; temporary switch off motion events because they make problems with barplot
      ;; will be switched back on at the end of this section
      mev = 0
      if eventValue2 ne 'frag_hmc' then begin  ;; distance histogram
        dhist = fltarr(n_elements(bins))
        dhist[0:bgmax-1] = -reverse(bghist[1:*]) & dhist[bgmax+1:*]=fghist[1:*]
        bptit = 'Distance histogram (' + info.title + ')'
        a = barplot(bins, dhist, fill_color='blue', xtitle=xtit, /buffer, $
          ytitle = 'Frequency', title = bptit, xrange = [-x1,x2], histogram=1)
          
        ;; print out stats to a file which can then be saved later on
        openw,1,info.dir_tmp+'eucldist.txt' 
        printf, 1, 'Euclidean distance result using file: ', info.fname_input
        printf, 1, 'Background: average distance, number of objects, maximum distance: ' 
        printf, 1, strtrim(-adb, 2), '  -', strtrim(bgo, 2), '  ', strtrim(adbmax, 2)
        printf, 1, 'Foreground: average distance, number of objects, maximum distance: ' 
        printf, 1, ' ', strtrim(adf, 2), '   ', strtrim(fgo, 2), '   ', strtrim(adfmax, 2)
        printf, 1, 'Distance histogram (rounded to nearest integer, negative values for background)
        printf, 1, '       bin ID     frequency'
        for idx=0l, n_elements(bins)-1 do printf,1, bins(idx),long64(dhist(idx))
        close, 1     
        
        ;; overplot the foreground histogram
        z = dhist & z[0:bgmax-1]=0
        a = barplot(bins,z,fill_color='green',/overplot,histogram=1)
        a = text(2,-bghist[1]*0.2,'adf = ' + strtrim(adf, 2),/data,/current,color='green')
        a = text(2,-bghist[1]*0.2,'adf',/data,/current,color='gold')
        a = text(2,-bghist[1]*0.3,'fgo = ' + strtrim(fgo, 2),/data,/current,color='green')
        a = text(2,-bghist[1]*0.4,'d_max = ' + strtrim(adfmax, 2),/data,/current,color='green')
        px = -40 < (-bgmax)
        a = text(px*0.8,fghist[1]*0.4,'adb = ' + strtrim(-adb, 2),/data,/current,color='blue')
        a = text(px*0.8,fghist[1]*0.4,'adb',/data,/current,color='gold')
        a = text(px*0.8,fghist[1]*0.3,'bgo = -' + strtrim(bgo, 2),/data,/current,color='blue')
        a = text(px*0.8,fghist[1]*0.2,'d_max = ' + strtrim(adbmax, 2),/data,/current,color='blue')
        ;; highlight the average distance bin
        z2 = z*0 & bb = bgmax-round(adb) & z2[bb]=dhist[bb]
        if adf gt 1.0 then bb = bgmax+round(adf) else bb = bgmax & z2[bb]=dhist[bb]
        a = barplot(bins,z2,fill_color='gold',/overplot,histogram=1)
        a.save,info.dir_tmp + 'barplot_dist.png', resolution=300
        a.close
        
        ;; calculate hypsometric curve
        ;;===========================================================
        fghmc=total(fghist[1:*],/cum) & bghmc=total(bghist[1:*],/cum)
        fghmcx=fghmc/max(fghmc) & bghmcx=bghmc/max(bghmc)

        ;; define hmc for background and foreground
        hmc = fltarr(n_elements(bins))
        hmc[0:bgmax-1] = -reverse(bghmcx) & hmc[bgmax+1:*]=fghmcx
        bptit = 'Hypsometric curve (' + info.title + ')'
        a = barplot(bins,hmc,fill_color='blue',xtitle = xtit, /buffer,$
          ytitle='Normalized cumulative frequency',title=bptit,yrange=[-1.1,1.1],xrange=[-x1,x2],histogram=1)
        z = hmc & z[0:bgmax-1]=0
        a = barplot(bins,z,fill_color='green',/overplot,histogram=1)

        ;; highlight the average distance bin
        z = z*0 & bb = bgmax-round(adb) & z[bb]=hmc[bb]
        if adf gt 1.0 then bb = bgmax+round(adf) else bb = bgmax
        ; ensure it is not larger than the last entry of z which may happen in singular cases and rounding issues
        xx = n_elements(z)-1 & bb = bb < xx & z[bb]=hmc[bb]
        a = barplot(bins,z,fill_color='gold',/overplot,histogram=1)

        ;; HI: Hypsometric Index
        ;;
        ;; HI = (E_mean - E_min)/(E_max - E_min) with
        ;; E_min: minimum elevation value (outlet)
        ;; E_max: maximum elevation value
        ;; E_mean: mean (not median) elevation value

        ;; HA: Hypsometric Area - integral area under the curve for FG, BG

        hi_fg = 0 & hi_bg = 0 & ha_fg = 0 & ha_bg = 0
        if adf gt 0 then begin
          hi_fg = adf/adfmax
          ha_fg = total(fghmcx)
          fg_arep = (!PI * (adf^2)) ; typical area
        endif
        if adb gt 0 then begin
          hi_bg = adb/adbmax
          ha_bg = -total(bghmcx)
          bg_arep = -(!PI * (adb^2)) ; typical area
        endif

        ;;Foreground
        hi_fg_str = 'HI = ' + strtrim(hi_fg,2)
        ha_fg_str = 'HA = ' + strtrim(ha_fg,2)
        a = text(5,-0.2,hi_fg_str,/data,/current,color='green')
        a = text(5,-0.3,ha_fg_str,/data,/current,color='green')
        a = text(5,-0.5,'adf = ' + strtrim(adf, 2),/data,/current,color='green')
        a = text(5,-0.5,'adf',/data,/current,color='gold')
        a = text(5,-0.6,'fg_dmax = ' + strtrim(adfmax, 2),/data,/current,color='green')
        a = text(5,-0.7,'fg_obj = ' + strtrim(fgo, 2),/data,/current,color='green')
        a = text(5,-0.8,'fg_area = ' + strtrim(pfg*100, 2)+'%',/data,/current,color='green')
        a = text(5,-0.9,'fg_Arep = ' + strtrim(fg_arep, 2),/data,/current,color='red')

        ;; Background
        hi_bg_str = 'HI = ' + strtrim(hi_bg,2)
        ha_bg_str = 'HA = ' + strtrim(ha_bg,2)
        a = text(-x1*0.9,0.9,hi_bg_str,/data,/current,color='blue')
        a = text(-x1*0.9,0.8,ha_bg_str,/data,/current,color='blue')
        a = text(-x1*0.9,0.6,'adb = ' + strtrim(-adb, 2),/data,/current,color='blue')
        a = text(-x1*0.9,0.6,'adb',/data,/current,color='gold')
        a = text(-x1*0.9,0.5,'bg_dmax = ' + strtrim(adbmax, 2),/data,/current,color='blue')
        a = text(-x1*0.9,0.4,'bg_obj = -' + strtrim(bgo, 2),/data,/current,color='blue')
        a = text(-x1*0.9,0.3,'bg_area = ' + strtrim(pbg*100, 2)+'%',/data,/current,color='blue')
        a = text(-x1*0.9,0.2,'bg_Arep = ' + strtrim(bg_arep, 2),/data,/current,color='red')
        a.save,info.dir_tmp + 'barplot_hmc.png', resolution=300   
        
        ;; print out HMC stats to a txt-file
        fn_out = info.dir_tmp + 'dist_hmc.txt'
        openw,1,fn_out
        printf, 1, 'HI, HA, adb, bg_dmax, bg_obj, bg_area, bg_Arep (background indices)'
        printf, 1, 'HI, HA, adf, fg_dmax, fg_obj, fg_area, fg_Arep (foreground indices)'
        printf, 1, ' '
        printf, 1, 'File: ' + info.fname_input
        printf, 1, strtrim(abs(hi_bg),2),'  ',strtrim(abs(ha_bg),2), '  ',strtrim(adb,2),'  ', strtrim(abs(adbmax),2),$
          '  ', strtrim(bgo,2), '  ', strtrim(pbg*100, 2), '  ', strtrim(abs(bg_arep),2)
        printf, 1, strtrim(hi_fg,2), '  ', strtrim(ha_fg,2), '  ', strtrim(adf,2), '  ', strtrim(adfmax,2),'  ',$
          strtrim(fgo,2), '  ', strtrim(pfg*100, 2), '  ', strtrim(fg_arep,2)
        close, 1

        ;; print out HMC stats to a csv-file
        fn_out = info.dir_tmp + 'dist_hmc.csv'
        openw,1,fn_out
        printf, 1, 'HI_bg, HA_bg, adb, bg_dmax, bg_obj, bg_area, bg_Arep, ,HI_fg, HA_fg, adf, fg_dmax, fg_obj, fg_area, fg_Arep'
        printf, 1, strtrim(abs(hi_bg),2) + ',' + strtrim(abs(ha_bg),2) + ',' + strtrim(adb,2) + ',' + strtrim(abs(adbmax),2) + ',' + $
          strtrim(bgo,2) + ',' + strtrim(pbg*100, 2) + ',' + strtrim(abs(bg_arep),2) + ', ,' + strtrim(hi_fg,2) + ',' + strtrim(ha_fg,2) + $
          ',' + strtrim(adf,2) + ',' + strtrim(adfmax,2) + ',' + strtrim(fgo,2) + ',' + strtrim(pfg*100, 2) + ',' + strtrim(fg_arep,2)
        close, 1            
      endif
      
      if eventValue2 eq 'frag_hmc' then begin
      ;;///////////////////////////////////////////////////////////
      ;; calculate hypsometric curve            
        fghmc=total(fghist[1:*],/cum) & bghmc=total(bghist[1:*],/cum)
        fghmcx=fghmc/max(fghmc) & bghmcx=bghmc/max(bghmc)
        
        ;; define hmc for background and foreground
        hmc = fltarr(n_elements(bins))
        hmc[0:bgmax-1] = -reverse(bghmcx) & hmc[bgmax+1:*]=fghmcx
 
        ;; FRAGMENTATION
        ;;=======================================================
        ;; let's define fragmentation as the deviation from the maximum compact shape, 
        ;; a circle made up of the FG pixels, having the radius of R0
        ;; which equals the maximum distance from the FG/BG boundary into the circle
        ;;
        ;; define reference hmc:
        ;; a circle of equal area as the image with all fg_pix as a subcircle in the center
        ;; data = fg_pix + bg_pix  ;; area of known values without missing for which we can't say anything
        r_data = sqrt(data/!pi)
        r_fg = sqrt(fg_pix/!pi)
        
        ;; calculate reference hmc
        rfgmax = ceil(r_fg)
        ringsfg = lonarr(rfgmax) 
        for i = 0, rfgmax-2 do ringsfg[i] = round((!pi * (r_fg - (i))^2) - (!pi * (r_fg - (i+1))^2))
        ;; set the last entry
        ringsfg[rfgmax-1] = round(!pi * (r_fg - (rfgmax-1))^2)

        rbgmax = ceil(r_data - r_fg)
        ringsbg = lonarr(rbgmax) 
        for i = 0, rbgmax-2 do ringsbg[i] = round( (!pi * (r_fg + (i+1))^2) - (!pi * (r_fg + (i))^2) )
        ;; set the last entry
        ringsbg[rbgmax-1] = round( (!pi * r_data^2) - (!pi * (r_fg + (rbgmax-1))^2) )
        
        ;; add 1 bin for the 0-entry
        rbins = indgen(rbgmax + rfgmax)-rbgmax
        
        ; setup HMC
        rfghmc=total(ringsfg,/cum) & rbghmc=total(ringsbg,/cum)
        rfghmcx=rfghmc/max(rfghmc) & rbghmcx=rbghmc/max(rbghmc)
        rhmc = fltarr(n_elements(rbins))
        rhmc[0:rbgmax-1] = -reverse(rbghmcx) & rhmc[rbgmax:*]=rfghmcx
              
        ;; show reference hmc
        ;;;===================
        bptit = 'Normalized hypsometric curve (' + info.title + ')'
        xtit = 'Background               normalized distance               Foreground'
        a = barplot([0,1],[1,1],fill_color='Red',xtitle = xtit, transparency=90, /buffer,$
          ytitle='Normalized cumulative frequency',title=bptit,yrange=[-1.1,1.1],xrange=[-1,1],histogram=1)
        a = barplot([-2,-1],[-1,-1],fill_color='Red',transparency=90,/overplot,histogram=1)
        ;; add boundary info
        a = text(-0.9,0.9,'Minimum fragmentation',/data,/current,color='Black')
        a = text(-0.9,0.75,'Maximum fragmentation',/data,/current,color='Red')
        a = plot([-1,0],[-1,-1],thick=3,/data,/current,/overplot,color='Red')
        a = plot([0,1],[1,1],thick=3,/data,/current,/overplot,color='Red')
        a = plot([0,0],[1,-1],thick=3,/data,/current,/overplot,color='Red')

        ;; first oplot hmc of actual image
        ;;=================================
        ;; a) background
        y = hmc[0:bgmax-1] & x = bins[0:bgmax-1] & xm = float(min(x))
        bgarea = total(y)/n_elements(y) & x = -x/xm
        a = barplot(x,y,fill_color='Blue', transparency=0,/overplot,histogram=1)
        ;; b) foreground, here we shift the foreground range to the zero center line (x=x-1)
        y = hmc[bgmax+1:*] & x = bins[bgmax+1:*] & x=x-1 & xm = float(max(x))
        ;; test if only one element to avoid division by zero
        if xm lt 1.0 then begin
          fgarea = total(y) & x[0] = 0
        endif else begin
          fgarea = total(y)/n_elements(y) & x = x/xm
        endelse
        a = barplot(x,y,fill_color='Green', transparency=30,/overplot,histogram=1)

        ;; next oplot hmc of the reference area 
        ;;=======================================
        y = rhmc[0:rbgmax-1] & x = rbins[0:rbgmax-1] & xm = float(min(x))
        rbgarea = total(y)/n_elements(y) & x = -x/xm
        a = barplot(x,y,fill_color='Black',/overplot,histogram=1)
        ;; now oplot the normalized FG
        y = rhmc[rbgmax:*] & x = rbins[rbgmax:*] &  xm = float(max(x))
        rfgarea = total(y)/n_elements(y) & x = x/xm
        a = barplot(x,y,fill_color='Black',/overplot,histogram=1)

        ;; define fragmentation in complementary area of area covered
        ;; by the reference hmc 
        ;; a) background
        ; d_bg = abs(bgarea) - abs(rbgarea)
        d_bg = abs(abs(bgarea) - abs(rbgarea))
        frag_bg = 100.0 / (1.0 - abs(rbgarea)) * d_bg
        ;; round off to 1%
        frag_bg = round(frag_bg*100)/100.0
        ttbg = strtrim(frag_bg,2) & ttbg = strmid(ttbg, 0,strpos(ttbg,'.')+3)
        frag_bg_str = 'bg_frag = ' + ttbg + '%'
        a = text(-0.9,0.2,frag_bg_str,/data,/current,color='Blue')
        ;; b) foreground
        ;; potential fragmentation area limits
        ;; 1.0 - rfgarea = 100  ;; green area
        ;; rfgarea = 0  ;; black area
        ;; d_fg = fgarea - rfgarea = area occupied by image := x% fragmentation
        d_fg = fgarea - rfgarea
        ;; due to the bining and calculation inprecision frag_fg might be slighly negative, reset to 0
        frag_fg = 100.0 / (1.0 - rfgarea) * d_fg > 0.0
        frag_fg = round(frag_fg*100)/100.0
        ttfg = strtrim(frag_fg,2) & ttfg = strmid(ttfg, 0,strpos(ttfg,'.')+3)
        frag_fg_str = 'fg_frag = ' + ttfg + '%'
        a = text(0.1,-0.2,frag_fg_str,/data,/current,color='Green')
        frag = pbg * frag_bg + pfg * frag_fg
        frag = round(frag*100)/100.0
        ttf = strtrim(frag,2) & ttf = strmid(ttf, 0,strpos(ttf,'.')+3)
        frag_str = 'frag = ' + ttf + '%'
        a = text(-0.9,0.6,'$\bf'+frag_str+'$',/data,/current,color='Orange')
        
        a.save,info.dir_tmp + 'barplot2.png', resolution=300
        ;; open barplot image
        IF info.my_os EQ 'apple' THEN BEGIN
          spawn, 'open ' + info.dir_tmp + 'barplot2.png'
        ENDIF ELSE IF info.my_os EQ 'windows' THEN BEGIN
          pushd, info.dir_tmp
          spawn, 'start barplot2.png', / nowait
          popd
        ENDIF ELSE BEGIN ;; Linux
          IF strlen(info.xdgop) EQ 0 THEN BEGIN
            st = "Please install xdg-open to automatically" + $
              "display barplots within GuidosToolbox."
            result = dialog_message(st, / information)
          ENDIF ELSE BEGIN
            spawn, info.xdgop + ' "' + info.dir_tmp + 'barplot2.png' + '"'
          ENDELSE
        ENDELSE

       
      endif

      if eventValue2 eq 'frag_hmc' then begin
        info.add_title = ' (Frag(Hypsometry_Index): ' + ttf + '%, BG=' + ttbg + '%, FG=' + ttfg + '%)'
        ;; reset images to input when doing hmc
        * info.process = temporary(image_hmc) 
        * info.fr_image = * info.process       
        goto, skip_dist
      endif else begin
        distcont:
        zz = ': tick Divide for new distance range settings; Intext for barplot)'
        info.add_title = ' (Euclidean Distance, adb=-' + strtrim(adb, 2) + $
          ' adf=' + strtrim(adf, 2) + zz 
      endelse

      widget_control, info.w_labelstr, set_value = 'Distance range: '
      widget_control, info.w_label_t1, set_value = ['X','5','10','15']
      widget_control, info.w_label_t2, set_value = ['X','20','30','50']
      widget_control, info.w_label_t1, set_combobox_select = 1 & info.label_t1 = 5
      widget_control, info.w_label_t2, set_combobox_select = 1 & info.label_t2 = 20
      
      skip_dist:
      mev = 1

   END
   
   ;;*****************************************************************************************************

   'batch_eucldist':  BEGIN
     tit = 'Select (Geo-)Tif-files'
     im_file = $
       dialog_pickfile(Title = tit, get_path = path2file, $
       path = info.dir_data, default_extension = 'tif', / fix_filter, $
       / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
     IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
     
     ;; test that the directory of the selected files has no sub-directories
     ;; this will also ensure no output file is opened in excel or thelike
     pushd, path2file
     list = file_search() & nl = n_elements(list) & nr_dir = 0
     for idx = 0, nl-1 do begin
       q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
     endfor
     IF nr_dir GT 0 THEN BEGIN
       msg = 'The directory of your Batch Euclidean input files contains sub-directories.'  +  string(10b) +  string(10b) + $
         'Please set up a new directory having Batch Euclidean input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     popd
     
     ;; test that we can write into the parent directory or if it exists already
     batch_type = 'batch_Euclidean'
     dd = file_dirname(im_file[0], / mark_directory)
     dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
     res = file_test(dir_batch, /directory, /write)
     if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
       res = dialog_message(msg,/question)
       If res eq 'No' then goto, fin
       ;; empty it
       pushd, dir_batch
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd
     endif else begin ;; does not exist yet, create it
       file_mkdir, dir_batch
     endelse



     ;; files are now selected, reset the GUI
     ;;========================================================================
     ;; reset the front image and block any events
     ;;========================================================================
     title = 'Euclidean Distance Batch Processing'
     goto, resetfront

     backto_batch_eucldist:
     desc = 'GTB_EUCL, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
     desc0 = 'GTB, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
     ;; do the loop processing now
     ;; validate and process the images in a loop
     fn_logfile = dir_batch + batch_type + '.log'
     nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
     openw, 9, fn_logfile
     printf, 9, 'Euclidean Distance batch processing logfile: ', systime()
     printf, 9, 'Number of files to be processed: ', nr_im_files
     printf, 9, '==============================================='
     close, 9
     
     msg = 'Processing selected images for Euclidean Distance, please wait...'
     progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title,/cancel)
     progressBar -> Start

     FOR fidx = 0, nr_im_files - 1 DO BEGIN
       counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
       ;; validate the input, if not skip it without message

       IF progressBar -> CheckCancel() THEN BEGIN
         res = Dialog_Message('Batch-processing cancelled by user.')
         openw, 9, fn_logfile, /append
         printf, 9, 'Batch-processing cancelled by user.'
         close, 9
         progressBar -> Destroy
         Obj_Destroy, progressBar
         tvlct, rini, gini, bini
         GOTO, fin
       ENDIF

       input = im_file(fidx) 
       res = strpos(input,' ') ge 0
       IF res EQ 1 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Euclidean Distance input (empty space in directory path or input filename): ', input
         close, 9
         GOTO, skip_eucldist  ;; invalid input
       ENDIF
       
       type = '' & res = query_image(input, type=type)
       IF type NE 'TIFF' THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Euclidean Distance input (not a TIFF image): ', input
         close, 9
         GOTO, skip_eucldist  ;; invalid input
       ENDIF

       res = query_tiff(input, geotiff = geotiffinfo)
       IF res EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Euclidean Distance input file: ', input
         close, 9
         GOTO, skip_eucldist  ;; invalid input
       ENDIF

       image0 = read_tiff(input)  ;; read and check it
       IF max(image0) NE 2b THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Euclidean Distance input file: ', input
         close, 9
         GOTO, skip_eucldist  ;; invalid input
       ENDIF

       ;; now all is ok for processing
       time0 = systime( / sec)
       widget_control, / hourglass
       ;; rotate the image to be compliant with Guidos results!
       image0 = rotate(image0,7)
       q = size(image0,/dim) & sim_x = q[0] & sim_y = q[1]
       sext_x = sim_x + 2 & sext_y = sim_y + 2
       ext = bytarr(sext_x, sext_y)
       ext[1:sim_x, 1:sim_y] = image0
       ext[0, 1:sim_y] = image0[0,*] ;left
       ext[1+sim_x:*, 1:sim_y] = image0[sim_x-1:*,*] ;right
       ext[1:sim_x, 0] = image0[*, 0] ;top
       ext[1:sim_x, 1+sim_y:*] = image0[*, sim_y-1:*] ;bottom

       ;; count FG, BG objects
       IF info.mspa_param1_id EQ 1b THEN conn8 = 1 ELSE conn8 = 0
       fgo = label_region(ext eq 2b,all_neighbors=conn8, /ulong) & fgo = max(fgo)
       bgo = label_region(ext eq 1b,all_neighbors=1-conn8, /ulong) & bgo = max(bgo)
       fg_pix = total(image0 eq 2b) & bg_pix = total(image0 eq 1b) & data = fg_pix+bg_pix
       pfg=fg_pix/data & pbg=bg_pix/data

       fo = morph_distance(ext EQ 1b, /background, neighbor = 3) & fo = fo[1:sim_x, 1:sim_y]
       distreal = temporary(fo) * (image0 eq 2b)
       ;; calculate the average distance to boundary for foreground
       q = where(distreal gt 0.0, /l64) & adf = mean(distreal(q)) & q = 0 & adfmax = max(distreal)
       ;; limit the distance to 120 x the pixel size, convert from
       ;; float to byte, and add the offset of 130b
       fo = byte(round(distreal) < 120) + 130b
       ;; keep only the values above the threshold
       fo = fo * (fo gt 130b)

       ;; do the same for the backg pixels, we already call them
       bo =  morph_distance(ext EQ 2b, / background, neighbor = 3) & bo = bo[1:sim_x, 1:sim_y]
       image0 = temporary(bo) * (temporary(image0) eq 1b)  & adbmax = - max(image0)
       morphdist = temporary(distreal) - image0
       ;; calculate the average distance to boundary for background
       q = where(image0 gt 0.0, /l64) & adb = mean(image0(q)) & q = 0
       image0 = 130b - byte(round(temporary(image0)) < 120)
       image0 = image0 * (image0 lt 130b)
       ;; combine the foreground and backg distance maps
       image0 = temporary(image0) + temporary(fo)

       ;; write the final result (float) to the initial input dir
       ;; ===============================================
       loadct, 0
       res = file_basename(input, '.tif')
       dir_res = res + info.os_sep & file_mkdir, dir_batch + dir_res
       fn_out = dir_batch + dir_res + res + '_dist.tif'
       ;; add the geotiff info if available
       IF (size(geotiffinfo))[0] gt 0 THEN BEGIN
         write_tiff, fn_out, rotate(morphdist,7), geotiff = geotiffinfo, description = desc0, compression = 1, /float
       ENDIF ELSE BEGIN
         write_tiff, fn_out, rotate(morphdist,7), description = desc0, compression = 1, /float
       ENDELSE
       
       ;; write out the image (byte array) as seen in the viewport using the distance colors
       restore, info.dir_guidossub + 'distcolors.sav' & tvlct, r, g, b
       fn_out = dir_batch + dir_res + res + '_dist_viewport.tif'       
       IF (size(geotiffinfo))[0] gt 0 THEN BEGIN
         write_tiff, fn_out, rotate(image0,7), red = r, green = g, blue = b, geotiff = geotiffinfo, description = desc, compression = 1
       ENDIF ELSE BEGIN
         write_tiff, fn_out, rotate(image0,7), red = r, green = g, blue = b, description = desc, compression = 1
       ENDELSE

       ;; add barplot of distance distribution
       ;; ====================================
       image0 = temporary(round(morphdist))
       ; build distance histogram
       fghist = histogram((image0 gt 0)*image0) & fgmax=max(image0)
       bghist = histogram(-(image0 lt 0)*image0) & bgmax=-min(image0)
       image0 = 0
       bins = indgen(bgmax+fgmax+1)-bgmax
       ;; define xrange to be at least -40 to +40 and plot the thing
       x1 = 40 > bgmax*1.05 > fgmax/2 & x2 = 40 > fgmax*1.05 > bgmax/2
       xtit = 'Background          distance [pixels]          Foreground'           
       dhist = fltarr(n_elements(bins))
       dhist[0:bgmax-1] = -reverse(bghist[1:*]) & dhist[bgmax+1:*]=fghist[1:*]
       bptit = 'Distance histogram (' + res + ')'

       ;; print out stats to a file which can then be saved later on
       openw,1,dir_batch + dir_res + res + '_dist.txt'
       printf, 1, 'Euclidean distance result using file: ', input
       printf, 1, 'Background: average distance, number of objects, maximum distance: '
       printf, 1, strtrim(-adb, 2), '  -', strtrim(bgo, 2), '  ', strtrim(adbmax, 2)
       printf, 1, 'Foreground: average distance, number of objects, maximum distance: '
       printf, 1, ' ', strtrim(adf, 2), '   ', strtrim(fgo, 2), '   ', strtrim(adfmax, 2)
       printf, 1, 'Distance histogram (rounded to nearest integer, negative values for background)
       printf, 1, '       bin ID     frequency'
       for idx=0l, n_elements(bins)-1 do printf,1, bins(idx),long64(dhist(idx))
       close, 1
       
       a = barplot(bins, dhist, fill_color='blue', xtitle=xtit, /buffer, $
         ytitle = 'Frequency', title = bptit, xrange = [-x1,x2], histogram=1)
         
       ;; overplot the foreground histogram
       z = dhist & z[0:bgmax-1]=0
       a = barplot(bins,z,fill_color='green',/overplot,histogram=1)
       a = text(2,-bghist[1]*0.2,'adf = ' + strtrim(adf, 2),/data,/current,color='green')
       a = text(2,-bghist[1]*0.2,'adf',/data,/current,color='gold')
       a = text(2,-bghist[1]*0.3,'fgo = ' + strtrim(fgo, 2),/data,/current,color='green')
       a = text(2,-bghist[1]*0.4,'d_max = ' + strtrim(adfmax, 2),/data,/current,color='green')
       px = -40 < (-bgmax)
       a = text(px*0.8,fghist[1]*0.4,'adb = ' + strtrim(-adb, 2),/data,/current,color='blue')
       a = text(px*0.8,fghist[1]*0.4,'adb',/data,/current,color='gold')
       a = text(px*0.8,fghist[1]*0.3,'bgo = -' + strtrim(bgo, 2),/data,/current,color='blue')
       a = text(px*0.8,fghist[1]*0.2,'d_max = ' + strtrim(adbmax, 2),/data,/current,color='blue')
       ;; highlight the average distance bin
       z2 = z*0 & bb = bgmax-round(adb) & z2[bb]=dhist[bb]
       if adf gt 1.0 then bb = bgmax+round(adf) else bb = bgmax & z2[bb]=dhist[bb]
       a = barplot(bins,z2,fill_color='gold',/overplot,histogram=1)
       a.save,dir_batch + dir_res + res + '_dist_hist.png', resolution=300
       a.close
       
       ;; calculate hypsometric curve
       ;;===========================================================
       fghmc=total(fghist[1:*],/cum) & bghmc=total(bghist[1:*],/cum)
       fghmcx=fghmc/max(fghmc) & bghmcx=bghmc/max(bghmc)

       ;; define hmc for background and foreground
       hmc = fltarr(n_elements(bins))
       hmc[0:bgmax-1] = -reverse(bghmcx) & hmc[bgmax+1:*]=fghmcx
       bptit = 'Hypsometric curve (' + res + ')'
       a = barplot(bins,hmc,fill_color='blue',xtitle = xtit, /buffer,$
         ytitle='Normalized cumulative frequency',title=bptit,yrange=[-1.1,1.1],xrange=[-x1,x2],histogram=1)
       z = hmc & z[0:bgmax-1]=0
       a = barplot(bins,z,fill_color='green',/overplot,histogram=1)

       ;; highlight the average distance bin
       z = z*0 & bb = bgmax-round(adb) & z[bb]=hmc[bb]
       if adf gt 1.0 then bb = bgmax+round(adf) else bb = bgmax
       ; ensure it is not larger than the last entry of z which may happen in singular cases and rounding issues
       xx = n_elements(z)-1 & bb = bb < xx & z[bb]=hmc[bb]
       a = barplot(bins,z,fill_color='gold',/overplot,histogram=1)

       ;; HI: Hypsometric Index
       ;;
       ;; HI = (E_mean - E_min)/(E_max - E_min) with
       ;; E_min: minimum elevation value (outlet)
       ;; E_max: maximum elevation value
       ;; E_mean: mean (not median) elevation value

       ;; HA: Hypsometric Area - integral area under the curve for FG, BG

       hi_fg = 0 & hi_bg = 0 & ha_fg = 0 & ha_bg = 0
       if adf gt 0 then begin
         hi_fg = adf/adfmax
         ha_fg = total(fghmcx)
         fg_arep = (!PI * (adf^2)) ; typical area
       endif
       if adb gt 0 then begin
         hi_bg = adb/adbmax
         ha_bg = -total(bghmcx)
         bg_arep = -(!PI * (adb^2)) ; typical area
       endif

       ;;Foreground
       hi_fg_str = 'HI = ' + strtrim(hi_fg,2)
       ha_fg_str = 'HA = ' + strtrim(ha_fg,2)
       a = text(5,-0.2,hi_fg_str,/data,/current,color='green')
       a = text(5,-0.3,ha_fg_str,/data,/current,color='green')
       a = text(5,-0.5,'adf = ' + strtrim(adf, 2),/data,/current,color='green')
       a = text(5,-0.5,'adf',/data,/current,color='gold')
       a = text(5,-0.6,'fg_dmax = ' + strtrim(adfmax, 2),/data,/current,color='green')
       a = text(5,-0.7,'fg_obj = ' + strtrim(fgo, 2),/data,/current,color='green')
       a = text(5,-0.8,'fg_area = ' + strtrim(pfg*100, 2)+'%',/data,/current,color='green')
       a = text(5,-0.9,'fg_Arep = ' + strtrim(fg_arep, 2),/data,/current,color='red')

       ;; Background
       hi_bg_str = 'HI = ' + strtrim(hi_bg,2)
       ha_bg_str = 'HA = ' + strtrim(ha_bg,2)
       a = text(-x1*0.9,0.9,hi_bg_str,/data,/current,color='blue')
       a = text(-x1*0.9,0.8,ha_bg_str,/data,/current,color='blue')
       a = text(-x1*0.9,0.6,'adb = ' + strtrim(-adb, 2),/data,/current,color='blue')
       a = text(-x1*0.9,0.6,'adb',/data,/current,color='gold')
       a = text(-x1*0.9,0.5,'bg_dmax = ' + strtrim(adbmax, 2),/data,/current,color='blue')
       a = text(-x1*0.9,0.4,'bg_obj = -' + strtrim(bgo, 2),/data,/current,color='blue')
       a = text(-x1*0.9,0.3,'bg_area = ' + strtrim(pbg*100, 2)+'%',/data,/current,color='blue')
       a = text(-x1*0.9,0.2,'bg_Arep = ' + strtrim(bg_arep, 2),/data,/current,color='red')
       a.save, dir_batch + dir_res + res + '_dist_hmc.png', resolution=300

       ;; print out HMC stats to a txt-file
       fn_out = dir_batch + dir_res + res + '_dist_hmc.txt'
       openw,1,fn_out
       printf, 1, 'HI, HA, adb, bg_dmax, bg_obj, bg_area, bg_Arep (background indices)'
       printf, 1, 'HI, HA, adf, fg_dmax, fg_obj, fg_area, fg_Arep (foreground indices)'
       printf, 1, ' '
       printf, 1, 'File: ' + input
       printf, 1, strtrim(abs(hi_bg),2),'  ',strtrim(abs(ha_bg),2), '  ',strtrim(adb,2),'  ', strtrim(abs(adbmax),2),$
         '  ', strtrim(bgo,2), '  ', strtrim(pbg*100, 2), '  ', strtrim(abs(bg_arep),2)
       printf, 1, strtrim(hi_fg,2), '  ', strtrim(ha_fg,2), '  ', strtrim(adf,2), '  ', strtrim(adfmax,2),'  ',$
         strtrim(fgo,2), '  ', strtrim(pfg*100, 2), '  ', strtrim(fg_arep,2)
       close, 1

       ;; print out HMC stats to a csv-file
       fn_out = dir_batch + dir_res + res + '_dist_hmc.csv'
       openw,1,fn_out
       printf, 1, 'HI_bg, HA_bg, adb, bg_dmax, bg_obj, bg_area, bg_Arep, ,HI_fg, HA_fg, adf, fg_dmax, fg_obj, fg_area, fg_Arep'
       printf, 1, strtrim(abs(hi_bg),2) + ',' + strtrim(abs(ha_bg),2) + ',' + strtrim(adb,2) + ',' + strtrim(abs(adbmax),2) + ',' + $
         strtrim(bgo,2) + ',' + strtrim(pbg*100, 2) + ',' + strtrim(abs(bg_arep),2) + ', ,' + strtrim(hi_fg,2) + ',' + strtrim(ha_fg,2) + $
         ',' + strtrim(adf,2) + ',' + strtrim(adfmax,2) + ',' + strtrim(fgo,2) + ',' + strtrim(pfg*100, 2) + ',' + strtrim(fg_arep,2)
       close, 1     
       
       okfile = okfile + 1
       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'File: ' + input
       printf, 9, 'Euclidean Distance comp.time [sec]: ', systime( / sec) - time0
       close, 9

       skip_eucldist:
       stepn = (fidx + 1.0)/nr_im_files * 100.0
       progressBar -> Update, stepn
     ENDFOR
     progressBar -> Destroy
     Obj_Destroy, progressBar

     ;; inform that batch is done
     proct = systime( / sec) - time00
     IF proct GT 3600.0 THEN BEGIN
       proct2 = proct - ulong(proct/3600)*3600
       proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDIF ELSE BEGIN
       proctstr = strtrim(ulong(proct/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDELSE
     IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
     openw, 9, fn_logfile, /append
     printf, 9, ''
     printf, 9, '==============================================='
     printf, 9, 'Euclidean Distance Batch Processing total comp.time: ', proctstr
     printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
     printf, 9, '==============================================='
     close, 9

     msg = 'Euclidean Distance Batch Processing finished.' + string(10b) + $
       'Total computation time: ' + proctstr + string(10b) + $
       'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
       'More information can be found in the logfile: ' + string(10b) + fn_logfile
     res = dialog_message(msg, / information)

     ;; reset the colortable to the settings before the batch processing
     tvlct, rini, gini, bini
     goto,fin
   END
   
  
   ;;*****************************************************************************************************

   'batch_hmc':  BEGIN
      tit = 'Select (Geo-)Tif-files'
       im_file = $
         dialog_pickfile(Title = tit, get_path = path2file, $
         path = info.dir_data, default_extension = 'tif', / fix_filter, $
         / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
       IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
       
       ;; test that the directory of the selected files has no sub-directories
       ;; this will also ensure no output file is opened in excel or thelike
       pushd, path2file
       list = file_search() & nl = n_elements(list) & nr_dir = 0
       for idx = 0, nl-1 do begin
         q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
       endfor
       IF nr_dir GT 0 THEN BEGIN
         msg = 'The directory of your Batch HMC input files contains sub-directories.'  +  string(10b) +  string(10b) + $
           'Please set up a new directory having Batch HMC input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
       ENDIF
       popd
       
       ;; test that we can write into the parent directory or if it exists already
       batch_type = 'batch_FragHypsometry'
       dd = file_dirname(im_file[0], / mark_directory)
       dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
       res = file_test(dir_batch, /directory, /write)
       if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
         res = dialog_message(msg,/question)
         If res eq 'No' then goto, fin
         ;; empty it
         pushd, dir_batch
         list = file_search() & nl = n_elements(list)
         if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
         popd
       endif else begin ;; does not exist yet, create it
         file_mkdir, dir_batch
       endelse



       ;; files are now selected, reset the GUI
       ;;========================================================================
       ;; reset the front image and block any events
       ;;========================================================================
       title = 'FragHypsometry Batch Processing'
       goto, resetfront

       backto_batch_hmc:
       ;; do the loop processing now
       ;; validate and process the images in a loop
       fn_logfile = dir_batch + batch_type + '.log'
       nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l & hmcloop=1
       openw, 9, fn_logfile
       printf, 9, 'FragHypsometry batch processing logfile: ', systime()
       printf, 9, 'frag_image, frag_bg, frag_fg [%]'
       printf, 9, ' '
       printf, 9, 'Number of files to be processed: ', nr_im_files
       printf, 9, '==============================================='
       close, 9
       loadct, 0

         ;; do the loop processing now
         ;; validate and process the images in a loop
         msg = 'Processing selected images for HMC, please wait...'
         progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
         progressBar -> Start        
         
         FOR fidx = 0, nr_im_files - 1 DO BEGIN
           counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
           ;; validate the input, if not skip it without message
           IF progressBar -> CheckCancel() THEN BEGIN
             res = Dialog_Message('Batch-processing cancelled by user.')
             openw, 9, fn_logfile, /append
             printf, 9, 'Batch-processing cancelled by user.'
             close, 9
             progressBar -> Destroy
             Obj_Destroy, progressBar
             tvlct, rini, gini, bini
             GOTO, fin
           ENDIF

           input = im_file(fidx) 
           res = strpos(input,' ') ge 0
           IF res EQ 1 THEN BEGIN
             openw, 9, fn_logfile, /append
             printf, 9, ' '
             printf, 9, '==============   ' + counter + '   =============='
             printf, 9, 'Skipping invalid HMC input (empty space in directory path or input filename): ', input
             close, 9
             GOTO, skip_batch_hmc  ;; invalid input
           ENDIF
           
           type = '' & res = query_image(input, type=type)
           IF type NE 'TIFF' THEN BEGIN
             openw, 9, fn_logfile, /append
             printf, 9, ' '
             printf, 9, '==============   ' + counter + '   =============='
             printf, 9, 'Skipping invalid HMC input (not a TIFF image): ', input
             close, 9
             GOTO, skip_batch_hmc  ;; invalid input
           ENDIF

           res = query_tiff(input, geotiff = geotiffinfo)
           IF res EQ 0 THEN BEGIN
             openw, 9, fn_logfile, /append
             printf, 9, ' '
             printf, 9, '==============   ' + counter + '   =============='
             printf, 9, 'Skipping invalid HMC input file: ', input
             close, 9
             GOTO, skip_batch_hmc  ;; invalid input
           ENDIF

           image0 = read_tiff(input)  ;; read and check it
           q=size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
           ;; in batch mode we can process larger images compared to the GUI
           MSPA_Compliance, input, image0, info.immaxsizeg * 10, 0, result
           IF result EQ 0 THEN BEGIN  ;; OR imgminsize lt 500 
             openw, 9, fn_logfile, /append
             printf, 9, ' '
             printf, 9, '==============   ' + counter + '   =============='
             printf, 9, 'Skipping invalid HMC input file: ', input
             close, 9
             GOTO, skip_batch_hmc  ;; invalid input
           ENDIF

            ;; now all is ok for processing
            time0 = systime( / sec)
            widget_control, / hourglass
            
            ;; process the image for HMC
            ;; rotate the image to be compliant with Guidos results!
            image0 = rotate(image0,7) 

            ;; first extend the image to avoid border effects
            q = size(image0,/dim) & sim_x = q[0] & sim_y = q[1]
            sext_x = sim_x + 2 & sext_y = sim_y + 2
            ext = bytarr(sext_x, sext_y)
            ext[1:sim_x, 1:sim_y] = image0
            ext[0, 1:sim_y] = image0[0,*] ;left
            ext[1+sim_x:*, 1:sim_y] = image0[sim_x-1:*,*] ;right
            ext[1:sim_x, 0] = image0[*, 0] ;top
            ext[1:sim_x, 1+sim_y:*] = image0[*, sim_y-1:*] ;bottom

            ;; count FG, BG objects
            IF info.mspa_param1_id EQ 1b THEN conn8 = 1 ELSE conn8 = 0
            fgo = label_region(ext eq 2b,all_neighbors=conn8, /ulong) & fgo = max(fgo) ;; 8-conn FG
            bgo = label_region(ext eq 1b,all_neighbors=1-conn8, /ulong) & bgo = max(bgo)  ;; 4-conn BG
            fg_pix = total(image0 eq 2b) & bg_pix = total(image0 eq 1b) & data = fg_pix + bg_pix
            pfg=fg_pix/data & pbg=bg_pix/data

            fo = morph_distance(ext EQ 1b, /background, neighbor = 3) & fo = fo[1:sim_x, 1:sim_y]
            distreal = temporary(fo) * (image0 eq 2b)
            ;; calculate the average distance to boundary for foreground
            q = where(distreal gt 0.0, /l64) & adf = mean(distreal(q)) & q = 0 & adfmax = max(distreal)

            bo =  morph_distance(ext EQ 2b, / background, neighbor = 3) & bo = bo[1:sim_x, 1:sim_y]
            image0 = temporary(bo) * (temporary(image0) eq 1b)  & adbmax = - max(image0)
            morphdist = temporary(distreal) - image0
            ;; calculate the average distance to boundary for background
            q = where(image0 gt 0.0, /l64) & adb = mean(image0(q)) & q = 0
            
            ;; add barplot of distance distribution
            image0 = round(temporary(morphdist))

            ; build distance histogram
            fghist = histogram((image0 gt 0)* image0) & fgmax=max(image0)
            bghist = histogram(-(image0 lt 0)* image0) & bgmax=-min(image0)
            bins = indgen(bgmax+fgmax+1)-bgmax & image0 = 0
            x1 = 40 > bgmax*1.05 > fgmax/2 & x2 = 40 > fgmax*1.05 > bgmax/2
            xtit = 'Background          distance [pixels]          Foreground'
            
            ;; calculate hypsometric curve
            fghmc=total(fghist[1:*],/cum) & bghmc=total(bghist[1:*],/cum)
            fghmcx=fghmc/max(fghmc) & bghmcx=bghmc/max(bghmc)
            hmc = fltarr(n_elements(bins))
            hmc[0:bgmax-1] = -reverse(bghmcx) & hmc[bgmax+1:*]=fghmcx
            
                   
            ;; fragmentation
            ;;=======================================================
            r_data = sqrt(data/!pi)
            r_fg = sqrt(fg_pix/!pi)

            ;; calculate reference hmc
            rfgmax = ceil(r_fg)
            ringsfg = lonarr(rfgmax)
            for i = 0, rfgmax-2 do ringsfg[i] = round((!pi * (r_fg - (i))^2) - (!pi * (r_fg - (i+1))^2))
            ;; set the last entry
            ringsfg[rfgmax-1] = round(!pi * (r_fg - (rfgmax-1))^2)

            rbgmax = ceil(r_data - r_fg)
            ringsbg = lonarr(rbgmax)
            for i = 0, rbgmax-2 do ringsbg[i] = round( (!pi * (r_fg + (i+1))^2) - (!pi * (r_fg + (i))^2) )
            ;; set the last entry
            ringsbg[rbgmax-1] = round( (!pi * r_data^2) - (!pi * (r_fg + (rbgmax-1))^2) )

            ;; add 1 bin for the 0-entry
            rbins = indgen(rbgmax + rfgmax)-rbgmax

            ; setup HMC
            rfghmc=total(ringsfg,/cum) & rbghmc=total(ringsbg,/cum)
            rfghmcx=rfghmc/max(rfghmc) & rbghmcx=rbghmc/max(rbghmc)
            rhmc = fltarr(n_elements(rbins))
            rhmc[0:rbgmax-1] = -reverse(rbghmcx) & rhmc[rbgmax:*]=rfghmcx

            ;; show reference hmc
            ;;;===================
            bptit = 'Normalized hypsometric curve (' + info.title + ')'
            xtit = 'Background               normalized distance               Foreground'
            a = barplot([0,1],[1,1],fill_color='Red',xtitle = xtit, transparency=90, /buffer,$
              ytitle='Normalized cumulative frequency',title=bptit,yrange=[-1.1,1.1],xrange=[-1,1],histogram=1)
            a = barplot([-2,-1],[-1,-1],fill_color='Red',transparency=90,/overplot,histogram=1)
            ;; add boundary info
            a = text(-0.9,0.9,'Minimum fragmentation',/data,/current,color='Black')
            a = text(-0.9,0.75,'Maximum fragmentation',/data,/current,color='Red')
            a = plot([-1,0],[-1,-1],thick=3,/data,/current,/overplot,color='Red')
            a = plot([0,1],[1,1],thick=3,/data,/current,/overplot,color='Red')
            a = plot([0,0],[1,-1],thick=3,/data,/current,/overplot,color='Red')

            ;; first oplot hmc of actual image
            ;;=================================
            ;; a) background
            y = hmc[0:bgmax-1] & x = bins[0:bgmax-1] & xm = float(min(x))
            bgarea = total(y)/n_elements(y) & x = -x/xm
            a = barplot(x,y,fill_color='Blue', transparency=0,/overplot,histogram=1)
            ;; b) foreground, here we shift the foreground range to the zero center line (x=x-1)
            y = hmc[bgmax+1:*] & x = bins[bgmax+1:*] & x=x-1 & xm = float(max(x))
            ;; test if only one element to avoid division by zero
            if xm lt 1.0 then begin
              fgarea = total(y) & x[0] = 0
            endif else begin
              fgarea = total(y)/n_elements(y) & x = x/xm
            endelse
            a = barplot(x,y,fill_color='Green', transparency=30,/overplot,histogram=1)

            ;; next oplot hmc of the reference area
            ;;=======================================
            y = rhmc[0:rbgmax-1] & x = rbins[0:rbgmax-1] & xm = float(min(x))
            rbgarea = total(y)/n_elements(y) & x = -x/xm
            a = barplot(x,y,fill_color='Black',/overplot,histogram=1)
            ;; now oplot the normalized FG
            y = rhmc[rbgmax:*] & x = rbins[rbgmax:*] &  xm = float(max(x))
            rfgarea = total(y)/n_elements(y) & x = x/xm
            a = barplot(x,y,fill_color='Black',/overplot,histogram=1)

            ;; define fragmentation in complementary area of area covered
            ;; by the reference hmc
            ;; a) background
            ; d_bg = abs(bgarea) - abs(rbgarea)
            d_bg = abs(abs(bgarea) - abs(rbgarea))
            frag_bg = 100.0 / (1.0 - abs(rbgarea)) * d_bg
            ;; round off to 1%
            frag_bg = round(frag_bg*100)/100.0
            ttbg = strtrim(frag_bg,2) & ttbg = strmid(ttbg, 0,strpos(ttbg,'.')+3)
            frag_bg_str = 'bg_frag = ' + ttbg + '%'
            a = text(-0.9,0.2,frag_bg_str,/data,/current,color='Blue')
            ;; b) foreground
            ;; potential fragmentation area limits
            ;; 1.0 - rfgarea = 100  ;; green area
            ;; rfgarea = 0  ;; black area
            ;; d_fg = fgarea - rfgarea = area occupied by image := x% fragmentation
            d_fg = fgarea - rfgarea
            ;; due to the bining and calculation inprecision frag_fg might be slighly negative, reset to 0
            frag_fg = 100.0 / (1.0 - rfgarea) * d_fg > 0.0
            frag_fg = round(frag_fg*100)/100.0
            ttfg = strtrim(frag_fg,2) & ttfg = strmid(ttfg, 0,strpos(ttfg,'.')+3)
            frag_fg_str = 'fg_frag = ' + ttfg + '%'
            a = text(0.1,-0.2,frag_fg_str,/data,/current,color='Green')
            frag = pbg * frag_bg + pfg * frag_fg
            frag = round(frag*100)/100.0
            ttf = strtrim(frag,2) & ttf = strmid(ttf, 0,strpos(ttf,'.')+3)
            frag_str = 'frag = ' + ttf + '%'
            a = text(-0.9,0.6,'$\bf'+frag_str+'$',/data,/current,color='Orange')
            a.save,info.dir_tmp + 'barplot2.png', resolution=300
           
            ;; write the final result to the initial input dir
            res = file_basename(input, '.tif')
            outdir = dir_batch + res + '_HMC'

            ;; setup the output directory for the current image file
            file_mkdir, outdir
            pushd, outdir
            file_move, info.dir_tmp + 'barplot2.png', res + '_HMCnorm.png',/overwrite          
            popd
            
            okfile = okfile + 1
            openw, 9, fn_logfile, /append
            printf, 9, ' '
            printf, 9, '==============   ' + counter + '   =============='
            printf, 9, 'File: ' + input
            printf, 9, ttf+'% '+ ttbg+'% ' + ttfg+ '%'
            printf, 9, 'HMC comp.time [sec]: ', systime( / sec) - time0
            close, 9
    
            skip_batch_hmc:
            stepn = (fidx + 1.0)/nr_im_files * 100.0
            progressBar -> Update, stepn         
         ENDFOR        
         progressBar -> Destroy
         Obj_Destroy, progressBar

         ;; inform that batch is done
         proct = systime( / sec) - time00
         IF proct GT 3600.0 THEN BEGIN
           proct2 = proct - ulong(proct/3600)*3600
           proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
             ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
         ENDIF ELSE BEGIN
           proctstr = strtrim(ulong(proct/60.),2) + $
             ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
         ENDELSE
         IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
         openw, 9, fn_logfile, /append
         printf, 9, ''
         printf, 9, '==============================================='
         printf, 9, 'FragHypsometry Batch Processing total comp.time: ', proctstr
         printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
         printf, 9, '==============================================='
         close, 9

         msg = 'FragHypsometry Batch Processing finished.' + string(10b) + $
           'Total computation time: ' + proctstr + string(10b) + $
           'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
           'More information can be found in the logfile: ' + string(10b) + fn_logfile
         res = dialog_message(msg, / information)

         ;; reset the colortable to the settings before the batch processing
         tvlct, rini, gini, bini
         goto,fin       
   END
   
   ;;===================================================================================================   
   'distance_influence':  BEGIN ;; also for proximity and reconnect
      ;; assign the full resolution image
     image0 = * info.fr_image & info.small_lt_old = -1

     ;; check for input compliance:
     ;; 1) input must not be larger than 2b
     IF max(image0) NE 2b THEN BEGIN
       res = dialog_message(info.wronginput, / information)
       GOTO, fin
     ENDIF
     
     ;; the original settings to be shown in the title
     ;; enforce 8-connectivity for the FG and set param 3 and 4
     info.mspa_param1_id = 1
     widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id
     info.mspa_param3_id = 1
     widget_control, info.w_mspa_param3, set_value = info.mspa_param3_id
     info.mspa_param4_id = 1
     widget_control, info.w_mspa_param4, set_value = info.mspa_param4_id


     ;widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id

     ;;IF info.mspa_param1_id EQ 1b THEN conn8str = '8-conn.' ELSE conn8str = '4-conn.'
     if info.label_t1 gt 0 then targets='Core-obj.' else targets='FG-obj.'
     influ_t = ulong(info.mspa_size_current)
     save, filename = info.dir_tmp + 'influprox.sav', targets, influ_t ;;conn8str,
     
      influ_cont:
      do_influ = 1
      ;; after we change 8/4-conn or minsize we need to reset eventvalue2 
      IF strpos(info.add_title,'(Proximity: ') GT 0 THEN eventValue2 = 'distance_proximity'
      if eventValue2 eq 'distance_proximity' then do_influ = 2
      
      ;; mspa FG-connectivity: 8 <=> euclidean distance;  4 <=> cityblock
      IF info.mspa_param1_id EQ 1b THEN conn8 = 1 ELSE conn8 = 0 ;; conn8 for the calculation


      ;; test if size was never changed then set to default of 500
       if info.small_lt_old eq -1 then begin
         info.mspa_size_old = '5000' & info.mspa_size_current = '5000'
         widget_control, info.w_mspa_param2, set_combobox_select = 0, sensitive = 1
         widget_control, info.w_mspa_param2, set_value = ['5000','1','2','3','4','5','6','7','8','9','10']
         influ_t_old = fix(info.mspa_size_current) & info.small_lt_old = influ_t_old
         save, influ_t_old, filename=info.dir_guidossub + 'influ.sav'
         info.do_label_groups_id = 1
         widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id
         if do_influ eq 1 then begin
           widget_control, info.w_labelstr, set_value = 'Buffer zone: '
         endif else begin
          widget_control, info.w_labelstr, set_value = 'Proximity: '
         endelse
         if do_influ eq 1 then widget_control, info.w_labelstr1, set_value = ' Foreground: ' else $
            widget_control, info.w_labelstr1, set_value = ' CoreZone: '
         if do_influ eq 1 then widget_control, info.w_labelstr2, set_value = ' Background' else $
            widget_control, info.w_labelstr2, set_value = ' Prox_max'
         widget_control, info.w_labelstr3, set_value = ''
         widget_control, info.w_label_t1, set_value = ['X', '0','1','2','3','5']
         if do_influ eq 1 then widget_control, info.w_label_t2, set_value = ['X', '0','5','10','15','20'] else $
            widget_control, info.w_label_t2, set_value = ['X', '0','5','10','20','50'] 
         widget_control, info.w_label_t1, set_combobox_select = 1 & info.label_t1 = 0
         widget_control, info.w_label_t2, set_combobox_select = 1 & info.label_t2 = 0
       endif

      ;; 2) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
        info.selsubregion_id = 0
        ;; deactivate zoomfactor selector
        widget_control, info.w_zoomfac, sensitive = 1
        widget_control, info.w_selsubregion, $
          set_value = 'Zoom Mode'
        ;; restore the prezoomed process image
        * info.process = * info.prezoomprocess
        ;; disable button and enable motion events in w_draw
        widget_control, info.w_draw, Draw_Motion_Events = 1
        widget_control, info.w_draw, Draw_Button_Events = 0
        info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF
      influ_t = ulong64(info.mspa_size_current)
      proxcalc = 1

      if info.is_influ and info.do_label_groups_id eq 0b then begin
        proxcalc = 0 
        if info.is_influ eq 3 then titstr = 'Proximity' else titstr = 'Influence Zone'
        GOTO, skip_proxcalc
      endif

      ;; below we do the actual calculation
      ;;=========================================
      ;; assign the full resolution image
      im = * info.orig_image & sz=size(im,/dim) & targets='FG-obj.' 
      
      ;; extend the image with background so label_region can do a flood-fill in the BG
      ;; find and fill holes in FG
      ;; holes are all labels gt 1, label 1 = real background, label 0 = foreground
      ;;
      ext = bytarr(sz[0] + 10, sz[1] + 10) + 1b
      ext[5:sz[0] + 4,5:sz[1] + 4] = temporary(im)
      
      if info.label_t1 gt 0 then begin
        ;; info.label_t1  is FG distance to edge = use core zones
        ;build euclidean distance map of foreground and constrain FG areas         
        qmiss=where(ext eq 0b,ctqmiss, /l64) 
        bo = morph_distance(ext EQ 2b, neighbor = 3)
        z=where(bo lt (info.label_t1 + 0.5) and ext eq 2b,ct, /l64)
        if ct gt 0 then ext(z)=1b
        if ctqmiss gt 0 then ext(qmiss)=0b
        z=0 & bo=0 & qmiss=0   
        targets='Core-obj.'
      endif

      ;; b) remove small FG objects
      ext=(ext eq 2b)
      lx=label_region(ext,all=conn8, /ulong)
      h=histogram(lx) & qthresh=influ_t ;; keep only FGobjects ge 5000 pixels
      qok=where(h ge qthresh, ctok, /l64)
      ;; neglect the first two entries referring to FG and open BG
      if ctok le 1 then begin
        msg = 'The current area threshold is too large. Please insert' + string(10b) + $
          'a smaller area threshold number in the Edge Width panel.' + string(10b) + 'Returning...'
        res = dialog_message(msg, /information)
        lx=0 & ext=0 & goto, fin              
      endif
      
      ext=ext*0b ;; all background to start with
      for i=1,ctok-1 do ext(where(lx eq qok(i), /l64))=2b

      ;; a) close holes in FG:
      ;; get BG and missing together , then label with 4-conn
      ;; this will close all holes, also those with 8-conn to actual BG
      ;; which are not masked by MSPA
      lx=ext ne 2b & lx=label_region(lx, /ulong) ;; this uses 4-conn
      fg_holes=where(lx gt 1, ct_fg_holes) & lx=0 
      if ct_fg_holes gt 0 then ext(fg_holes)=2b
 

      ;; find boundaries           
      ws = ext eq 2b
      ws = morph_distance(ws, /background, neighbor_sampling=3, /no_copy)
      if eventValue2 eq 'distance_proximity' then begin
        ;; old:  nw_conns = floor(ws)
        nw_conns = round(ws * 2.0) ;; use actual instead of pairwise distance
      endif
        
      ;; watershed will use or if necessary CONVERT input to byte!
      ;; we need to do this here ourselves to avoid byte-flipping
      ;; hist_equal could be better when dealing with large distance else use: ws = bytscl(ws)
        ws = hist_equal(ws)  
        ws = watershed(ws, connectivity=8, /long, nregions=nregions) & qws = where(ws eq 0, /l64) 
        ext(qws)=4b
;;;      endif
      
      cl = byte([59, 5, 9, 17, 33, 65, 18, 56, 55, 57, 58, 101]) ;; colors to be used for the objects
      nw_ids = label_region(ext eq 2b, all=conn8, / ulong) ;; nw_ids of FILLED components
      z = nw_ids & z[fg_holes]=0 
      ;;;nw_hnw = histogram(nw_ids, reverse_indices = r, / l64) ;; area of FILLED components
      nw_hnw = histogram(z, reverse_indices = r, /l64) & z=0 ;; area of non-FILLED components
      max_nw_ids=max(nw_ids)

      ;; assign random color to components, or green in case of proximity
      FOR i = 1l, n_elements(nw_hnw) - 1 DO BEGIN
        clx = i MOD 12 
        if eventValue2 eq 'distance_proximity' then $
          ext[r[r[i]:r[i + 1] - 1]] = 12b else ext[r[r[i]:r[i + 1] - 1]] = cl(clx)
      ENDFOR

      ;; cut back to original
      ext2 = temporary(long(nw_ids[5:sz[0]+4,5:sz[1]+4]))
      ext = ext[5:sz[0]+4,5:sz[1]+4]
      ;; get watershed
      qws=where(ext eq 4b, ct_qws, /l64)

      if eventValue2 eq 'distance_proximity' then nw_conns = nw_conns[5:sz[0]+4,5:sz[1]+4]  
      
      ;; show holes in FG with color 0
      q_neglect = where( (* info.orig_image eq 2b) and (ext le 2b), ct_neglect, /l64) ;; inside & outside
      q = where( (* info.orig_image eq 1b) and (ext eq 2b), ct_q, /l64)
      IF ct_q GT 0 THEN BEGIN
        ext(q) = 0b & ext2(q)= -1 & q = 0
      ENDIF
      
      ct_buff = 0
      ;; show BG-buffer zone boundary with color 80 (pink)(only for influene zones)
      if do_influ eq 1 then begin
        if info.label_t2 gt 0 then begin
          c = ext gt 4b
          c = morph_distance(c, /background, neighbor_sampling=3, /no_copy)
          a1=info.label_t2-0.5 & a2=info.label_t2+0.5
          buff = where(c ge a1 and c lt a2, ct_buff)
          ;; show BG-buffer zone with color 160
          buff2 = where(c lt a1 and c gt 0.0, ct_buff2, /l64)
          if ct_buff2 gt 0 then begin
            ext(buff2)=160b
            ext2(buff2)= -6
          endif
        endif
      endif

      IF ct_neglect GT 0 THEN BEGIN
        ext(q_neglect) = 176b & ext2(q_neglect)= -2 & q_neglect = 0
      ENDIF
      
      ;; show buffer boundary (only for influence zones)
      if do_influ eq 1 then begin
        if ct_buff gt 0 then begin
          ext(buff)=80b
          ext2(buff)= -5
        endif
      endif
      
      
      ;; put back missing 
      q = where(* info.orig_image eq 0b, ct_q, /l64)
      IF ct_q GT 0 THEN BEGIN
        ext(q) = 129b
        ext2(q)= -4
      ENDIF
      
      ;; mark watershed
      IF ct_qws GT 0 THEN BEGIN
        ext[qws] = 4b
        ext2[qws] = -3
        if eventValue2 eq 'distance_proximity' then begin
          ;; find out closest proximity
          ;;prox = nw_conns[qws] & proxmin = min(prox) & str_proxmin = strtrim(proxmin,2)
          proxmin = min(nw_conns(where(ext eq 4b, /l64))) & str_proxmin = strtrim(proxmin,2)
          proxmin_p = where((nw_conns eq proxmin) * (ext eq 4b), ct_proxmin_p, /l64) & str_ct_proxmin_p = strtrim(ct_proxmin_p,2)
          ;;print,array_indices(nw_conns,proxmin_p)

          ;; mark maximum proximity in yellow
          markmax = info.label_t2 > proxmin
          mask = (nw_conns gt 0 and nw_conns le markmax) * (ext eq 4b)
          q_skin = where(mask gt 0b, /l64) 
          ext[q_skin] = 165b ;; skin is 59
          
          ;; mark minimum proximity in red
          ext[proxmin_p] = 193b    ;; pink is 80 
    
          ;; equivalent area 
          ;;;====================================
          ;; get equivalent area along ws line
          ;sel = replicate(1b, 3, 3) ;; SE
          ws = ws[5:sz[0]+4,5:sz[1]+4] & qws = where(ws eq 0, ct, /l64)
          ;; buffer around ws showing area value of segments
          ;z = dilate(ws eq 0, sel)*nw_hnw(ws) & z[qws]=0
          ;; buffer around ws showing value of segments
          ;z = dilate(ws eq 0, sel)*ws ;;& z[qws]=0

          ;; loop over qws
          ;; setup a table here for [qws, area1, area2. etc]
          
          ;; test if we can write to the file or if it is currently open in Excel   
          fx = info.title & pp = strpos(fx, '.', / reverse_search)
          IF pp GT 0 THEN fx = strmid(fx, 0, pp)
          fx = fx + '_proximity_' + strtrim(fix(info.mspa_size_current),2)+ $
            '_' + strtrim(info.label_t1,2) + '_' + strtrim(info.label_t2,2)+'.csv'
          fx = info.dir_tmp + fx 
          openw,1,fx, error=error
          IF (error NE 0) then begin
            msg = 'Please close your spreadsheet application, then try again.' + $
              string(10b) + 'Returning...'
            res = dialog_message(msg, /information)
            close,1
            ;; set label_groups_id to 0 
            info.do_label_groups_id = 0b
            widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id
            goto,fin
          ENDIF
          proxws = ulonarr(5,ct)         
          if info.label_t1 gt 0 then targets=' Core-obj.' else targets=' FG-obj.'
          tit = 'Min.' + targets + ' size: ' + strtrim(influ_t,2)         
          tit = tit + ' - ' + strtrim(max_nw_ids,2) + ' objects - prox_min: ' + str_proxmin
          if info.label_t1 gt 0 then tit = tit + ' - core-buffer: ' + strtrim(info.label_t1,2) + ' pixels'
          printf,1, info.fname_input + ' - ' + tit
          printf,1, 'WS-X,WS-Y, #nbr, clength, CAG, IDs(area),'
          sz0 = sz[0]-1 & sz1 = sz[1]-1 & nw_cag = nw_conns * 0 
          for i = 0l, ct-1 do begin
            pp = array_indices(ws,qws[i])
            p1 = pp[0]-1 > 0 & p2 = pp[0]+1 < sz0
            p3 = pp[1]-1 > 0 & p4 = pp[1]+1 < sz1
            p = ws[p1:p2,p3:p4] & p = (p[uniq(p, sort(p))])[1:*]
            nrp = n_elements(p) 

            ;; calculate CAG (connected area gain) as sqrt(Sum_i  sum_j (i ne j) a_i * a_j)           
            IF nrp eq 1 then begin
              ;; may happen at the image boundary, exclude it
              proxws[0,i]=pp[0] & proxws[1,i]=pp[1] & proxws[2,i]=nrp & proxws[3,i]= 0 & proxws[4,i]= 0
              goto, skipcag
            ENDIF

            cag=double(0)
            for ii=0,nrp-2 do for jj=ii+1,nrp-1 do cag = cag + nw_hnw[p[ii]]*nw_hnw[p[jj]]
            cag = round(sqrt(2*cag),/l64)           
            nw_cag(pp[0],pp[1]) = cag

            ;; calculate actual proximity distance at position pp
            ;; get distance value and then weigh it by the number of intersections            
            d = nw_conns(qws[i]) ;;;& d = round(d * 2.0) ;;& d = round(d * 2.0 / nrp)
            ;;;nw_conns(qws[i]) = d
            ;; write the corrected value back into the array, only needed if nrp gt 2
            if nrp gt 2 then begin
              d = round(d / 2.0 * nrp)
              nw_conns(qws[i]) = d
              ;; check if color needs to be changed
              if d le markmax then ext(qws[i]) = 165b ;; yellow
              if d eq proxmin then ext(qws[i]) = 193b ;; red             
            endif
            
            ;; p shows the network IDs and nw_hnw[p] are the associated areas
            ;; combine them into a string
            idarea = strtrim(p[0],2) + '-' + strtrim(nw_hnw[p[0]],2)
            for ii = 1,nrp-1 do idarea = idarea + '  ' + strtrim(p[ii],2) + '-' + strtrim(nw_hnw[p[ii]],2)
            a=ext2[p]
            
            ;;            x           y                      # of intersecs     conn length    cag
            proxws[0,i]=pp[0]+1 & proxws[1,i]=sz[1]-pp[1] & proxws[2,i]=nrp & proxws[3,i]=d & proxws[4,i]=cag
            printf,1, strtrim(proxws[0,i],2), ',', strtrim(proxws[1,i],2),',',  strtrim(nrp,2), $
                ',', strtrim(d,2), ',', strtrim(cag,2),',', idarea  ;strmid(nw_hnw[p],13)
            skipcag:
          endfor
          close,1
                            
          ;; 1) get existing distance values 
          d = reform(proxws[3,*]) & duniq = d[uniq(d, sort(d))] & nr_duniq = n_elements(duniq)

          ;; 2) for each existing distance get the min/max cag, mean
          yarr0 = ulonarr(nr_duniq) & yarr1 = yarr0 & yarr2 = yarr0 & yarr3 = yarr0
          e = reform(proxws[4,*]);; the cag entries         
          for ii = 0, nr_duniq -1 do begin
            q = where(d EQ duniq[ii], /l64) & z = e[q]
            a = min(z, max=b) & k = median(z)
            yarr0[ii] = a & yarr1[ii] = b & yarr2[ii]=k & yarr3[ii] = n_elements(z) ;& cagmm[2,ii] = round(mean(z))    
          endfor
          
          ;; show range of min/max cag
          ymax = max(yarr1) & ymin = min(yarr0(where(yarr0 gt 0, /l64)))*0.9 > 0
          xmax = max(duniq)
          ;; location for max CAG (the first of possibly several ones)
          q = (where(proxws[4,*] eq ymax, /l64))[0] & maxstr=''
          if q gt 0 then begin
            xc = proxws[0,q] < sz0
            yc = proxws[1,q] < sz[1]
            maxstr = 'CAGmax: ' + strtrim(ymax,2) + '(' + strtrim(xc,2) + '/' + strtrim(yc,2) + ')'
          endif
                   
          ;yarr2 = reform(cagmm[2,*]) 
          if info.label_t1 gt 0 then targets=' Core-obj.' else targets=' FG-obj.'
          tit = 'Min.' + targets + ' size: ' + strtrim(influ_t,2) 
          tit = tit + ', ' + strtrim(max_nw_ids,2) + '; prox_min: ' + str_proxmin
          if info.label_t1 gt 0 then tit = tit + ', core-buffer: ' + strtrim(info.label_t1,2) + ' pixels'            
                    
          ;; save stuff to be displayed if wanted
          proxmax=info.label_t2
          save, duniq, yarr0, yarr1, yarr2, yarr3, ymin, ymax, xmax, proxmax, tit, $
            maxstr, fx, filename=info.dir_tmp+'proxws.sav',/compress             
        ENDIF ;; end of Proximity AND having a watershed
                         
      ENDIF ELSE BEGIN
        str_ct_proxmin_p = 'undef.' & str_proxmin = str_ct_proxmin_p
      ENDELSE
      
      ;; store stuff in the info structure
      if eventValue2 eq 'distance_proximity' then begin
        * info.nw_conns = temporary(nw_conns)  ;; filled component BG-distance
        * info.cs22_nodes = temporary(nw_cag) ;; 
      endif
      * info.nw_hnw = temporary(nw_hnw)  ; component area
      info.allcomp = total(( * info.nw_hnw)[1:*])
      * info.nw_ids = temporary(ext2)   ; nw - ids
      * info.process = temporary(ext)
      * info.fr_image = * info.process
            

      skip_proxcalc:
      ;; restore the the colors-on table
      restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b
      
      ;; reset mspa etc
      info.is_mspa = 0 & info.is_fragm = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b
      info.do_mspa_stats_id = 0 & info.is_cs22 = 0 & info.is_nw = 0 & info.is_cost = 0
      info.ctbl = - 1 & info.disp_colors_id = 3 & info.autostretch_id = 0 & info.is_dist = 0 
      if eventValue2 eq 'distance_proximity' then info.is_influ = 3 else info.is_influ = 1   
      if eventValue2 eq 'distance_proximity' then zstr = ' (Proximity: ' else zstr = ' (Influence Zones: '
          
      ;; read out the NEW settings to be shown in the title
      IF proxcalc EQ 1 THEN BEGIN 
        ;;IF info.mspa_param1_id EQ 1b THEN conn8str = '8-conn.' ELSE conn8str = '4-conn.'
        if info.label_t1 gt 0 then targets=' Core-obj.' else targets=' FG-obj.'
        ;;info.add_title = zstr + conn8str +' ' + targets + ' ge ' + strtrim(influ_t,2) + $
        info.add_title = zstr + targets + ' ge ' + strtrim(influ_t,2) + $
          ': ' + strtrim(max_nw_ids,2) ;;+ ' objects'
        if eventValue2 eq 'distance_proximity' then begin
          info.add_title = info.add_title + '; prox_min: ' + str_proxmin + '; tick Intext for barplot)'
        endif else begin
          info.add_title = info.add_title + ')'
        endelse
        save, filename = info.dir_tmp + 'influprox.sav', targets, influ_t ;;, conn8str
      ENDIF ELSE BEGIN ;; display the original settings
        restore, info.dir_tmp + 'influprox.sav' 
        info.add_title = zstr +' ' + targets + ' ge ' + strtrim(influ_t,2) + $
          ': tick Divide for new ' + titstr + ' settings)'
      ENDELSE

   END

   ;;===================================================================================================================
   ;;===================================================================================================================
   ;;=================================       R E S T O R A T I O N        ==============================================
   ;;===================================================================================================================
   ;;===================================================================================================================
   
   ;;===================================================================================================
   'cost_fixed':  BEGIN   ;;;; Restoration Setup: fixed BG-resistance   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;;===================================================================================================
     ;; 1) if already a mspa image then quit
     IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_contort GT 0 OR info.is_nw EQ 1 OR info.is_cost EQ 1 THEN BEGIN
       res = dialog_message(info.wronginput, / information)
       GOTO, fin
     ENDIF

     ;; 2) if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF
     
     ;; assign the full resolution image
     image0 = * info.fr_image
     head = 'Please load or setup a Resistance map: [(0), 2, 3-100] byte' + string(10b) + string(10b)
     histo = histogram(image0) & tit = 'Restoration setup information:'
     IF histo[2] EQ 0 THEN BEGIN
       msg = head + 'Image has no FG-objects (2b).' + string(10b) + 'Returning...'
       res = dialog_message(msg, / information, title = tit)
       GOTO, fin
     ENDIF
     qm = where(image0 eq 0b, ctqm, /l64) ;; missing pixels
     
     ;; ask for fixed BG-reistance     
     target = strtrim(indgen(98)+3,2) + ' - BG' & seltarg = target[0]
     cancel = ptr_new(1b) & seltarg = ptr_new(seltarg)
     ;; get the selected mapping
     get_roires, title = 'Fixed BG-resistance', target = target, seltarg = seltarg, $
       cancel = cancel, Group_Leader = event.top
       
     ;; check if cancel was selected then do nothing else apply the selected settings
     IF * cancel EQ 0b THEN BEGIN
       selresist = * seltarg & ptr_free, seltarg & seltarg = 0b
       ptr_free, cancel & cancel = 0b
       ;; assign the selected value
       tt = strsplit(selresist,' - ',/extract) & tt = byte(tt[0]+0)     
       image0 = (image0 NE 2b)*tt + (image0 EQ 2b)*2b
       IF ctqm GT 0 THEN image0[qm] = 0b
       * info.fr_image = image0
     ENDIF ELSE BEGIN  ;; cancel was selected
       ptr_free, cancel & cancel = 0b
       ptr_free, seltarg & seltarg = 0b
       GOTO, fin
     ENDELSE    
     info.is_cost = 0 & info.add_title = ' (fixed BG-resistance)'        
   END


   ;;===================================================================================================
   'cost_recode':  BEGIN   ;;;;; Restoration Setup: resistance by land cover   ;;;;;;;;;;;;;;;;;;;;;;
     ;;===================================================================================================
     msg = "Please assign the following resistance values:" + string(10b) + $
      '0: Blocking, can not be traversed (optional)' + string(10b) + $
      '2: Foreground (FG) objects, fixed at 2%' + string(10b) + $
      '[3, 100]: land cover specific Background (BG) resistance' + string(10b) + string(10b) + $
      'Note: resistance values of 1 or > 100 are not allowed.'
     tit = 'Restoration Planner Setup: assign land cover class specific resistance'
     res = dialog_message(msg, title = tit, / information)
     goto, lc_recode
   END


   ;;===================================================================================================
   'cost_disres':  BEGIN ;;; Restoration Setup: resistance by distance  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;;===================================================================================================
     ;; check for input compliance:
     ;; 1) if already a mspa image then quit
     IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_contort GT 0 OR info.is_nw EQ 1 OR info.is_cost EQ 1 THEN BEGIN
       res = dialog_message(info.wronginput, / information)
       GOTO, fin
     ENDIF

     ;; 2) if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF

     ;; 3) check input compliance
     finp = info.fname_input
     foutp = strpos(finp, '.', / reverse_search) & foutp = strmid(finp, 0, foutp) + '_disres.tif'
     ;; assign the full resolution image
     image0 = * info.fr_image

     ;; calculate Euclidean distance in BG only
     qm = where(image0 EQ 0b, ctqm, /l64)
     qfg = where(image0 EQ 2b, ctfg, /l64)
     
     ;; image must have FG pixels, if not notify
     if ctfg eq 0 then begin     
       msg = 'The current image has no Foreground (FG) objects <-> pixel value 2 byte.' + string(10b) + $
       "Please use 'General Tools -> Preprocessing' to assign the value 2 to your FG-objects." 
       tit = 'Restoration Planner Setup: Distance to Resistance'
       res = dialog_message(msg, title = tit, / information)
       goto, fin
     endif

     eew = 2  & eew2 = eew * 2 & sz = size(image0)
     ext = bytarr(sz[1] + eew2, sz[2] + eew2)
     ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = temporary(image0) eq 2b
     ext = morph_distance(ext, /background, neighbor = 3, /no_copy)
     ext = ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]
     ;; minimum resistance must be 3, make an offset, and round/convert to byte
     ext = 0 > round(temporary(ext) + 2.0 < 100.0)
     ext = byte(ext)
     ;; reset FG and misssing
     ext[qfg] = 2b
     if ctqm gt 0 then ext[qm] = 0b
     
     * info.process = temporary(ext)
     * info.fr_image = * info.process
     
     restore, info.dir_guidossub + 'resistcolors.sav' & tvlct, r, g, b
     info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 11
     info.is_cost = 0 & info.add_title = ' (dist2resistance)'   
   END


   ;;===================================================================================================
   'cost_pixel':  BEGIN   ;;;;; Restoration Setup: resistance by pixel   ;;;;;;;;;;;;;;;;;;;;;;
     ;;===================================================================================================
     ;; 1) if already a mspa image then quit
     IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_contort GT 0 OR info.is_nw EQ 1 OR info.is_cost EQ 1 THEN BEGIN
       res = dialog_message(info.wronginput, / information)
       GOTO, fin
     ENDIF

     ;; 2) if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF

     q = size(* info.fr_image,/dim) & xdim = q[0] & ydim = q[1]
     tit = 'Restoration Planner: pixel -> resistance'
     cancel = ptr_new(1b) & selx = ptr_new('orig') & sely = ptr_new('orig') & selval = ptr_new('orig')
     ;; get the location settings
     get_locset, title = tit, xdim = xdim, ydim = ydim, selx = selx, sely = sely, $
       selval = selval, cancel = cancel, Group_Leader = event.top
     ;; check if cancel was selected then do nothing else apply the selected settings
     IF * cancel EQ 1b THEN BEGIN ;; cancel was selected
       ptr_free, cancel & cancel = 0b
       ptr_free, selx & selx = 0b
       ptr_free, sely & sely = 0b
       ptr_free, selval & selval = 0b
       GOTO, fin
     ENDIF
     x = *selx & y = *sely & val = *selval
     ptr_free, cancel & cancel = 0b
     ptr_free, selx & selx = 0b
     ptr_free, sely & sely = 0b
     ptr_free, selval & selval = 0b
     ;; check if they were modified
     IF (x EQ 'orig') OR (y EQ 'orig') OR (val EQ 'orig') THEN BEGIN
       tit = 'Restoration Planner Setup: Pixel -> Resistance'
       msg = '             *** Operation cancelled ***  ' + string(10b) + string(10b) + $
        'Please insert, and *** press the Enter key*** in each of the three fields to assign a resistance value for a given pixel:' + string(10b) +$
        'x-location;   y-location;   resistance value [0, 2, 3-100]' + $
        string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, title = tit, / error)
       GOTO, fin 
     ENDIF
     
     ;; convert coordinates to match the upside down display
     x = x - 1
     y = ydim - y 
     val = byte((strsplit(val,'-',/extract))[0]+0)
     
     ; assign
     image0 = * info.fr_image
     image0[x,y] = val
     
     * info.process = image0
     * info.fr_image = temporary(image0)
     
     ;; when big fullres image update accordingly
     IF info.bigim THEN BEGIN
       s = size( * info.process,/dim)
       * info.process = congrid(temporary( * info.process), s[0] / info.resfac, s[1] / info.resfac)
     ENDIF

     info.is_cost = 0 & info.add_title = ' (pixel -> resistance)'       
   END
   
   
   ;;===================================================================================================
   'cost_line':  BEGIN   ;;;;; Restoration Setup: resistance by line   ;;;;;;;;;;;;;;;;;;;;;;
     ;;===================================================================================================
     ;; 1) if already a mspa image then quit
     IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_cs22 EQ 1 OR info.is_nw EQ 1 OR info.is_contort GT 0 OR info.is_influ gt 0 OR info.is_cost EQ 1 THEN BEGIN
       res = dialog_message(info.wronginput, / information)
       GOTO, fin
     ENDIF
     
     ;; 2) if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF
     
     ;; 3) check input compliance
     ;; test if the current image is a MSPA-compliant OR a propper resistance map
     ;; we must process the full resolution image
     image0 = * info.fr_image & sz = size(image0)
     
     tit = 'Custom Path restoration setup information:'
     head = 'Please load or setup a Resistance map: [(0), 2, 3-100] byte' + string(10b) + string(10b)
     IF sz[3] NE 1 THEN BEGIN ;; not byte
       msg = head + 'Resistance map must have data type byte.' + string(10b) + 'Returning...'
       res = dialog_message(msg, / information, title = tit)
       GOTO, fin
     ENDIF
     ;; test for presence of FG-objects and correct resistance values
     histo = histogram(image0)
     IF histo[2] EQ 0 THEN BEGIN
       msg = head + 'Image has no FG-objects (2b).' + string(10b) + 'Returning...'
       res = dialog_message(msg, / information, title = tit)
       GOTO, fin
     ENDIF
     IF histo[1] GT 0 THEN BEGIN ;; resistance = 1, not allowed
       msg = head + 'Resistance values of 1 are not allowed.' + string(10b) + $
         'Please use a suitable option under:'  + string(10b) + $
         'Image Analysis -> Restoration Planner -> Setup Tools' + string(10b) + string(10b) + $
         'Returning...'
       res = dialog_message(msg, / information, title = tit)
       GOTO, fin
     ENDIF
     ;; test for resistance > 100, not allowed
     IF total(histo[101:*]) GT 0.0 THEN BEGIN
       msg = head + 'Resistance values higher than 100 are not allowed.' + string(10b) + $
         'Please use a suitable option under:'  + string(10b) + $
         'Image Analysis -> Restoration Planner -> Setup Tools' + string(10b) + string(10b) + $
         'Returning...'
       res = dialog_message(msg, / information, title = tit)
       GOTO, fin
     ENDIF     

     ;; we are ok now    
     info.is_cost = 9 & info.add_title = ' (line -> resistance; tick FGConn for Path setup)'
   END



   ;;===================================================================================================
   'cost_roi':  BEGIN   ;;;;; Restoration Setup: resistance by ROI   ;;;;;;;;;;;;;;;;;;;;;;
     ;;===================================================================================================
     ;; check if we are in zoom mode
     if info.selsubregion_id eq 1 then begin ;; we are in zoom mode
       ;; get the subset of the image without zoomfactor
       ;; constrain to be within the image dimensions
       z = * info.fr_image & zdim = size(z,/dim)
       x = info.x * info.resfac & y = info.y * info.resfac
       x01 = (x(1) + 1) < zdim[0] - 1 & y01 = (y(1) + 1) < zdim[1] - 1
       imageSubset = z[x(0):x01, y(0):y01]
       
       IF info.autostretch_id eq 1b THEN image0 = bytscl(imageSubset) ELSE image0 = imageSubset
       q = Size(image0, /Dimensions) & ydim = strtrim(q[1],2)
       tit = 'Define ROIs & quit window when done. NOTE: area/length measures are approximate.'
       mask = ROIMask(image0, title=tit, Indices=roiIndices)
       roi = where(mask eq 1b, ct_roi, /l64)
       if ct_roi eq 0 then GOTO, fin ;; nothing defined
       
       ;; let the user assign a resistance value for all those rois defined earlier
       image0 = imageSubset
       tt = strtrim(indgen(98)+3,2) + ' - BG'
       target = ['2 - Foreground', '0 - Blocking', [tt]] & seltarg = target[0]
       cancel = ptr_new(1b) & seltarg = ptr_new(seltarg)
       ;; get the selected mapping
       get_roires, title = 'ROI -> Resistance', target = target, seltarg = seltarg, $
         cancel = cancel, Group_Leader = event.top
         
       ;; check if cancel was selected then do nothing else apply the selected settings
       IF * cancel EQ 0b THEN BEGIN
         * info.undo = * info.process
         * info.fr_undo = * info.fr_image
         * info.undo_data_min = * info.data_min
         * info.undo_data_max = * info.data_max
         info.undo_datatype = info.datatype

         selresist = * seltarg & ptr_free, seltarg & seltarg = 0b
         ptr_free, cancel & cancel = 0b
         ;; assign the selected value
         tt = strsplit(selresist,' - ',/extract) & tt = byte(tt[0]+0)
         image0[roi] = tt
         ;; put back into the full resolution image
         tt = * info.fr_image
         tt[x(0):x01, y(0):y01] = image0
         * info.fr_image = tt
       ENDIF ELSE BEGIN  ;; cancel was selected
         ptr_free, cancel & cancel = 0b
         ptr_free, seltarg & seltarg = 0b
         GOTO, fin
       ENDELSE
       
       ;; reset zoom
       IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
         info.selsubregion_id = 0
         ;; deactivate zoomfactor selector
         widget_control, info.w_zoomfac, sensitive = 1
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode'
         * info.process = * info.fr_image
         IF info.bigim THEN BEGIN
           s = size( * info.process,/dim)
           * info.process = congrid(temporary( * info.process), s[0] / info.resfac, s[1] / info.resfac)
         ENDIF        
         ;; disable button and enable motion events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 1
         widget_control, info.w_draw, Draw_Button_Events = 0
         info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
       ENDIF
            
     ENDIF ELSE BEGIN ;; we are NOT in zoom mode
       ;; this below is ok for the full image!!!
       IF info.autostretch_id eq 1b THEN image0 = bytscl(* info.fr_image) ELSE image0 = * info.fr_image
       q = Size(image0, /Dimensions) & ydim = strtrim(q[1],2)
       tit = 'Define ROIs & quit window when done. NOTE: area/length measures are approximate.'
       mask = ROIMask(image0, title=tit, Indices=roiIndices)
       roi = where(mask eq 1b, ct_roi, /l64)
       if ct_roi eq 0 then GOTO, fin ;; nothing defined

       ;; let the user assign a resistance value for all those rois defined earlier
       image0 = * info.fr_image
       tt = strtrim(indgen(98)+3,2) + ' - BG'
       target = ['2 - Foreground', '0 - Blocking', [tt]] & seltarg = target[0]
       cancel = ptr_new(1b) & seltarg = ptr_new(seltarg)
       ;; get the selected mapping
       get_roires, title = 'ROI -> Resistance', target = target, seltarg = seltarg, $
         cancel = cancel, Group_Leader = event.top

       ;; check if cancel was selected then do nothing else apply the selected settings
       IF * cancel EQ 0b THEN BEGIN
         * info.undo = * info.process
         * info.fr_undo = * info.fr_image
         * info.undo_data_min = * info.data_min
         * info.undo_data_max = * info.data_max
         info.undo_datatype = info.datatype
         selresist = * seltarg & ptr_free, seltarg & seltarg = 0b
         ptr_free, cancel & cancel = 0b
         ;; assign the selected value
         tt = strsplit(selresist,' - ',/extract) & tt = byte(tt[0]+0)
         image0[roi] = tt
         * info.fr_image = image0
       ENDIF ELSE BEGIN  ;; cancel was selected
         ptr_free, cancel & cancel = 0b
         ptr_free, seltarg & seltarg = 0b
         GOTO, fin
       ENDELSE       
       ;; reset zoom
       IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
         info.selsubregion_id = 0
         ;; deactivate zoomfactor selector
         widget_control, info.w_zoomfac, sensitive = 1
         widget_control, info.w_selsubregion, set_value = 'Zoom Mode'
         ;; restore the prezoomed process image
         * info.process = * info.prezoomprocess
         ;; disable button and enable motion events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 1
         widget_control, info.w_draw, Draw_Button_Events = 0
         info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
       ENDIF       
     ENDELSE
     info.is_cost = 0 & info.add_title = ' (ROI added)'

   END   
   
   ;;===================================================================================================================
   'cost_status': BEGIN   ;;;;;;;;;;;;;;  Restoration status summary  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;;===================================================================================================================
     ;; 1) check for input compliance
     ;; check for input compliance:
     IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_cs22 EQ 1 OR info.is_nw EQ 1 OR info.is_contort GT 0 OR info.is_influ gt 0 OR info.is_cost EQ 1 THEN BEGIN
       res = dialog_message(info.wronginput, / information)
       GOTO, fin
     ENDIF

     ;; 2) if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF

     ;; image is already setup for restoration
     IF strpos(info.add_title,'; tick FGConn for Path setup)') GT 0 THEN BEGIN
       res = file_info(info.dir_tmp + 'customLCP.sav')
       IF res.exists EQ 0b THEN BEGIN
         msg = "Please first setup your image via either:" + string(10b) + $
           "'Add Custom Path' or 'Find Optimum Path'"
         res = dialog_message(msg, / error)
         GOTO, fin
       ENDIF       
       restore, info.dir_tmp + 'customLCP.sav'
       goto, ok4cost3
     ENDIF

     ;; 3) check input compliance
     ;; test if the current image is a propper resistance map
     ;; we must process the full resolution image
     image0 = * info.fr_image & sz = size(image0)

     tit = 'Restoration status summary, network of FG-objects (2b):'
     ;; verify image properties for Restoration
     IF sz[3] NE 1 THEN BEGIN ;; not byte
       msg = 'Resistance map must have data type byte.' + string(10b) + 'Returning...'
       res = dialog_message(msg, / information, title = tit)
       GOTO, fin
     ENDIF
     ;; test for presence of FG-objects and correct resistance values
     histo = histogram(image0)
     IF histo[2] EQ 0 THEN BEGIN
       msg = 'Resistance map has no FG-objects (2b).' + string(10b) + 'Returning...'
       res = dialog_message(msg, / information, title = tit)
       GOTO, fin
     ENDIF
     IF total(histo[101:*]) GT 0.0 THEN BEGIN
       msg = 'Resistance map has invalid resistance > 100b.' + string(10b) + 'Returning...'
       res = dialog_message(msg, / information, title = tit)
       GOTO, fin
     ENDIF 

     ;; get all components of FG-objects
     ;; labeling must be done on extended image to avoild
     ;; zeroed boundaries, go back to original dimension later
     eew = 2  & eew2 = eew * 2
     ext = bytarr(sz[1] + eew2, sz[2] + eew2)
     ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = image0 eq 2b
     qm = where(image0 EQ 0b, /l64, ctqm) ;; missing pixels in original dimensions
     data_area = float(sz[4]) - ctqm
     image0 = temporary(ext) ;; free up space, note that image0 is now the extended area

     ;; FG-components
     lbl_comp = label_region(image0, / all, / ulong)
     nr_comp = max(lbl_comp) ;; total # of components

     ;; get area by component
     h_comp_area = histogram(lbl_comp, / l64)
     obj_big = max(h_comp_area[1: * ])

     ;; PCnum:= overall connectivity. Sum of [ (areas per component)^2 ]
     pcnum_orig = total((h_comp_area[1: * ])^2, / double)

     ;; ECA: equivalent connected component area = sqrt(pcnum) [unit area, hectares]
     ECA_orig = sqrt(pcnum_orig)
     ECA_max = total(h_comp_area[1: * ])
     DOC_orig = ECA_orig/ECA_max*100.0
     REST_POT = 100.0-doc_orig
     RAC_orig = ECA_max / data_area *100.0
     aps = ECA_MAX/nr_comp
     ;; ECA_rel: normalised/relative ECA
     ;; ARH: amount of reachable habitat (%)
     ;; PRH: percentage of reachable habitat
     ;; ECA_max = total(h_comp_area[1:*])
     ;; ECA_rel = ECA/ECA_max * 100.0

     ;; CNOA: Criticial New Object Area
     b = ECA_max & c = ECA_orig
     CNOA = (2.0 * b * c^2)/(b^2 - c^2)
     CNOA = ulong64(cnoa+1.0)

     ok4cost3:
     ;; output for csv and xdisplayfile
     statsfiletxt = info.dir_tmp + 'rss.txt'
     close, 11 & openw, 11, statsfiletxt
     printf, 11, format='(a18, 5x, 2(a20),a17,a15, 3x,4(a22))', 'AREA', 'RAC[%]', 'NR_OBJ', 'LARG_OBJ', 'APS', 'CNOA', 'ECA', 'COH[%]', 'REST_POT[%]'
     printf, 11, format = '(9(a20))', strtrim(eca_max,2), strtrim(rac_orig,2),  $
       strtrim(nr_comp,2), strtrim(obj_big,2), strtrim(aps,2), strtrim(cnoa,2), strtrim(eca_orig,2),strtrim(doc_orig,2), strtrim(rest_pot,2)
     printf, 11, ''
     printf, 11, 'Note: select File -> Save Image to save the restoration status summary.'

     close, 1 & openw, 1, info.dir_tmp + 'rss.csv'
     printf, 1, 'REP_UNIT, AREA,  RAC[%], NR_OBJ, LARG_OBJ, APS, CNOA, ECA, COH[%], REST_POT[%]'
     input2 = file_basename(info.fname_input)
     ;; check if original image has been modified
     q = where(*info.orig_image NE *info.fr_image, ct, /l64)
     IF ct GT 0 THEN input2 = 'modified_' + input2
     rowstr = input2 + ',' + strtrim(eca_max,2) + ',' + strtrim(rac_orig,2) + ','  + $
       strtrim(nr_comp,2) + ',' + strtrim(obj_big, 2) + ',' + strtrim(aps, 2) + ',' + strtrim(cnoa, 2) + ',' + $
       strtrim(eca_orig,2) + ',' + strtrim(doc_orig,2) + ',' + strtrim(rest_pot,2)
     printf, 1, rowstr
     close, 1, 11
     xdisplayfile, statsfiletxt, title = tit, width = 130

     ;; reset mspa
     info.is_mspa = 0 & info.is_fragm = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b
     info.do_mspa_stats_id = 8 & info.is_cost = 8

   END

   ;;===================================================================================================
   'batch_rss':  BEGIN   ;;;; Restoration Status batch   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;;===================================================================================================
     ;; select the images to be processed
     tit = 'Select (Geo-)Tif-files'
     im_file = $
       dialog_pickfile(Title = tit, get_path = path2file, $
       path = info.dir_data, default_extension = 'tif', / fix_filter, $
       / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
     IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected

     ;; test that the directory of the selected files has no sub-directories
     ;; this will also ensure no output file is opened in excel or thelike
     pushd, path2file
     list = file_search() & nl = n_elements(list) & nr_dir = 0
     for idx = 0, nl-1 do begin
       q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
     endfor
     IF nr_dir GT 0 THEN BEGIN
       msg = 'The directory of your Batch Restoration Status input files contains sub-directories.'  +  string(10b) +  string(10b) + $
         'Please set up a new directory having Batch Restoration Status input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     popd

     ;; test that we can write into the parent directory or if it exists already
     batch_type = 'batch_rss' ;;'batch_RestorationStatus'
     dd = file_dirname(im_file[0], / mark_directory)
     dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
     res = file_test(dir_batch, /directory, /write)
     if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
       res = dialog_message(msg,/question)
       If res eq 'No' then goto, fin
       ;; empty it
       pushd, dir_batch
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd
     endif else begin ;; does not exist yet, create it
       file_mkdir, dir_batch
     endelse

     ;; files are now selected, reset the GUI
     ;;========================================================================
     ;; reset the front image and block any events
     ;;========================================================================
     title = 'Restoration Status Batch Processing'
     goto, resetfront

     backto_batch_rss:
     fn_logfile = dir_batch + batch_type + '.log'
     fn_rssfile = dir_batch + batch_type + '.csv'

     nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
     openw, 9, fn_logfile
     printf, 9, 'Restoration Status batch processing logfile: ', systime()
     printf, 9, 'Number of files to be processed: ', nr_im_files
     printf, 9, '==============================================='
     close, 9

     msg = 'Processing selected images for Restoration Status, please wait...'
     progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
     progressBar -> Start

     ;; open the summary spreadsheet for all files
     close, 1 & openw, 1, fn_rssfile
     printf, 1, 'REP_UNIT, AREA, RAC[%], NR_OBJ, LARG_OBJ, APS, CNOA, ECA, COH[%], REST_POT[%]'

     FOR fidx = 0, nr_im_files - 1 DO BEGIN
       counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
       ;; validate the input, if not skip it without message
       IF progressBar -> CheckCancel() THEN BEGIN
         res = Dialog_Message('Batch-processing cancelled by user.')
         openw, 9, fn_logfile, /append
         printf, 9, 'Batch-processing cancelled by user.'
         close, 9, 1
         progressBar -> Destroy
         Obj_Destroy, progressBar
         tvlct, rini, gini, bini
         GOTO, fin
       ENDIF

       input = im_file(fidx)
       res = strpos(input,' ') ge 0
       IF res EQ 1 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Restoration Status input (empty space in directory path or input filename): ', input
         close, 9
         GOTO, skip_batch_RSS  ;; invalid input
       ENDIF

       type = '' & res = query_image(input, type=type)
       IF type NE 'TIFF' THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Restoration Status input (not a TIFF image): ', input
         close, 9
         GOTO, skip_batch_RSS  ;; invalid input
       ENDIF

       image0 = read_tiff(input)  ;; read and check it
       sz = size(image0)
       IF sz[3] NE 1 THEN BEGIN ;; not byte
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Restoration Status input file (not byte): ', input
         close, 9
         GOTO, skip_batch_RSS
       ENDIF

       histo = histogram(image0)
       IF histo[2] EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Restoration Status input file (no FG-objects - 2b): ', input
         close, 9
         GOTO, skip_batch_RSS
       ENDIF
       
       IF total(histo[101:*]) GT 0.0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Restoration Status input file (resistance > 100b): ', input
         close, 9
         GOTO, skip_batch_RSS
       ENDIF


       ;; now all is ok for processing
       qmiss=where(image0 eq 0b, /l64, ctmiss)
       time0 = systime( / sec)
       widget_control, / hourglass

       eew = 2  & eew2 = eew * 2
       ext = bytarr(sz[1] + eew2, sz[2] + eew2)
       ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = image0 eq 2b
       qm = where(image0 EQ 0b, /l64, ctqm) ;; missing pixels in original dimensions
       data_area = float(sz[4]) - ctqm
       image0 = temporary(ext) ;; free up space, note that image0 is now the extended area

       ;; FG-components
       lbl_comp = label_region(image0, / all, / ulong)
       nr_comp = max(lbl_comp) ;; total # of components

       ;; get area by component
       h_comp_area = histogram(lbl_comp, / l64)
       obj_big = max(h_comp_area[1: * ])

       ;; PCnum:= overall connectivity. Sum of [ (areas per component)^2 ]
       pcnum_orig = total((h_comp_area[1: * ])^2, / double)

       ;; ECA: equivalent connected component area = sqrt(pcnum) [unit area, hectares]
       ECA_orig = sqrt(pcnum_orig)
       ECA_max = total(h_comp_area[1: * ])
       DOC_orig = ECA_orig/ECA_max*100.0
       REST_POT = 100.0-doc_orig
       RAC_orig = ECA_max / data_area *100.0
       aps = ECA_MAX/nr_comp
       ;; CNOA: Criticial New Object Area
       b = ECA_max & c = ECA_orig
       CNOA = (2.0 * b * c^2)/(b^2 - c^2)
       CNOA = ulong64(cnoa+1.0)
       input2 = file_basename(input)

       rowstr = input2 + ',' + strtrim(eca_max,2) + ',' + strtrim(rac_orig,2) + ',' + $
         strtrim(nr_comp,2) + ',' + strtrim(obj_big, 2) + ',' + $
         strtrim(aps, 2) + ',' + strtrim(cnoa, 2) + ',' + $
         strtrim(eca_orig,2) + ',' + strtrim(doc_orig,2)  + ',' + strtrim(rest_pot,2)
       printf, 1, rowstr

       okfile = okfile + 1
       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'File: ' + input
       printf, 9, 'Restoration Status comp.time [sec]: ', systime( / sec) - time0
       close, 9

       skip_batch_rss:
       stepn = (fidx + 1.0)/nr_im_files * 100.0
       progressBar -> Update, stepn
     ENDFOR
     close, 1
     progressBar -> Destroy
     Obj_Destroy, progressBar

     ;; inform that batch is done
     proct = systime( / sec) - time00
     IF proct GT 3600.0 THEN BEGIN
       proct2 = proct - ulong(proct/3600)*3600
       proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDIF ELSE BEGIN
       proctstr = strtrim(ulong(proct/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDELSE
     IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
     openw, 9, fn_logfile, /append
     printf, 9, ''
     printf, 9, '==============================================='
     printf, 9, 'Restoration Status Batch Processing total comp.time: ', proctstr
     printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
     printf, 9, '==============================================='
     close, 9

     msg = 'Restoration Status Batch Processing finished.' + string(10b) + $
       'Total computation time: ' + proctstr + string(10b) + $
       'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
       'More information can be found in the logfile: ' + string(10b) + fn_logfile
     res = dialog_message(msg, / information)
     ;; reset the colortable to the settings before the batch processing
     tvlct, rini, gini, bini
     info.is_cost = 0
     GOTO, fin
    END
    
    ;;===================================================================================================================
    'cost_draw': BEGIN   ;;;;;;;;;;;;;;    Custom Draw Path     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;===================================================================================================================
      ;
      ; use/settings of info.is_cost switch:
      ; 1: isochrone map
      ; 2: optimum path or optimum big5
      ; 3/4/7: custon draw, (4-point click detection)
      ; 8: restoration status calculation
      ; 9: add custom line
      ;
      ;; 1) check for input compliance
      ;; check for input compliance:
      IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_cs22 EQ 1 OR info.is_nw EQ 1 OR info.is_contort GT 0 OR info.is_influ gt 0 OR info.is_cost EQ 1 THEN BEGIN
        res = dialog_message(info.wronginput, / information)
        GOTO, fin
      ENDIF

      ;; 2) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
        info.selsubregion_id = 0
        ;; deactivate zoomfactor selector
        widget_control, info.w_zoomfac, sensitive = 1
        widget_control, info.w_selsubregion, $
          set_value = 'Zoom Mode'
        ;; restore the prezoomed process image
        * info.process = * info.prezoomprocess
        ;; disable button and enable motion events in w_draw
        widget_control, info.w_draw, Draw_Motion_Events = 1
        widget_control, info.w_draw, Draw_Button_Events = 0
        info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF

      ;; 3) check input compliance
      ;; test if the current image is a MSPA-compliant OR a propper resistance map
      ;; we must process the full resolution image
      image0 = * info.fr_image & sz = size(image0)

      ;; image is already setup for restoration
      IF strpos(info.add_title,'; tick FGConn for Path setup)') GT 0 THEN goto, ok4cost
      
      tit = 'Custom Path restoration setup information:'
      head = 'Please load or setup a Resistance map: [(0), 2, 3-100] byte' + string(10b) + string(10b)
      IF sz[3] NE 1 THEN BEGIN ;; not byte
        msg = head + 'Resistance map must have data type byte.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information, title = tit)
        GOTO, fin
      ENDIF
      ;; test for presence of FG-objects and correct resistance values
      histo = histogram(image0)
      IF histo[2] EQ 0 THEN BEGIN
        msg = head + 'Image has no FG-objects (2b).' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information, title = tit)
        GOTO, fin
      ENDIF
      IF histo[1] GT 0 THEN BEGIN ;; resistance = 1, not allowed
        msg = head + 'Resistance values of 1 are not allowed.' + string(10b) + $
          'Please use a suitable option under:'  + string(10b) + $
          'Image Analysis -> Restoration Planner -> Setup Tools' + string(10b) + string(10b) + $
          'Returning...'
        res = dialog_message(msg, / information, title = tit)
        GOTO, fin
      ENDIF
      ;; test for resistance > 100, not allowed
      IF total(histo[101:*]) GT 0.0 THEN BEGIN
        msg = head + 'Resistance values higher than 100 are not allowed.' + string(10b) + $
          'Please use a suitable option under:'  + string(10b) + $
          'Image Analysis -> Restoration Planner -> Setup Tools' + string(10b) + string(10b) + $
          'Returning...'
        res = dialog_message(msg, / information, title = tit)
        GOTO, fin
      ENDIF
      ;; we are ok now, check which resistance we have
      q = where(histo[3:100] gt 0, ct)
      IF ct EQ 1 THEN c_size = strtrim(q[0]+3,2) ELSE c_size = 'var'
      
      ;; backup the resistance image for line draw analysis
      *info.extra = image0
      
      ;; get all components of FG-objects
      ;; labeling must be done on extended image to avoild
      ;; zeroed boundaries, go back to original dimension later
      eew = 2  & eew2 = eew * 2
      ext = bytarr(sz[1] + eew2, sz[2] + eew2)
      ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = image0 eq 2b
      qm = where(image0 EQ 0b, ctqm, /l64) ;; missing pixels in original dimensions
      data_area = float(sz[4]) - ctqm
      image0 = ext ;; free up space, note that image0 is now the extended area

      ;; build distance map for quality of restore pixels
      ext =  morph_distance(ext, / background, neighbor = 3, /no_copy)
      ext = ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]
      *info.morphdist = temporary(ext)

      ;; FG-components
      lbl_comp = label_region(image0, / all, / ulong)
      nr_comp = max(lbl_comp) ;; total # of components

      ;; get area by component
      h_comp_area = histogram(lbl_comp, / l64)
      obj_big = max(h_comp_area[1: * ])

      ;; PCnum:= overall connectivity. Sum of [ (areas per component)^2 ]
      pcnum_orig = total(h_comp_area(1: * )^2, / double)

      ;; ECA: equivalent connected component area = sqrt(pcnum) [unit area, hectares]
      ECA_orig = sqrt(pcnum_orig)
      ECA_max = total(h_comp_area(1: * ))
      DOC_orig = ECA_orig/ECA_max*100.0    
      RAC_orig = ECA_max / data_area *100.0
      aps = ECA_MAX/nr_comp
      ;; ECA_rel: normalised/relative ECA
      ;; ARH: amount of reachable habitat (%)
      ;; PRH: percentage of reachable habitat
      ;; ECA_max = total(h_comp_area[1:*])
      ;; ECA_rel = ECA/ECA_max * 100.0
      
      
      ;; CNOA: Criticial New Object Area
      b = ECA_max & c = ECA_orig
      CNOA = (2.0 * b * c^2)/(b^2 - c^2)
      CNOA = ulong64(cnoa+1.0)
      
;      ssq_orig = 58.0
;      eca_orig = sqrt(ssq_orig)
;      eca_max_orig = 16.0
;
;
;      ssq_orig = 3442.0
;      eca_orig = sqrt(ssq_orig)
;      eca_max_orig = 120.0
;      
;      a = ssq_orig
;      
;      b = eca_max_orig
;      c = eca_orig
;      y = (2.0 * b * c^2)/(b^2 - c^2)         
;      
;      x = sqrt( (b^2*c^2 - a*b^2)/(b^2 - c^2) - (0.25 * y^2) ) + y/2.0

      
      ;; show the FG-component setup to the user, who then needs to select what to reconnect

      ;; prepare image for display
      ;; load the colors-on table
      restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b
      info.ctbl = - 1 & info.disp_colors_id = 3
      image0 = (image0 GT 0b) * 150b

      ;; go back to original dimension to be shown in the display
      lbl_comp = lbl_comp[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]
      image0 = image0[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]

      ;; store stuff in the info structure
      info.autostretch_id = 0
      * info.nw_ids = lbl_comp
      ;; add back missing
      IF ctqm GT 0 THEN image0[qm] = 129b
      qm = 0

      * info.nw_conns = image0 ;; backup image for re-use to do customLCP
      * info.process = image0
      * info.nw_hnw = h_comp_area
      lbl_comp = 0 & image0 = 0 & h_comp_area = 0
      * info.fr_image = * info.process
      info.add_title = ' (custom restoration, BGresist: ' + c_size + '%, COH_ORIG: ' + $
        strtrim(doc_orig,2) + '%, CNOA: ' + strtrim(cnoa,2) +  '; tick FGConn for Path setup)'
      inatit = info.add_title

      ;; save stuff for Custom LCP
      save, c_size, pcnum_orig, cnoa, ECA_orig, ECA_max, DOC_orig, RAC_orig, obj_big, aps, $
        nr_comp, CNOA, inatit, filename = info.dir_tmp + 'customLCP.sav'

      ok4cost:
      ;; reset mspa
      info.is_mspa = 0 & info.is_fragm = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b
      info.do_mspa_stats_id = 0 & info.is_cost = 3
      ;; ensure to set FGconn to on
      info.mspa_param1_id = 1
      widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id
      info.do_label_groups_id = 0b
      widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id

    END

    ;;===================================================================================================================
    'cost_reconnect': BEGIN ;;;;;;;;;;;;;;;;   Optimum LCP   ;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;===================================================================================================================
      ;; 1) check for input compliance
      ;; check for input compliance:
      IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_cs22 EQ 1 OR info.is_nw EQ 1 OR info.is_contort GT 0 OR info.is_influ gt 0 OR info.is_cost EQ 1 THEN BEGIN
        res = dialog_message(info.wronginput, / information)
        GOTO, fin
      ENDIF

      ;; 2) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
        info.selsubregion_id = 0
        ;; deactivate zoomfactor selector
        widget_control, info.w_zoomfac, sensitive = 1
        widget_control, info.w_selsubregion, $
          set_value = 'Zoom Mode'
        ;; restore the prezoomed process image
        * info.process = * info.prezoomprocess
        ;; disable button and enable motion events in w_draw
        widget_control, info.w_draw, Draw_Motion_Events = 1
        widget_control, info.w_draw, Draw_Button_Events = 0
        info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF

      ;; 3) check input compliance
      ;; we must process the full resolution image
      image0 = * info.fr_image & sz = size(image0)
      
      ;; image is already setup for restoration
      IF strpos(info.add_title,'; tick FGConn for Path setup)') GT 0 THEN goto, ok4cost2


        tit = 'Optimum Path restoration setup information:'
        head = 'Please load or setup a Resistance map: [(0), 2, 3-100] byte' + string(10b) + string(10b)
        IF sz[3] NE 1 THEN BEGIN ;; not byte
          msg = head + 'Resistance map must have data type byte.' + string(10b) + 'Returning...'
          res = dialog_message(msg, / information, title = tit)
          GOTO, fin
        ENDIF
        ;; test for presence of FG-objects and correct resistance values
        histo = histogram(image0)
        IF histo[2] EQ 0 THEN BEGIN
          msg = head + 'Image has no FG-objects (2b).' + string(10b) + 'Returning...'
          res = dialog_message(msg, / information, title = tit)
          GOTO, fin
        ENDIF
        IF histo[1] GT 0 THEN BEGIN ;; resistance = 1, not allowed
          msg = head + 'Resistance values of 1 are not allowed.' + string(10b) + $
            'Please use a suitable option under:'  + string(10b) + $
            'Image Analysis -> Restoration Planner -> Setup Tools' + string(10b) + string(10b) + $
            'Returning...'
          res = dialog_message(msg, / information, title = tit)
          GOTO, fin
        ENDIF
        ;; test for resistance > 100, not allowed
        IF total(histo[101:*]) GT 0.0 THEN BEGIN
          msg = head + 'Resistance values higher than 100 are not allowed.' + string(10b) + $
            'Please use a suitable option under:'  + string(10b) + $
            'Image Analysis -> Restoration Planner -> Setup Tools' + string(10b) + string(10b) + $
            'Returning...'
            res = dialog_message(msg, / information, title = tit)
          GOTO, fin
        ENDIF
      ;; we are ok now, check which resistance we have
      q = where(histo[3:100] gt 0, ct)
      IF ct EQ 1 THEN c_size = strtrim(q[0]+3,2) ELSE c_size = 'var'
            
      ;; backup the resistance image for line draw analysis
      *info.extra = image0

      ;; get all components of FG-objects
      ;; labeling must be done on extended image to avoild
      ;; zeroed boundaries, go back to original dimension later
      eew = 2  & eew2 = eew * 2
      ext = bytarr(sz[1] + eew2, sz[2] + eew2)
      ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = image0 eq 2b
      qm = where(image0 EQ 0b, ctqm, /l64) ;; missing pixels in original dimensions    
      data_area = float(sz[4]) - ctqm
      image0 = ext ;; free up space, note that image0 is now the extended area having the FG-objects only

      ;; build distance map for quality of restore pixels
      ext =  morph_distance(ext, / background, neighbor = 3, /no_copy)
      ext = ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]
      if ctqm gt 0 then ext[qm] = 0.0   ;; set missing to zero, they can not be encountered in custom path
      *info.morphdist = temporary(ext)     
         
      ;; FG-components
      lbl_comp = label_region(image0, / all, / ulong)
      nr_comp = max(lbl_comp) ;; total # of components

      ;; get area by component
      h_comp_area = histogram(lbl_comp, / l64)
      obj_big = max(h_comp_area[1: * ])
      
      ;; PCnum:= overall connectivity. Sum of [ (areas per component)^2 ]
      pcnum_orig = total(h_comp_area(1: * )^2, / double)

      ;; ECA: equivalent connected component area = sqrt(pcnum) [unit area, hectares]
      ECA_orig = sqrt(pcnum_orig)
      ECA_max = total(h_comp_area(1: * ))
      DOC_orig = ECA_orig/ECA_max*100.0
      RAC_orig = ECA_max / data_area *100.0
      aps = ECA_MAX/nr_comp
      ;; ECA_rel: normalised/relative ECA
      ;; ARH: amount of reachable habitat (%)
      ;; PRH: percentage of reachable habitat
      ;; ECA_max = total(h_comp_area[1:*])
      ;; ECA_rel = ECA/ECA_max * 100.0
      
      ;; CNOA: Criticial New Object Area
      b = ECA_max & c = ECA_orig
      CNOA = (2.0 * b * c^2)/(b^2 - c^2)
      CNOA = ulong64(cnoa+1.0)

      ;; show the FG-component setup to the user, who then needs to select what to reconnect
      ;; prepare image for display
      ;; load the colors-on table
      restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b
      info.ctbl = - 1 & info.disp_colors_id = 3
      image0 = (image0 GT 0b) * 150b

      ;; go back to original dimension to be shown in the display
      lbl_comp = lbl_comp[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]
      image0 = image0[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]

      ;; store stuff in the info structure
      info.autostretch_id = 0
      * info.nw_ids = lbl_comp
      ;;* info.nw_conns = nw_conns
      ;; add back missing
      IF ctqm GT 0 THEN image0[qm] = 129b
      qm = 0

      * info.nw_conns = image0 ;; backup image for re-use to do customLCP
      * info.process = image0
      * info.nw_hnw = h_comp_area
      lbl_comp = 0 & image0 = 0 & h_comp_area = 0 
      * info.fr_image = * info.process
      info.add_title = ' (custom restoration, BGresist: ' + c_size + '%, COH_ORIG: ' + strtrim(doc_orig,2) + '%; tick FGConn for Path setup)'
      inatit = info.add_title

      ;; save stuff for Custom LCP
      save, c_size, pcnum_orig, ECA_orig, ECA_max, DOC_orig, RAC_orig, obj_big, aps, nr_comp, CNOA, inatit, filename = info.dir_tmp + 'customLCP.sav'

      ok4cost2:
      ;; reset mspa
      info.is_mspa = 0 & info.is_fragm = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b
      info.do_mspa_stats_id = 0 & info.is_cost = 2
      ;; ensure to set FGconn to on
      info.mspa_param1_id = 1
      widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id
      info.do_label_groups_id = 0b
      widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id


    END

    ;;===================================================================================================================
    'cost_restoration': BEGIN ;;;;;;;     Optimum Big 5   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;===================================================================================================================
      ;; 1) check for input compliance
      ;; check for input compliance:
      IF info.is_mspa EQ 1 OR info.is_fragm GT 0 OR info.is_cs22 EQ 1 OR info.is_nw EQ 1 OR info.is_contort GT 0 OR info.is_influ gt 0 OR info.is_cost EQ 1 THEN BEGIN
        res = dialog_message(info.wronginput, / information)
        GOTO, fin
      ENDIF

      ;; 2) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
        info.selsubregion_id = 0
        ;; deactivate zoomfactor selector
        widget_control, info.w_zoomfac, sensitive = 1
        widget_control, info.w_selsubregion, $
          set_value = 'Zoom Mode'
        ;; restore the prezoomed process image
        * info.process = * info.prezoomprocess
        ;; disable button and enable motion events in w_draw
        widget_control, info.w_draw, Draw_Motion_Events = 1
        widget_control, info.w_draw, Draw_Button_Events = 0
        info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF

      ;; 3) check input compliance
      ;; test if we have a proper resistance map
      ;; we must process the full resolution image
      image0 = * info.fr_image & sz = size(image0)

      tit = 'Optimum Big 5: setup information:'
      head = 'Please load or setup a Resistance map: [(0), 2, 3-100] byte' + string(10b) + string(10b)
      IF sz[3] NE 1 THEN BEGIN ;; not byte
        msg = head + 'Resistance map must have data type byte.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information, title = tit)
        GOTO, fin
      ENDIF
      ;; test for presence of FG-objects and correct resistance values
      histo = histogram(image0)
      IF histo[2] EQ 0 THEN BEGIN
        msg = head + 'Image has no FG-objects (2b).' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information, title = tit)
        GOTO, fin
      ENDIF
      IF histo[1] GT 0 THEN BEGIN ;; resistance = 1, not allowed
        msg = head + 'Resistance values of 1 are not allowed.' + string(10b) + $
          'Please use a suitable option under:'  + string(10b) + $
          'Image Analysis -> Restoration Planner -> Setup Tools' + string(10b) + string(10b) + $
          'Returning...'
        res = dialog_message(msg, / information, title = tit)
        GOTO, fin
      ENDIF
      ;; test for resistance > 100, not allowed
      IF total(histo[101:*]) GT 0.0 THEN BEGIN
        msg = head + 'Resistance values higher than 100 are not allowed.' + string(10b) + $
          'Please use a suitable option under:'  + string(10b) + $
          'Image Analysis -> Restoration Planner -> Setup Tools' + string(10b) + string(10b) + $
          'Returning...'
        res = dialog_message(msg, / information, title = tit)
        GOTO, fin
      ENDIF
      ;; we are ok now, check which resistance we have
      q = where(histo[3:100] gt 0, ct)
      IF ct EQ 1 THEN c_size = strtrim(q[0]+3,2) ELSE c_size = 'var'
      
      ;; backup the resistance image for analysis later in the loop
      resist = image0
      ;; reassign resistance image: FG-1 for cost analysis
      q = where(resist eq 2b, /l64) & resist[q] = 1b & q = 0      
      time0 = systime( / sec)

      ;; get all components of FG-objects
      ;; labeling must be done on extended image to avoild
      ;; zeroed boundaries, go back to original dimension later
      eew = 2  & eew2 = eew * 2
      ext = bytarr(sz[1] + eew2, sz[2] + eew2)
      ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = image0 eq 2b
      qm = where(image0 EQ 0b, ctqm, /l64) ;; missing pixels in original dimensions
      data_area = float(sz[4]) - ctqm
      image0 = ext ;; free up space, note that image0 is now the extended area having the FG-objects only

      ;; build distance map for restore pixels
      ext =  morph_distance(ext, / background, neighbor = 3, /no_copy)
      ext = ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]
      morphdist = temporary(ext)

      ;; FG-components
      lbl_comp = label_region(image0, / all, / ulong)
      nr_comp = max(lbl_comp) ;; total # of components

      ;; get area by component
      h_comp_area = histogram(lbl_comp, / l64)

      ;; PCnum:= overall connectivity. Sum of [ (areas per component)^2 ]
      pcnum_orig = total(h_comp_area(1: * )^2, / double)

      ;; ECA: equivalent connected component area = sqrt(pcnum) [unit area, hectares]
      ECA_orig = sqrt(pcnum_orig)
      ECA_max = total(h_comp_area(1: * ))
      DOC_orig = ECA_orig/ECA_max*100.0
      RAC_orig = ECA_max / data_area *100.0
      ;; ECA_rel: normalised/relative ECA
      ;; ARH: amount of reachable habitat (%)
      ;; PRH: percentage of reachable habitat
      ;; ECA_max = total(h_comp_area[1:*])
      ;; ECA_rel = ECA/ECA_max * 100.0

      ;; 5 biggest components by area
      ;; we can have 10 uniq links between the 5 largest components
      ;; from h_comp_area we exclude the first entry (= background)
      lcompidx = (reverse(sort(h_comp_area[1:*])))+1
      max5 = 5    
      IF nr_comp LT 2 THEN BEGIN
        msg = 'At least 2 components are needed.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information, title = tit)
        GOTO, fin        
      ENDIF
      max5 = nr_comp < max5
      lcompidx = lcompidx[0:max5-1] ;; these are the top 5 by ID
      ;;lcomparea = h_comp_area[lcompidx]
      IF max5 EQ 5 THEN BEGIN
        tenlinks = ['1 <-> 2', '1 <-> 3', '1 <-> 4', '1 <-> 5', '2 <-> 3', $
        '2 <-> 4', '2 <-> 5', '3 <-> 4', '3 <-> 5', '4 <-> 5']
      ENDIF ELSE IF max5 EQ 4 THEN BEGIN
        tenlinks = ['1 <-> 2', '1 <-> 3', '1 <-> 4', '2 <-> 3', '2 <-> 4', '3 <-> 4']        
      ENDIF ELSE IF max5 EQ 3 THEN BEGIN
        tenlinks = ['1 <-> 2', '1 <-> 3', '2 <-> 3']
      ENDIF ELSE IF max5 EQ 2 THEN BEGIN
        tenlinks = ['1 <-> 2']
      ENDIF
      nrtenlinks = n_elements(tenlinks)
      tenlinksimp = fltarr(nrtenlinks) & tenlinkslength = intarr(2, nrtenlinks)

      ;; prepare image for display
      ;; load the colors-on table
      restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b
      info.ctbl = - 1 & info.disp_colors_id = 3
      cl = byte([1, 5, 55, 17, 65, 56])
      image0 = (image0 GT 0b) * 150b
      imlcp0 = image0[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] ;; base image to show the individual LCPs
      if ctqm gt 0 then imlcp0[qm] = 129b
      ;; color in 5 largest components
      FOR i = 1l, max5 DO BEGIN
        q = where(lbl_comp EQ lcompidx(i - 1), /l64) & image0[q] = cl(i)
      ENDFOR
      q = 0

      ;; go back to original dimension to be shown in the display
      lbl_comp = lbl_comp[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]
      image0 = image0[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]

      ;; set up fixed stuff in dir_tmp
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      pushd, info.dir_tmp

;      ;; assign resistance image: FG-1, BG- BG-resist, missing-100
;      resist = *info.orig_image

;      ;; set/get fixed background resistance if MSPA-compliant
;      if MSPAcompliant eq 1 then resist = (resist eq 2b) + (resist eq 1b)*bgresist

      ;; a) write out resistance mask with extended frame of 0b
      ext = bytarr(sz[1] + eew2, sz[2] + eew2)
      ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = resist
      write_tiff,'mask.tif',ext, compression=1

      IF info.my_os EQ 'windows' THEN BEGIN
        ggeo='..\spatcon\ggeo64.exe'
        file_copy, ggeo, info.dir_tmp + 'ggeo.exe', /overwrite
      ENDIF ELSE IF info.my_os EQ 'apple' THEN BEGIN
        ggeo='../spatcon/ggeo_mac'
        file_copy, ggeo, info.dir_tmp + 'ggeo', /overwrite
      ENDIF ELSE BEGIN
        ggeo='../spatcon/ggeo_lin64'
        file_copy, ggeo, info.dir_tmp + 'ggeo', /overwrite
      ENDELSE
      desc = 'GTB_RES, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
      desc2 = 'GTB_ISO, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'

      tit = 'Restoration Planner, BG-resistance: ' + c_size + '%'
      msg = 'Processing restoration pathways, please wait...'
      progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=400, title=tit, /cancel)
      progressBar -> Start

      ;; prepare temporary output
      expense_t = 'EXP_' + c_size & statsfiletxt = 'restoration_' + c_size + '.txt'

      close, 11 & openw, 11, statsfiletxt 
      IF info.my_os EQ 'windows' THEN BEGIN
        printf, 11, format='(5(a16),2x,8(a17))', 'RESTORE', 'SIZE_A', 'SIZE_B', 'REST_PIX', 'AVDIST_RP',$
          expense_t, 'EFFIC', 'ECA_ORIG', 'ECA_NEW', 'DELTA_ECA', 'COH_ORIG', 'COH_NEW', 'DELTA_COH'
      ENDIF ELSE BEGIN
        printf, 11, format='(5(a16),2(a14),3x,6(a16))', 'RESTORE', 'SIZE_A', 'SIZE_B', 'REST_PIX', 'AVDIST_RP',$
          expense_t, 'EFFIC', 'ECA_ORIG', 'ECA_NEW', 'DELTA_ECA', 'COH_ORIG', 'COH_NEW', 'DELTA_COH'       
      ENDELSE
          
      statsfile = 'restoration_' + c_size + '.csv'
      close,1 & openw, 1, statsfile, error=error
      IF (error NE 0) then begin
        msg = 'Please close your spreadsheet application, then try again.' + $
          string(10b) + 'Returning...'
        res = dialog_message(msg, /information)
        progressBar -> Destroy
        Obj_Destroy, progressBar
        close,1 & popd
        GOTO, fin
      ENDIF    
      printf, 1, 'RESTORE, SIZE_A, SIZE_B, REST_PIX, AVDIST_RP,' + expense_t + $
        ', EFFIC, ECA_ORIG, ECA_NEW, DELTA_ECA, COH_ORIG, COH_NEW, DELTA_COH' 

      ;; get LCP and importance for these new links
      nr_connections = nrtenlinks
      FOR il = 0, nr_connections - 1 DO BEGIN
        IF progressBar -> CheckCancel() THEN BEGIN
          res = Dialog_Message('Restoration-processing cancelled by user.')
          progressBar -> Destroy
          Obj_Destroy, progressBar
          close,1 & popd
          GOTO, fin
        ENDIF

        ;; each link in 'tenlinks' connects the two
        ;; components laidx and lbidx. They correspond to
        ;; linka and linkb in the image
        laidx = fix(strmid(tenlinks(il), 0, 1)) & linka = lcompidx(laidx - 1)
        lbidx = fix(strmid(tenlinks(il), 6, 1)) & linkb = lcompidx(lbidx - 1)

        ;; setup and get LCP, we do this in dir_tmp
        ;; we need 3 input files:
        ;; mask.tif [1,100]b + marker1.tif [0,1]b + marker2.tif [0,1]b
        ;; -> 2 output files:
        ;; out.tif (cost a+b) + lcp.tif [0,1]b
        ;

        ;; setup marker maps
        ;; b) marker1 (linka) with extended frame of missing (3b)
        ext = temporary(ext)*0b + 3b
        marker = lbl_comp eq linka & q1b = where(marker eq 1b, /l64)
        if ctqm gt 0 then marker[qm] = 3b
        ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = marker
        write_tiff,'marker1.tif', ext, compression=1
        qm1 = where(ext eq 1b, /l64)

        ;; c) marker2 (linkb) with extended frame of missing (3b)
        ext = temporary(ext)*0b + 3b
        marker = lbl_comp eq linkb & q2b = where(marker eq 1b, /l64)
        if ctqm gt 0 then marker[qm] = 3b
        ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = marker
        write_tiff,'marker2.tif', ext, compression=1
        qm2 = where(ext eq 1b, /l64)

        ;; check if A and B are divided or can not be connected due to a path of missing pixels
        ext[qm1] = 1b
        im = (ext eq 3b) - 1b
        im = label_region(im,/all_n,/ulong)
        v1 = mean(im[qm1]) & v2 = mean(im[qm2])
        im = 0 & eps=1.0e-4 & condition = abs(v1 - v2) lt eps
        IF condition EQ 0b THEN BEGIN
          ;; A and B can not be connected
          GOTO, skip_restore
        ENDIF

        ;; d) markers in extended image, without missing (3b)
        ext = temporary(ext) eq 1b
        write_tiff,'markers.tif', ext, compression=1

        IF info.my_os EQ 'windows' THEN spawn, 'ggeo.exe', log, / hide ELSE spawn, './ggeo', log

        ;; get cost map
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        cost = read_tiff('out.tif')
        cost = cost[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]
        ;; long 32
        micost = min(cost)
        mincost = round(micost/2.0)  ;, /l64)
        maxcost = max(cost)
        if ctqm gt 0 then maxcost=round((max((cost lt maxcost)*cost))/2.0) else maxcost=round(maxcost/2.0)
        ;; test if image is too large for long 32 processing
        if maxcost lt 0 then begin
          msg = 'Image is too large for current implementation.' + string(10b) + 'Returning.'
          res = dialog_message(msg, / information) & popd & GOTO, fin
        endif

        ;; get markers and least cost path
        ;; 1) mark LCP in black
        lcp = read_tiff('lcp.tif')
        lcp = lcp[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]
        lcp = where(lcp gt 0b, ct_lcp, /l64)
;;;        image0[lcp] = 103b

        ;; convert ulong to long 32
        cost = round(temporary(cost)/2.0)
        ;; set up cost image for display, range 0-100 cost, objects 101, missing 102, lcp 103
        cost = BytScl(cost, min = mincost, max = maxcost, Top = 100)
        cost[q1b] = 101b & cost[q2b] = 101b
        cost[lcp] = 103b & if ctqm gt 0 then cost[qm] = 102b

        ;; save the image, use normalised colortable
        restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
        fname = 'restoration_' + c_size + '_' + strmid(tenlinks(il),0,1) + strmid(tenlinks(il),0,1,/reverse) + '_isochrone.tif'
        if info.is_geotiff eq 1 then begin
          write_tiff,fname, rotate(cost,7), description = desc2, geotiff = * info.geotiffinfo, red = r, green = g, blue = b, compression = 1
        endif else begin
          write_tiff,fname, rotate(cost,7), description = desc2, red = r, green = g, blue = b, compression=1
        endelse
        ;; back to MSPA-colors
        restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b
        ;; end cost
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;; get LCP total length restore pixels
        ;; total length is 2 pixels less because it starts/ends in the targets
        tenlinkslength(0, il) = ct_lcp - 2
        path = lbl_comp[lcp] & rp = where(path eq 0, restpix, /l64) & tenlinkslength(1, il) = restpix

        ;; get accumulated cost of those restore pixels
        ;; use the sum of the resitance values of the restore pixels along the LCP
        ;; cost image is the sum of A and B, so build the average to get the actual cost for the path
        expense = resist[lcp] & expense = long64(total(expense[rp]))

        ;; LCP starts in linka and ends in linkb
        ;; 2) find out if this path passes through other components
        pts = lbl_comp[lcp]
        ;; test for and add intermediate components
        h = histogram(pts) & qintcomp = where(h GT 0)
        ;; remove background (0) and start/end comnponent
        q = where(qintcomp eq linka) & qintcomp[q] = 0
        q = where(qintcomp eq linkb) & qintcomp[q] = 0
        q = where(qintcomp gt 0, ct_qintcomp)
        if ct_qintcomp gt 0 then qintcomp = qintcomp[q]       
        imlcp = imlcp0
        ;; overplot intermediate components, beige
        IF ct_qintcomp GT 0 THEN BEGIN
          FOR i = 0, ct_qintcomp - 1 DO BEGIN
            q = where(lbl_comp EQ qintcomp(i), ct)
            if ct gt 0 then imlcp[q] = 58b
          ENDFOR
        ENDIF
        ;; get location of restore pixels
        rp = where(imlcp[lcp] eq 0b, ct)
        imlcp[lcp[rp]] = 33b  ;; overplot restore pixels in red
        image0[lcp[rp]] = 33b  ;; overplot restore pixels in red in summary display image
        imlcp[q1b] = 105b & imlcp[q2b] = 176b ;; overplot start (blue) / target (lightblue) component

        ;; save the image
        fname = 'restoration_' + c_size + '_' + strmid(tenlinks(il),0,1) + strmid(tenlinks(il),0,1,/reverse) + '.tif'
        if info.is_geotiff eq 1 then begin
          write_tiff,fname, rotate(imlcp,7), description = desc, geotiff = * info.geotiffinfo, red = r, green = g, blue = b, compression = 1
        endif else begin
          write_tiff,fname, rotate(imlcp,7), description = desc, red = r, green = g, blue = b, compression=1
        endelse
        
        ;; build average distance of restore pixels
        quality = mean(morphdist[lcp[rp]])
        
        fg = imlcp GT 0b & IF ctqm GT 0 THEN fg[qm] = 0b
        eew = 2  & eew2 = eew * 2
        ext = temporary(ext)*0b
        ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = temporary(fg)
        lbl = label_region(ext, / all, / ulong) 
        hca = histogram(lbl, / l64) & lbl = 0
        pcnum = total(hca(1: * )^2, / double)

        ;;%-increase in DOC
        ECA = sqrt(pcnum) & ECA_maxnew = ECA_max + restpix & delta_eca = ECA - ECA_orig
        DOC = ECA/ECA_maxnew*100.0
        gain = doc - doc_orig
        tenlinksimp(il) = gain
        effic = delta_eca / float(expense)
        ;rac = ECA_maxnew / data_area *100.0
        ;delta_rac = rac - RAC_orig

        rowstr = tenlinks(il) + ',' + strtrim(h_comp_area(linka), 2) + ',' + strtrim(h_comp_area(linkb), 2) + ',' + $
          strtrim(tenlinkslength(1, il), 2) + ',' + strtrim(quality,2) + ',' + strtrim(expense,2) + ',' + strtrim(effic,2) + ',' + $
          strtrim(eca_orig,2) + ',' + strtrim(eca,2) + ',' + strtrim(delta_eca,2) + ',' + $
          strtrim(doc_orig,2) + ',' + strtrim(doc,2) + ',' + strtrim(tenlinksimp(il), 2)     
        printf, 1, rowstr

        ;; add output for xdisplayfile
        IF info.my_os EQ 'windows' THEN BEGIN
          printf, 11, format = '(13(a18,2x))',tenlinks(il), strtrim(h_comp_area(linka), 2), $
            strtrim(h_comp_area(linkb), 2), $
            strtrim(tenlinkslength(1, il), 2), strtrim(quality,2), strtrim(expense,2), strtrim(effic,2), $
            strtrim(eca_orig,2), strtrim(eca,2), strtrim(delta_eca,2), $
            strtrim(doc_orig,2), strtrim(doc,2), strtrim(tenlinksimp(il), 2)
        ENDIF ELSE BEGIN
          printf, 11, format = '(13(a14,2x))',tenlinks(il), strtrim(h_comp_area(linka), 2), $
            strtrim(h_comp_area(linkb), 2), $
            strtrim(tenlinkslength(1, il), 2), strtrim(quality,2), strtrim(expense,2), strtrim(effic,2), $
            strtrim(eca_orig,2), strtrim(eca,2), strtrim(delta_eca,2), $
            strtrim(doc_orig,2), strtrim(doc,2), strtrim(tenlinksimp(il), 2)
        ENDELSE       
        skip_restore:

        ;; update progress bar
        stepn = (il + 1.0)/nr_connections * 100.0
        progressBar -> Update, stepn

      ENDFOR
      printf, 11, ''
      printf, 11, 'Note: '
      printf, 11, 'The analysis may include alternative, parallel pathways and bifurcations in the Background having the same isochrone value.'
      printf, 11, 'These features may lead to an increased number of: restore pixels (REST_PIX) and expense (' + expense_t + '), resulting in'
      printf, 11, 'a decrease in Efficiency (EFFIC), meaning the actual Efficiency may be higher.'
      printf, 11, 'Please verify the individual paths after saving the result.'
      close, 1, 11
      progressBar -> Destroy
      Obj_Destroy, progressBar

      xdisplayfile, info.dir_tmp + statsfiletxt, title = tit, width = 250, /grow

      print, 'Restoration comp.time [sec]: ', systime( / sec) - time0

      popd ;; return to working directory

      ;; store stuff in the info structure
      info.autostretch_id = 0
      * info.nw_ids = lbl_comp
      ;; overwrite LCP with component colors
      FOR i = 1l, max5 DO BEGIN
        q = where(lbl_comp EQ lcompidx(i - 1)) & image0[q] = cl(i)
      ENDFOR
      q = 0
      ;; add back missing
      IF ctqm GT 0 THEN image0[qm] = 129b
      qm = 0
      morphdist = 0

      * info.process = image0
      * info.nw_hnw = h_comp_area
      lbl_comp = 0 & image0 = 0 & h_comp_area = 0
      * info.fr_image = * info.process
      info.add_title = ' (restoration path between ' + strtrim(max5,2) + ' largest objects, BGresist: ' + c_size + '%)'

      ;; reset mspa
      info.is_mspa = 0 & info.is_fragm = 0 & info.is_contort = 0 & info.mspa_stats_show = 0b
      info.do_mspa_stats_id = 0 & info.is_cost = 2

    END



    ;;===================================================================================================
    'cost_map':  BEGIN   ;;;;;;;;;;;;;;;;;;    cost map A/AB   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;===================================================================================================
      ;; we assume the current image is the resistance map

      ;; 1) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
        info.selsubregion_id = 0
        ;; deactivate zoomfactor selector
        widget_control, info.w_zoomfac, sensitive = 1
        widget_control, info.w_selsubregion, $
          set_value = 'Zoom Mode'
        ;; restore the prezoomed process image
        * info.process = * info.prezoomprocess
        ;; disable button and enable motion events in w_draw
        widget_control, info.w_draw, Draw_Motion_Events = 1
        widget_control, info.w_draw, Draw_Button_Events = 0
        info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF

      ;; we must process the full resolution image
      resist = * info.fr_image

      ;; test if current image is a resistance map
      s_resist = size(resist)
      tit = 'Isochrone Map setup information:'
      head = 'Please load a Resistance map: [(0), (2), 3-100] byte' + string(10b) + string(10b)
      IF s_resist[3] NE 1 THEN BEGIN ;; not byte
        msg = head + 'Resistance map must have data type byte.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information, title = tit)
        GOTO, fin
      ENDIF
      ;; test for resistance = 1, not allowed
      q = total(resist eq 1b)
      if q gt 0.0 then begin
        msg = head + 'Resistance values of 1 are not allowed.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information, title = tit)
        GOTO, fin
      endif

      ;; test for resistance > 100, not allowed
      if max(resist) gt 100b then begin
        msg = head + 'Resistance values higher than 100 are not allowed.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information, title = tit)
        GOTO, fin
      endif

      ;; read marker map
      ;;=========================================================================================
      res = dialog_read_image(file = im_file, get_path = path2file, $
        image = marker, path = info.dir_data, TITLE='Select the Marker map', $
        FILTER='.tif', /fix_filter)
      IF res EQ 0 THEN GOTO, fin ;; 'cancel' was selected
      
      s = size(marker)
      IF s[0] EQ 0 THEN BEGIN
        res = dialog_message('Invalid image format or directory' + $
          string(10b) + 'instead of file selected.' + $
          string(10b) + 'Returning...', / information) & GOTO, fin
      ENDIF

      ;; transfer image to 2-D if necessary
      IF s[0] EQ 3 THEN BEGIN ;; 3-dim image
        IF s[1] EQ 3 THEN BEGIN ;; 3 band image
          s = size(marker) & dim_pos = where(s EQ 3) & dim_pos = dim_pos(1)
          ;;remap true color images
          marker = color_quan(marker, dim_pos, r, g, b, / map_all)
          tvlct, r, g, b & info.disp_colors_id = 12 & info.ctbl = - 1
        ENDIF ELSE BEGIN
          msg = 'Please provide a single-band image.' + string(10b) + 'Returning...'
          res = dialog_message(msg, / information)
          GOTO, fin
        ENDELSE
      ENDIF ELSE IF s[0] EQ 2 THEN BEGIN
        info.ctbl = 0 & info.disp_colors_id = 0
      ENDIF ELSE BEGIN
        msg = 'Please provide a single-band image.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDELSE

      ;; test for byte
      IF s[3] NE 1 THEN BEGIN ;; not byte
        msg = 'Marker map must have data type byte.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF

      ;; test for same dimension
      q = (s[1] eq s_resist[1]) + (s[2] eq s_resist[2])
      IF q NE 2 THEN BEGIN
        msg = 'Dimensions of Marker and Resistance map differ. ' + string(10b) + 'Returning.'
        res = dialog_message(msg, / information) & GOTO, fin
      ENDIF

      ;; test for minimum set of required values:
      marker_vals = where(histogram(marker) gt 0) & n_marker_vals = n_elements(marker_vals)

      case eventvalue2 of
        'cost_map_aa': begin ;; [0, 1]
          markmax = 1
          if n_elements(marker_vals) lt 2 then begin
            msg = 'Marker map must have at least the following values: ' + string(10b) + $
              '0b: background '  + string(10b) + $
              '1b: foreground point or object A'  + string(10b) + 'Returning...'
            res = dialog_message(msg, / information) & GOTO, fin
          endif

          condition = marker_vals[0] eq 0 and marker_vals[1] eq 1
          IF condition NE 1b THEN BEGIN
            msg = 'Marker map must have at least the following values: ' + string(10b) + $
              '0b: background '  + string(10b) + $
              '1b: foreground point or object A'  + string(10b) + 'Returning...'
            res = dialog_message(msg, / information) & GOTO, fin
          ENDIF
        end

        'cost_map_ab': begin  ;; [0, 1, 2]
          markmax = 2
          if n_elements(marker_vals) lt 3 then begin
            msg = 'Marker map must have at least the following values: ' + string(10b) + $
              '0b: background '  + string(10b) + $
              '1b: foreground point or object A'  + string(10b) + $
              '2b: foreground point or object B'  + string(10b) + $
              'Returning.'
            res = dialog_message(msg, / information) & GOTO, fin
          endif

          condition = marker_vals[0] eq 0 AND marker_vals[1] eq 1 AND marker_vals[2] eq 2
          IF condition NE 1b THEN BEGIN
            msg = 'Marker map must have at least the following values: ' + string(10b) + $
              '0b: background '  + string(10b) + $
              '1b: foreground point or object A'  + string(10b) + $
              '2b: foreground point or object B'  + string(10b) + $
              'Returning.'
            res = dialog_message(msg, / information) & GOTO, fin
          ENDIF

          ;; test if the two objects are seperated
          im = bytarr(s[1]+2,s[2]+2)+255b
          im[1:s[1],1:s[2]] = (marker eq 1b OR marker eq 2b)
          im = label_region(im,/all_n,/ulong) & condition = max(im) & im=0
          IF condition EQ 1 THEN BEGIN
            ;; A and B intersect
            msg = 'Marker object A and B should not intersect.' + string(10b) + 'Returning.'
            res = dialog_message(msg, / information) & GOTO, fin
          ENDIF

          IF n_marker_vals GE 4 THEN BEGIN
            IF marker_vals[3] eq 3 THEN BEGIN ;; we have missing data
              ;; test if A and B are within the same blob, else we can not get a LCP
              ;; how: flood-fill complement of missing and check if A and B are in different blobs
              ;; labeling must be done on extended image to avoid problems if objects are at the image border
              im = bytarr(s[1]+2,s[2]+2)+255b
              im[1:s[1],1:s[2]] = (marker eq 3b) - 1b
              im = label_region(im,/all_n,/ulong) & im = im[1:s[1],1:s[2]]
              q = where(marker eq 1b) & v1 = mean(im[q])
              q = where(marker eq 2b) & v2 = mean(im[q])
              im = 0 & eps=1.0e-4 & condition = abs(v1 - v2) lt eps

              IF condition EQ 0b THEN BEGIN
                ;; A and B are disjoint
                msg = 'Marker object A and B can not be connected.' + string(10b) + 'Returning.'
                res = dialog_message(msg, / information) & GOTO, fin
              ENDIF
            ENDIF
          ENDIF
        end
      endcase

      ;; ensure unique appearance of each marker object
      for id = 1, markmax do begin
        q=byte(id)
        marker2 = bytarr(s[1]+2, s[2]+2)
        marker2[1:s[1],1:s[2]] = marker
        if max(label_region(marker2 eq q, /ALL_NEIGHBORS,/ulong)) ge 2 then begin
          msg = 'Marker map must have only one object with value: ' + strtrim(fix(q),2) + $
            ' byte' + string(10b) + 'Returning.'
          res = dialog_message(msg, / information) & GOTO, fin
        endif
        marker2=0
      endfor

      ;; reset mspa
      info.is_mspa = 0 & info.mspa_stats_show = 0b & info.is_fragm = 0 & info.is_contort = 0
      info.do_mspa_stats_id = 0 & info.is_cs22 = 0 & info.is_nw = 0 & info.is_cost = 1
      info.do_label_groups_id = 0

      msg = 'Processing isochrone map, please wait...'
      tit = 'Isochrone map analysis'
      progressBar = Obj_New("SHOWPROGRESS", message = msg, title = tit, xsize=300)
      progressBar -> Start

      ;; setup and calculate cost map
      ;;================================================================================
      pushd, info.dir_tmp
      list = file_search() & nl = n_elements(list)
      IF list[0] NE '' THEN FOR i = 0, nl -1 DO file_delete, list[i], / allow_nonexistent, / quiet, / recursive
      
      sz = size(marker) & eew = 2  & eew2 = eew * 2

      ;; put stuff in place
      ;; use enlarged images to avoid getting the zero line at the image boundaries
      ;; get missing data in original resolution
      qm = where(rotate(marker,7) eq 3b, ctqm)
      marktmp = marker 
      q2b = where(marker eq 2b,ct_q2b)
      if ct_q2b gt 0 then marktmp[q2b] = 0b      
;;;      write_tiff,'marker1.tif',marktmp,compression=1
      ;; marker1 with extended frame of missing (3b)
      ext = bytarr(sz[1] + eew2, sz[2] + eew2) + 3b
      ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = marktmp      
      write_tiff,'marker1.tif',rotate(ext,7),compression=1
            
      ;; reassign resistance image: FG-1 for cost analysis
;;;      q = where(resist eq 2b) & resist[q] = 1b & q = 0
;;;      ext = bytarr(sz[1] + eew2, sz[2] + eew2)
;;;      ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = resist   
;;;      write_tiff,'mask.tif', rotate(ext,7) ,compression=1

      ;; reassign resistance image for cost analysis: FG-1 
      ;; write out resistance mask with extended frame of 0b
      q = where(resist eq 2b) & resist[q] = 1b & q = 0
      ext = bytarr(sz[1] + eew2, sz[2] + eew2)
      ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = resist
      write_tiff,'mask.tif', ext, compression=1
      
;      resisttmp = rotate(resist,7)
;      write_tiff,'mask.tif',resisttmp,compression=1

      IF info.my_os EQ 'windows' THEN BEGIN
        IF (!version.memory_bits EQ 64) THEN ggeo='..\spatcon\ggeo64.exe' ELSE $
          ggeo='..\spatcon\ggeo32.exe'
        file_copy, ggeo, 'ggeo.exe', /overwrite
      ENDIF ELSE IF info.my_os EQ 'apple' THEN BEGIN
        ggeo='../spatcon/ggeo_mac' & file_copy, ggeo, 'ggeo', /overwrite
      ENDIF ELSE BEGIN
        ggeo='../spatcon/ggeo_lin64' & file_copy, ggeo, 'ggeo', /overwrite
      ENDELSE

      progressBar -> Update, 5

      case eventvalue2 of
        'cost_map_aa': begin ;; [0, 1]
          widget_control, / hourglass

          ;; run ggeo in tmp
          IF info.my_os EQ 'windows' THEN spawn, 'ggeo.exe', log, / hide ELSE spawn, './ggeo', log
          progressBar -> Update, 90

          cost = read_tiff('out.tif')
          cost = cost[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]
          ;; long64:
          ;; mincost = long64((min(cost-1) + 1)/2.0)
          ;; cost = round(temporary(cost)/2.0,/l64)
          ;; long32
          mincost = round((min(cost-1) + 1)/2.0)
          cost = round(temporary(cost)/2.0)
          maxcost=max(cost)
          ;; the actual cost map
          marker=rotate(marker,7)
          qmarker = where(marker eq 1b)
          if ctqm gt 0 then maxcost=max((cost lt maxcost)*cost)
          ;; test if image is too large for long 32 processing
          if maxcost lt 0 then begin
            msg = 'Image is too large for current implementation.' + string(10b) + 'Returning.'
            res = dialog_message(msg, / information) & popd
            progressBar -> Destroy
            Obj_Destroy, progressBar
            GOTO, fin
          endif

          ;; test for unreachable pixels, i.e., a river cutting off part of the image
          q = where(cost lt -2, ct, /l64)
          ;; set up cost image for display, range 0-100 cost, objects 101, missing 102, lcp 103
          cost = BytScl(cost, min=0, max=maxcost, Top = 100)
          if ct gt 0 then cost[q] = 104b ;; unreachable
          cost[qmarker] = 101b & if ctqm gt 0 then cost[qm] = 102b
          info.add_title = ' (isochrone map A)'
        end

        'cost_map_ab': begin ;; [0, 1, 2]
          widget_control, / hourglass
          marktmp = marker
          q1b = where(marktmp eq 1b,ct_q1b, /l64)
          if ct_q1b gt 0 then marktmp(q1b) = 0b
          if ct_q2b gt 0 then marktmp(q2b) = 1b
          ;; marker2 with extended frame of missing (3b)
          ext = bytarr(sz[1] + eew2, sz[2] + eew2) + 3b
          ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = marktmp         
          write_tiff,'marker2.tif',rotate(ext,7),compression=1
          
          marker = (marker - 1b) lt 2b  ;; marker mask without missing data of 3b
          ext = bytarr(sz[1] + eew2, sz[2] + eew2)
          ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = marker
          write_tiff,'markers.tif',rotate(ext,7),compression=1

          progressBar -> Update, 8

          IF info.my_os EQ 'windows' THEN spawn, 'ggeo.exe', log, / hide ELSE spawn, './ggeo', log
          progressBar -> Update, 90
          ;; cost of A, B, read and  set unreachable pixels to zero
          cost = read_tiff('out.tif')
          cost = cost[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]
          ;; long64:
          ;; cost = round(temporary(cost)/2.0,/l64)
          ;; maxcost = max(cost)
          ;; if ct_miss gt 0 then begin
          ;;    maxcost=max((cost lt maxcost)*cost)
          ;; endif
          ;; mincost = min(cost)

          ;; long 32
          mincost = round(min(cost)/2.0)
          maxcost = max(cost)
          if ctqm gt 0 then maxcost=round((max((cost lt maxcost)*cost))/2.0) else maxcost=round(maxcost/2.0)

          ;; test if image is too large for long 32 processing
          if maxcost lt 0 then begin
            msg = 'Image is too large for current implementation.' + string(10b) + 'Returning.'
            res = dialog_message(msg, / information) & popd
            progressBar -> Destroy
            Obj_Destroy, progressBar
            GOTO, fin
          endif
          ;; convert ulong to long 32
          cost = round(temporary(cost)/2.0)
          ;; end long 32

          ;; get markers and least cost path
          marker=rotate(marker,7)
          qmarker = where(marker eq 1b, /l64)
          lcp = read_tiff('lcp.tif') 
          lcp = lcp[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]
          lcp = where(lcp gt 0b, ct_lcp, /l64)

          ;; test for unreachable pixels, i.e., a river cutting off part of the image
          ;; for long 64: q = where(cost gt maxcost, ct)
          q = where(cost lt -2, ct, /l64)
          ;; set up cost image for display, range 0-100 cost, objects 101, missing 102, lcp 103
          cost = BytScl(cost, min = mincost, max = maxcost, Top = 100)
          cost[lcp] = 103b & cost[qmarker] = 101b & if ctqm gt 0 then cost[qm]= 102b
          if ct gt 0 then cost[q] = 104b ;; unreachable
          info.add_title = ' (isochrone map AB)'
        end
      endcase
      ;; clean up
      list = file_search() & nl = n_elements(list)
      IF list[0] NE '' THEN FOR i = 0, nl -1 DO file_delete, list[i], / allow_nonexistent, / quiet, / recursive
      popd ;; back to the roots
      * info.process = temporary(cost)
      * info.fr_image = * info.process
      restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
      info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 5 ;; entropy

      ;; cost range
      delta = 100.0
      costrange = floor([0.1, 0.25, 0.5, 0.6, 0.75, 0.9]*delta)
      crstr = strtrim(costrange,2) & info.costrange = costrange
      widget_control, info.w_labelstr, set_value = 'Isochrone range: '
      widget_control, info.w_label_t1, set_value = ['X',crstr[0:2]]
      widget_control, info.w_label_t2, set_value = ['X',crstr[3:5]]
      widget_control, info.w_label_t1, set_combobox_select = 1 & info.label_t1 = costrange[0]
      widget_control, info.w_label_t2, set_combobox_select = 1 & info.label_t2 = costrange[3]
      ;; end of coast map

      progressBar -> Destroy
      Obj_Destroy, progressBar

    END 

    ;;===================================================================================================================
    ;;===================================================================================================================
    ;;=================================  END of    R E S T O R A T I O N   ==============================================
    ;;===================================================================================================================
    ;;===================================================================================================================

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;        E N T R O P Y
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   'frag_entropy':  BEGIN
      widget_control, / hourglass
      ;; 1) check for input compliance:
      MSPA_Compliance, info.fname_input, * info.fr_image, info.immaxsizeg, 1, result
      IF result EQ 0 THEN GOTO, fin  ;; invalid input

      ;; 2) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
         info.selsubregion_id = 0
         ;; deactivate zoomfactor selector
         widget_control, info.w_zoomfac, sensitive = 1
         widget_control, info.w_selsubregion, $
                         set_value = 'Zoom Mode'
         ;; restore the prezoomed process image
         * info.process = * info.prezoomprocess
         ;; disable button and enable motion events in w_draw
         widget_control, info.w_draw, Draw_Motion_Events = 1
         widget_control, info.w_draw, Draw_Button_Events = 0
         info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF

      ;; we must process the full resolution image
      image0 = * info.fr_image 
      ;; test for maximum fragmentation on full image area
      ;;entropy_mspainp,(randomu(5l,xdim,ydim) ge 0.5)+1b,Cmax
      ;;
      ;;checkerboard:  
      ;cb = bytarr(1000,1000)+1b
      ; for j = 0, 998, 2 do for i = 0, 998, 2 do cb(i,j) = 2b
      ; for j = 1, 999, 2 do for i = 1,999, 2 do cb(i,j) = 2b
      ; entropy_mspainp,cb,cmax & print,cmax   
      ;; cmax = 1.50051 but this is caused by the replicated boundaries
      ;; if you use a proper checkerboard inside the function,
      ;; meaning the array ext is the checkerboard, then the entropy is zero
      
      entropy_mspainp, image0, 0, Ent_image
      z20=strtrim(Ent_image,2)
      
      ;; test if we only want the image entropy
      if strmid(eventValue2, 13, 2) eq 'im' then begin
        info.add_title = ' (Frag(Entropy_Index): ' + z20 + ')'
        info.is_fragm = 0 ;; not spatial fragmentation
        goto, redisplay
      endif
      
      q = size(image0,/dim) & xdim=q[0] & ydim=q[1] & entro = image0 * 0b
            
      ;; divide image in subtiles of dx, dy
      dx = 50 & dy=dx & imgminsize=(xdim<ydim)
      IF imgminsize lt 500 THEN BEGIN
        res = dialog_message('Entropy requires minimum image size ' + $
          string(10b) + 'of 500 x 500 pixels.' + string(10b) + 'Returning...', / information)
        info.is_fragm = 0 & GOTO, fin
      ENDIF
      
      ;; moving window approach
      ;; ====================================
      if strmid(eventValue2, 13, 2) eq 'mw' then begin
        msg = 'Warning'+ string(10b) + 'Compared to the default entropy calcualtion the moving window' + $
          string(10b) + 'calculation is about 250 times slower and differs only slightly.' + $
          string(10b) + '(Example: processing time for a 1000x1000 image is 1 minute)'+ $
          string(10b) + 'Are you sure you want to do this?'
        res = dialog_message(msg, /question)
        if res eq 'No' then begin
          info.is_fragm = 0 & goto,fin
        endif
          
        
        time0 = systime( / sec)

        ;; precise way via moving window
        entropy_mspainp, image0, 1, Ent_image, entro

        ;; get range of entro
        e_min1=min(entro, max=e_max1) & dy1=e_max1-e_min1
        ;; smooth
        entro = smooth(entro, 33, / edge_truncate, /nan, missing=1.0)

        ;; intensity range decreases due to smoothing:
        ;; scale back to original range
        e_min2=min(entro, max=e_max2) & dy2=e_max2-e_min2
        entro = e_min1+((float(entro)-e_min2)*dy1/dy2)

        goto, endfrag
      endif

      time0 = systime( / sec)

      ;; default, fast way 
      ;; ====================================
      ;; extend the image to avoid border effects
      ext = bytarr(xdim + 2*dx, ydim + 2*dy) & sz2=size(ext,/dim)
      ext[dx:dx + xdim - 1, dy:dy + ydim - 1] = image0
      ext[0:dx-1,    dy:dy+ydim-1] = reverse(image0[0:dx-1,*]) ;left
      ext[dx+xdim:*, dy:dy+ydim-1] = reverse(image0[xdim-dx:*,*]) ;right
      ext[dx:dx + xdim - 1, 0:dy-1] = reverse(image0[*, 0:dy-1],2) ;top
      ext[dx:dx + xdim - 1, dy+ydim:*] = reverse(image0[*, ydim-dy:*],2) ;bottom
      entro=ext*0b
   
      zstep=0
      fragagain1:
      ;; center area of image where dx/dy subtiles can be applied
      xdim2 = xdim + 2*dx & ydim2 = ydim + 2*dy
      xb=xdim2 mod dx & x1=xb/2 & x2=xdim2-xb  
      yb=ydim2 mod dy & y1=yb/2 & y2=ydim2-yb
      xtiles=xdim2/dx & ytiles=ydim2/dy
      
      for idy=0,ytiles-1 do begin
        yy=idy*dy+y1
        for idx=0,xtiles-1 do begin
          xx=idx*dx+x1
          subtile=ext[xx:xx+dx-1, yy:yy+dy-1]
          entropy_mspainp, subtile, 0, z
          entro[xx:xx+dx-1, yy:yy+dy-1]=z
        endfor
      endfor
      
      if zstep eq 0 then begin
        entro50=entro & entro=ext*0b & zstep=1 & dx = 33 & dy=dx & goto, fragagain1
      endif     

;      if zstep eq 1 then begin
;        entro33=entro & entro=ext*0b & zstep=2 & dx = 17 & dy=dx & goto, fragagain1
;       endif
;      entro = (temporary(entro50)+temporary(entro33)+temporary(entro))/3.0 < 100.0

      entro = (temporary(entro50)+temporary(entro))/2.0 < 100.0    
      dx = 50 & dy=dx
      entro = entro[dx:dx + xdim - 1, dy:dy + ydim - 1]
      
      ;; get range of entro
      e_min1=min(entro, max=e_max1) & dy1=e_max1-e_min1     
      ;; smooth
      entro = smooth(entro, 33, / edge_truncate, /nan, missing=1.0)
           
      ;; intensity range decreases due to smoothing: 
      ;; scale back to original range
      e_min2=min(entro, max=e_max2) & dy2=e_max2-e_min2
      entro = e_min1+((float(entro)-e_min2)*dy1/dy2)    


      endfrag: 
      
      ;; reset mspa
      info.is_mspa = 0 & info.mspa_stats_show = 0b & info.is_fragm = 1 & info.is_contort = 0
      info.do_mspa_stats_id = 0 & info.is_cs22 = 0 & info.is_nw = 0 & info.is_cost = 0
      info.do_label_groups_id = 0


      
      ;print, 'fragm proc.time: ', systime( / sec) - time0   
      qfg = where(image0 eq 2b, /l64) & z21=strtrim(mean(entro[qfg]),2)
      ;; convert to byte and apply mask
      entro = byte(round(entro)) * (image0 eq 2b)
      z22=strtrim(fix(min(entro[qfg])),2)
      z23=strtrim(fix(max(entro[qfg])),2)
      info.add_title = ' (frag(Entropy): ' + z20 + ';   FG-only: '+ z21 + ', Range: [' + z22 +','+z23 + '])'
      
      ;; add BG(101b), Missing(102b) 
      entro = temporary(entro) + (image0 eq 1b)*101b + (image0 eq 0b)*102b
      * info.nw_ids = entro
      * info.process = temporary(entro)
      * info.fr_image = * info.process
      restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
      info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 5 ;; entropy 
      widget_control, info.w_labelstr, set_value = 'Fragmentation range: '
      widget_control, info.w_label_t1, set_value = ['X','10','30','50']    
      widget_control, info.w_label_t2, set_value = ['X','60','70','80']
      widget_control, info.w_label_t1, set_combobox_select = 1 & info.label_t1 = 10
      widget_control, info.w_label_t2, set_combobox_select = 1 & info.label_t2 = 60
      skipspat:
   END
   
   ;;*****************************************************************************************************

   'batch_ent':  BEGIN
      tit = 'Select (Geo-)Tif-files'
      im_file = $
         dialog_pickfile(Title = tit, get_path = path2file, $
         path = info.dir_data, default_extension = 'tif', / fix_filter, $
         / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
       IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
       
       ;; test that the directory of the selected files has no sub-directories
       ;; this will also ensure no output file is opened in excel or thelike
       pushd, path2file
       list = file_search() & nl = n_elements(list) & nr_dir = 0
       for idx = 0, nl-1 do begin
         q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
       endfor
       IF nr_dir GT 0 THEN BEGIN
         msg = 'The directory of your Batch Entropy input files contains sub-directories.'  +  string(10b) +  string(10b) + $
           'Please set up a new directory having Batch Entropy input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
       ENDIF
       popd
       
       ;; test that we can write into the parent directory or if it exists already
       batch_type = 'batch_FragEntropy'
       dd = file_dirname(im_file[0], / mark_directory)
       dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
       res = file_test(dir_batch, /directory, /write)
       if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
         res = dialog_message(msg,/question)
         If res eq 'No' then goto, fin
         ;; empty it
         pushd, dir_batch
         list = file_search() & nl = n_elements(list)
         if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
         popd
       endif else begin ;; does not exist yet, create it
         file_mkdir, dir_batch
       endelse
       
       ;; files are now selected, reset the GUI
       ;;========================================================================
       ;; reset the front image and block any events
       ;;========================================================================
       title = 'FragEntropy Batch Processing'
       goto, resetfront

       backto_batch_ent:
       ;; do the loop processing now
       ;; validate and process the images in a loop
       ;boxsize = strmid(eventvalue2, 9, 2)
       
       ;; test if we want entropy on image or 
       entimage = strmid(eventvalue2,10,3) eq 'img'
       if entimage then res = 'batch_FragEntropy_Index.log' else res = 'batch_FragEntropy.log'
       fn_logfile = dir_batch + res
       nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
       openw, 9, fn_logfile
       printf, 9, 'FragEntropy batch processing logfile: ', systime()
       printf, 9, 'Number of files to be processed: ', nr_im_files
       printf, 9, '==============================================='
       close, 9
       msg = 'Processing selected images for Entropy, please wait...'
       progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
       progressBar -> Start
       
       FOR fidx = 0, nr_im_files - 1 DO BEGIN
         counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
         ;; validate the input, if not skip it without message
         IF progressBar -> CheckCancel() THEN BEGIN
           res = Dialog_Message('Batch-processing cancelled by user.')
           openw, 9, fn_logfile, /append
           printf, 9, 'Batch-processing cancelled by user.'
           close, 9
           progressBar -> Destroy
           Obj_Destroy, progressBar
           tvlct, rini, gini, bini
           GOTO, fin
         ENDIF

         input = im_file(fidx) 
         res = strpos(input,' ') ge 0
         IF res EQ 1 THEN BEGIN
           openw, 9, fn_logfile, /append
           printf, 9, ' '
           printf, 9, '==============   ' + counter + '   =============='
           printf, 9, 'Skipping invalid Entropy input (empty space in directory path or input filename): ', input
           close, 9
           GOTO, skip_frag1  ;; invalid input
         ENDIF
         
         type = '' & res = query_image(input, type=type)
         IF type NE 'TIFF' THEN BEGIN
           openw, 9, fn_logfile, /append
           printf, 9, ' '
           printf, 9, '==============   ' + counter + '   =============='
           printf, 9, 'Skipping invalid Entropy input (not a TIFF image): ', input
           close, 9
           GOTO, skip_frag1  ;; invalid input
         ENDIF

         res = query_tiff(input, geotiff = geotiffinfo)
         IF res EQ 0 THEN BEGIN
           openw, 9, fn_logfile, /append
           printf, 9, ' '
           printf, 9, '==============   ' + counter + '   =============='
           printf, 9, 'Skipping invalid Entropy input file: ', input
           close, 9
           GOTO, skip_frag1  ;; invalid input
         ENDIF

         image0 = read_tiff(input)  ;; read and check it
         q=size(image0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
         ;; in batch mode we can process larger images compared to the GUI         
         MSPA_Compliance, input, image0, info.immaxsizeg * 10, 0, result
         IF result EQ 0 OR imgminsize lt 500 THEN BEGIN
           openw, 9, fn_logfile, /append
           printf, 9, ' '
           printf, 9, '==============   ' + counter + '   =============='
           printf, 9, 'Skipping invalid Entropy input file: ', input
           close, 9
           GOTO, skip_frag1  ;; invalid input
         ENDIF

         ;; now all is ok for processing
         time0 = systime( / sec)
         widget_control, / hourglass
         ;; do the Entropy
         ;; rotate the image to be compliant with Guidos results!
         image0 = rotate(image0,7)
         entro = image0 * 0b

         ;; test for maximum fragmentation on full image area
         ;; old was only this line
         entropy_mspainp, image0, 0, comp & z20=strtrim(comp,2)
         
         if entimage eq 1 then goto, skip_spatial1
        
         ;; divide image in subtiles of dx, dy
         ;;dx=(xdim<ydim)/20 & dy=dx & xtiles=xdim/dx & ytiles=ydim/dy
         ;; fix to 50 for now
         ;dx = fix(boxsize)& dy=dx & smoothdim=dx*1
         dx = 50 & dy=dx 
         ;; default, fast way
         ;; ====================================
         ;; extend the image to avoid border effects
         ext = bytarr(xdim + 2*dx, ydim + 2*dy) & sz2=size(ext,/dim)
         ext[dx:dx + xdim - 1, dy:dy + ydim - 1] = image0
         ext[0:dx-1,    dy:dy+ydim-1] = reverse(image0[0:dx-1,*]) ;left
         ext[dx+xdim:*, dy:dy+ydim-1] = reverse(image0[xdim-dx:*,*]) ;right
         ext[dx:dx + xdim - 1, 0:dy-1] = reverse(image0[*, 0:dy-1],2) ;top
         ext[dx:dx + xdim - 1, dy+ydim:*] = reverse(image0[*, ydim-dy:*],2) ;bottom
         entro=ext*0b

         zstep=0
         fragagain10:

         ;; center area of image where dx/dy subtiles of 50x50 can be applied
         xdim2 = xdim + 2*dx & ydim2 = ydim + 2*dy
         xb=xdim2 mod dx & x1=xb/2 & x2=xdim2-xb  
         yb=ydim2 mod dy & y1=yb/2 & y2=ydim2-yb
         xtiles=xdim2/dx & ytiles=ydim2/dy
      
         for idy=0,ytiles-1 do begin
           yy=idy*dy+y1
           for idx=0,xtiles-1 do begin
             xx=idx*dx+x1
             subtile=ext[xx:xx+dx-1, yy:yy+dy-1]
             entropy_mspainp, subtile, 0, z
             entro[xx:xx+dx-1, yy:yy+dy-1]=z
           endfor
         endfor
         
         if zstep eq 0 then begin
           entro50=entro & entro=ext*0b & zstep=1 & dx = 33 & dy=dx & goto, fragagain10
         endif
         entro = (temporary(entro50)+temporary(entro))/2.0 < 100.0    
         dx = 50 & dy=dx
         entro = entro[dx:dx + xdim - 1, dy:dy + ydim - 1]
 
         ;; get range of entro
         e_min1=min(entro, max=e_max1) & dy1=e_max1-e_min1

         ;; smooth with triple tile-size
         ;; test for missing pixels and set them to nan
         ;;q=where(image0 eq 0b,ct) & entro[q] = !VALUES.F_NAN
         entro = smooth(entro, 33, / edge_truncate, /nan, missing=1.0)

         ;; intensity range decreases due to interpolation:
         ;; scale back to original range
         e_min2=min(entro, max=e_max2) & dy2=e_max2-e_min2
         entro = e_min1+((float(entro)-e_min2)*dy1/dy2)         
         qfg = where(image0 eq 2b, /l64) & z21=strtrim(mean(entro[qfg]),2)
         ;; convert to byte and apply mask
         entro = byte(round(entro)) * (image0 eq 2b)
         z22=strtrim(fix(min(entro[qfg])),2)
         z23=strtrim(fix(max(entro[qfg])),2)

         ;; add BG(101b), Missing(102b)
         entro = temporary(entro) + (image0 eq 1b)*101b + (image0 eq 0b)*102b
         
         ;if okfile eq 0 then begin
          restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
         ;endif

         ;; write the final result to the initial input dir
         ;; first rotate the image back to normal
         entro=rotate(entro,7)
         res = file_basename(input, '.tif')
         ;fn_out = dir_input + res + '_ent' + boxsize + '.tif'
         fn_out = dir_batch + res + '_FragEntropy.tif'
         ;; add the geotiff info if available
         IF (size(geotiffinfo))[0] gt 0 THEN BEGIN
           write_tiff, fn_out, entro, geotiff = geotiffinfo, red = r, green = g, blue = b,compression = 1
         ENDIF ELSE BEGIN
           write_tiff, fn_out, entro, red = r, green = g, blue = b,compression = 1
         ENDELSE
         image0 = 0 & entro = 0
         okfile = okfile + 1
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'File: ' + input
         printf, 9, 'Entropy: ' + z20 + ';   FG-only: '+ z21 + ', Range: [' + z22 +','+z23 + '])'
         printf, 9, 'Entropy comp.time [sec]: ', systime( / sec) - time0
         close, 9

         goto, skip_entimage1
         skip_spatial1:
         image0 = 0 & entro = 0
         okfile = okfile + 1
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'File: ' + input
         printf, 9, 'Entropy: ' + z20
         printf, 9, 'Entropy comp.time [sec]: ', systime( / sec) - time0
         close, 9

         skip_entimage1:
         skip_frag1:
         stepn = (fidx + 1.0)/nr_im_files * 100.0
         progressBar -> Update, stepn
       ENDFOR
       progressBar -> Destroy
       Obj_Destroy, progressBar

       ;; inform that batch is done
       proct = systime( / sec) - time00
       IF proct GT 3600.0 THEN BEGIN
         proct2 = proct - ulong(proct/3600)*3600
         proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
           ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
       ENDIF ELSE BEGIN
         proctstr = strtrim(ulong(proct/60.),2) + $
           ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
       ENDELSE
       IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
       openw, 9, fn_logfile, /append
       printf, 9, ''
       printf, 9, '==============================================='
       printf, 9, 'FragEntropy Batch Processing total comp.time: ', proctstr
       printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
       printf, 9, '==============================================='
       close, 9

       msg = 'FragEntropy Batch Processing finished.' + string(10b) + $
         'Total computation time: ' + proctstr + string(10b) + $
         'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
         'More information can be found in the logfile: ' + string(10b) + fn_logfile
       res = dialog_message(msg, / information)
       
       ;; reset the colortable to the settings before the batch processing
       tvlct, rini, gini, bini
       goto,fin
   END
      
   ;;*****************************************************************************************************

   'frag_contagion':  BEGIN
   ;; 1) check for input compliance:
   MSPA_Compliance, info.fname_input, * info.fr_image, info.immaxsizeg, 1, result
   IF result EQ 0 THEN GOTO, fin  ;; invalid input

   ;; if in zoom mode, quit zoom mode
   IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
     info.selsubregion_id = 0
     ;; deactivate zoomfactor selector
     widget_control, info.w_zoomfac, sensitive = 1
     widget_control, info.w_selsubregion, $
       set_value = 'Zoom Mode'
     ;; restore the prezoomed process image
     * info.process = * info.prezoomprocess
     ;; disable button and enable motion events in w_draw
     widget_control, info.w_draw, Draw_Motion_Events = 1
     widget_control, info.w_draw, Draw_Button_Events = 0
     info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
   ENDIF

   ;; we must process the full resolution image
   im0 = * info.fr_image
   qfg=where(im0 eq 2b,ctfg, /l64) 
   qbg=where(im0 eq 1b,ctbg, /l64)
   qmiss=where(im0 eq 0b,ctmiss, /l64)
   time00 = systime( / sec)
   ;; kernel-dimension
   ;;qqstr = strmid(eventValue2,14,2) & kdim = fix(qqstr)
   kdim = 49 
   widget_control, / hourglass
   

   q=size(im0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)   
   ;; divide image in subtiles of dx, dy
   dx = 50 & dy=dx & imgminsize=(xdim<ydim)
   IF imgminsize lt 50 THEN BEGIN
     res = dialog_message('Contagion requires minimum image size ' + $
       string(10b) + 'of 50 x 50 pixels.' + string(10b) + 'Returning...', / information)
     info.is_fragm = 0 & GOTO, fin
   ENDIF

   ;; reset mspa
   info.is_mspa = 0 & info.mspa_stats_show = 0b & info.is_fragm = 1
   info.do_mspa_stats_id = 0 & info.is_cs22 = 0 & info.is_nw = 0 & info.is_cost = 0
   info.do_label_groups_id = 0
   widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id


   ;; extend the image to avoid border effects
   ext = bytarr(xdim + 2*dx, ydim + 2*dy) & sz2=size(ext,/dim)
   ext[dx:dx + xdim - 1, dy:dy + ydim - 1] = im0
   ext[0:dx-1,    dy:dy+ydim-1] = reverse(im0[0:dx-1,*]) ;left
   ext[dx+xdim:*, dy:dy+ydim-1] = reverse(im0[xdim-dx:*,*]) ;right
   ext[dx:dx + xdim - 1, 0:dy-1] = reverse(im0[*, 0:dy-1],2) ;top
   ext[dx:dx + xdim - 1, dy+ydim:*] = reverse(im0[*, ydim-dy:*],2) ;bottom
   
   spatcon, ext, kdim, 'p22', info.dir_tmp, info.my_os, info.resfloat, im

   ;; rescale to original size and normalized byte range
   im = im[dx:dx + xdim - 1, dy:dy + ydim - 1]
   ;; rescale to normalized byte range
   if info.resfloat eq 0 then begin
     ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
     ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
     ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels
     q = where(im eq 255b, ct, /l64)
     im = ((im > 1b) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
     im = byte(round(temporary(im) * 100.0))
     if ct gt 0 then im[q] = 100b
   endif else begin
     im = byte(round(im*100.0))
   endelse

   ;; set fragmentation = 1.0 - contagion
   im = 100b - im 
   z20=strtrim(mean(im),2)
   
   ;; add back BG(101b), Missing(102b)
   im[qbg]=101b
   if ctmiss gt 0 then im[qmiss]=102b   
   qbg=0 & gmiss=0 
   z21=strtrim(mean(im[qfg]),2)
   z22=strtrim(fix(min(im[qfg])),2)
   z23=strtrim(fix(max(im[qfg])),2)
;   info.add_title = ' (frag(Contagion): ' + z20 + ';   FG-only: '+ z21 + ', Range: [' + z22 +','+z23 + '])'
   info.add_title = ' (Frag(Contagion): ' + z21 + ';  Range: [' + z22 +','+z23 + '])'
   * info.nw_ids = im
   * info.process = temporary(im)
   * info.fr_image = * info.process
   restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
   info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 5 ;; entropy
   widget_control, info.w_labelstr, set_value = 'Fragmentation range: '
      widget_control, info.w_label_t1, set_value = ['X','10','30','50']    
      widget_control, info.w_label_t2, set_value = ['X','60','70','80']
      widget_control, info.w_label_t1, set_combobox_select = 1 & info.label_t1 = 10
      widget_control, info.w_label_t2, set_combobox_select = 1 & info.label_t2 = 60
   print, systime( / sec) -time00
   END
   
   ;;*****************************************************************************************************

   'batch_cont':  BEGIN
     tit = 'Select (Geo-)Tif-files'
     im_file = $
       dialog_pickfile(Title = tit, get_path = path2file, $
       path = info.dir_data, default_extension = 'tif', / fix_filter, $
       / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
     IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
     
     ;; test that the directory of the selected files has no sub-directories
     ;; this will also ensure no output file is opened in excel or thelike
     pushd, path2file
     list = file_search() & nl = n_elements(list) & nr_dir = 0
     for idx = 0, nl-1 do begin
       q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
     endfor
     IF nr_dir GT 0 THEN BEGIN
       msg = 'The directory of your Batch Contagion input files contains sub-directories.'  +  string(10b) +  string(10b) + $
         'Please set up a new directory having Batch Contagion input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     popd
     
     ;; test that we can write into the parent directory or if it exists already
     batch_type = 'batch_FragContagion'
     dd = file_dirname(im_file[0], / mark_directory)
     dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
     res = file_test(dir_batch, /directory, /write)
     if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
       res = dialog_message(msg,/question)
       If res eq 'No' then goto, fin
       ;; empty it
       pushd, dir_batch
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd
     endif else begin ;; does not exist yet, create it
       file_mkdir, dir_batch
     endelse
     
     ;; files are now selected, reset the GUI
     ;;========================================================================
     ;; reset the front image and block any events
     ;;========================================================================
     title = 'FragContagion Batch Processing'
     goto, resetfront

     backto_batch_cont:
     ;; do the loop processing now
     ;; validate and process the images in a loop
     ;boxsize = '50' ;;strmid(eventvalue2, 10, 2)
     fn_logfile = dir_batch + batch_type + '.log'
     nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
     openw, 9, fn_logfile
     printf, 9, 'FragContagion batch processing logfile: ', systime()
     printf, 9, 'Number of files to be processed: ', nr_im_files
     printf, 9, '==============================================='
     close, 9
     
     msg = 'Processing selected images for Contagion, please wait...'
     progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
     progressBar -> Start

     FOR fidx = 0, nr_im_files - 1 DO BEGIN
       counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
       ;; validate the input, if not skip it without message
       IF progressBar -> CheckCancel() THEN BEGIN
         res = Dialog_Message('Batch-processing cancelled by user.')
         openw, 9, fn_logfile, /append
         printf, 9, 'Batch-processing cancelled by user.'
         close, 9
         progressBar -> Destroy
         Obj_Destroy, progressBar
         tvlct, rini, gini, bini
         GOTO, fin
       ENDIF

       input = im_file(fidx) 
       res = strpos(input,' ') ge 0
       IF res EQ 1 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Contagion input (empty space in directory path or input filename): ', input
         close, 9
         GOTO, skip_frag2  ;; invalid input
       ENDIF
       
       type = '' & res = query_image(input, type=type)
       IF type NE 'TIFF' THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Contagion input (not a TIFF image): ', input
         close, 9
         GOTO, skip_frag2  ;; invalid input
       ENDIF

       res = query_tiff(input, geotiff = geotiffinfo)
       IF res EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Contagion input file: ', input
         close, 9
         GOTO, skip_frag2  ;; invalid input
       ENDIF

       im0 = read_tiff(input)  ;; read and check it
       q=size(im0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
       ;; in batch mode we can process larger images compared to the GUI
       MSPA_Compliance, input, im0, info.immaxsizeg * 10, 0, result

       IF result EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Contagion input file: ', input
         close, 9
         GOTO, skip_frag2  ;; invalid input
       ENDIF
       ;; now all is ok for processing
       time0 = systime( / sec)
       widget_control, / hourglass
       ;; do the Contagion
       ;; rotate to be compliant with Guidos
       im0=rotate(im0,7)
       ;; we must process the full resolution image
       qfg=where(im0 eq 2b,ctfg, /l64)
       qbg=where(im0 eq 1b,ctbg, /l64)
       qmiss=where(im0 eq 0b,ctmiss, /l64)

       ;; kernel-dimension
       kdim = 49 ;;fix(boxsize)        
       dx = 50 & dy=dx
       q=size(im0,/dim) & xdim=q[0] & ydim=q[1] & imgminsize=(xdim<ydim)
       ;; extend the image to avoid border effects
       ext = bytarr(xdim + 2*dx, ydim + 2*dy) & sz2=size(ext,/dim)
       ext[dx:dx + xdim - 1, dy:dy + ydim - 1] = im0
       ext[0:dx-1,    dy:dy+ydim-1] = reverse(im0[0:dx-1,*]) ;left
       ext[dx+xdim:*, dy:dy+ydim-1] = reverse(im0[xdim-dx:*,*]) ;right
       ext[dx:dx + xdim - 1, 0:dy-1] = reverse(im0[*, 0:dy-1],2) ;top
       ext[dx:dx + xdim - 1, dy+ydim:*] = reverse(im0[*, ydim-dy:*],2) ;bottom
       spatcon, ext, kdim, 'p22', info.dir_tmp, info.my_os, info.resfloat, im
       
       ;; rescale to original size and normalized byte range
       im = im[dx:dx + xdim - 1, dy:dy + ydim - 1]
       ;; rescale to normalized byte range
       if info.resfloat eq 0 then begin
         ;; normally the conversion to byte range would be: im=(im-1b)/254.0 > 0.0
         ;; the potential max value from spatcon is 255b and *only* those pixels can have a remapped value of 100b
         ; we must prevent that the value 254b will get rounded to 100b so mask the 255b pixels
         q = where(im eq 255b, ct, /l64)
         im = ((im > 1b) - 1b)/254.0 & im = 0.994999 < temporary(im) > 0.0
         im = byte(round(temporary(im) * 100.0))
         if ct gt 0 then im[q] = 100b
       endif else begin
         im = byte(round(im*100.0))
       endelse

       ;; set fragmentation = 1.0 - contagion
       im = 100b - im
       z20=strtrim(mean(im),2)

       ;; add back BG(101b), Missing(102b)
       im[qbg]=101b
       if ctmiss gt 0 then im[qmiss]=102b
       qbg=0 & gmiss=0
       z21=strtrim(mean(im[qfg]),2)
       z22=strtrim(fix(min(im[qfg])),2)
       z23=strtrim(fix(max(im[qfg])),2)

       ;if okfile eq 0 then begin
         restore, info.dir_guidossub + 'entropycolors.sav' & tvlct, r, g, b
       ;endif

       ;; write the final result to the initial input dir
       res = file_basename(input, '.tif')
       ;fn_out = dir_input + res + '_cont' + boxsize + '.tif'
       fn_out = dir_batch + res + '_FragContagion.tif'
       ;; add the geotiff info if available
       ;; rotate back
       im=rotate(im,7)
       IF (size(geotiffinfo))[0] gt 0 THEN BEGIN
         write_tiff, fn_out, im, geotiff = geotiffinfo, red = r, green = g, blue = b,compression = 1
       ENDIF ELSE BEGIN
         write_tiff, fn_out, im, red = r, green = g, blue = b,compression = 1
       ENDELSE
       im = 0
       okfile = okfile + 1
       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'File: ' + input
       printf, 9, 'FG-Contagion: ' + z21 + '; Range: [' + z22 +','+z23 + '])'
       printf, 9, 'Contagion comp.time [sec]: ', systime( / sec) - time0
       close, 9

       skip_frag2:
       stepn = (fidx + 1.0)/nr_im_files * 100.0
       progressBar -> Update, stepn
     ENDFOR
     progressBar -> Destroy
     Obj_Destroy, progressBar

     ;; inform that batch is done
     proct = systime( / sec) - time00
     IF proct GT 3600.0 THEN BEGIN
       proct2 = proct - ulong(proct/3600)*3600
       proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDIF ELSE BEGIN
       proctstr = strtrim(ulong(proct/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDELSE
     IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
     openw, 9, fn_logfile, /append
     printf, 9, ''
     printf, 9, '==============================================='
     printf, 9, 'FragContagion Batch Processing total comp.time: ', proctstr
     printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
     printf, 9, '==============================================='
     close, 9

     msg = 'FragContagion Batch Processing finished.' + string(10b) + $
       'Total computation time: ' + proctstr + string(10b) + $
       'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
       'More information can be found in the logfile: ' + string(10b) + fn_logfile
     res = dialog_message(msg, / information)

     ;; reset the colortable to the settings before the batch processing
     tvlct, rini, gini, bini
     goto,fin
   END

   ;;*****************************************************************************************************

   'frag_parcellation':  BEGIN
     redo_parc:
     ;; 1) check for input compliance:
     Labelall_Compliance, info.fname_input, * info.fr_image, info.immaxsizeg, 1, result
     IF result EQ 0 THEN GOTO, fin  ;; invalid input

     ;; if in zoom mode, quit zoom mode
     IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
       info.selsubregion_id = 0
       ;; deactivate zoomfactor selector
       widget_control, info.w_zoomfac, sensitive = 1
       widget_control, info.w_selsubregion, $
         set_value = 'Zoom Mode'
       ;; restore the prezoomed process image
       * info.process = * info.prezoomprocess
       ;; disable button and enable motion events in w_draw
       widget_control, info.w_draw, Draw_Motion_Events = 1
       widget_control, info.w_draw, Draw_Button_Events = 0
       info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
     ENDIF

     ;; reset mspa
     info.is_mspa = 0 & info.mspa_stats_show = 0b & info.is_fragm = 0
     info.do_mspa_stats_id = 0 & info.is_cs22 = 0 & info.is_nw = 0 & info.is_cost = 0
     info.do_label_groups_id = 0
     widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id

     ;; we must process the full resolution image
     im0 = * info.fr_image     
     
     mi = min(im0, / nan) & q = where(histogram(im0, /l64, min=mi) GT 0, nr_classes) & classes = q+mi
     sz = size(im0) & qmiss=where(im0 eq 0b,ctmiss, /l64) & data_area = sz[4]-float(ctmiss)
     ;; add outside frame of 0 to make label_region work
     ext1 = lonarr(sz(1) + 2, sz(2) + 2) 
     ext1[1:sz(1), 1:sz(2)] = long(temporary(im0))
     IF info.mspa_param1_id EQ 1b THEN conn8 = 1 ELSE conn8 = 0
     parc = 0.0 & vclass = 0 & parcels = 0l;; initialize      
     p_vclass = lon64arr(nr_classes) & p_qclass = p_vclass & p_mx = p_vclass 
     p_atot = fltarr(nr_classes) & p_ba = [-1] & p_aps = p_atot 
     p_aaps_rel = p_atot & p_aaps = p_atot & p_parc = p_atot & p_div_rel = p_atot    
     div_up = -alog(1.0e-6) & div_scale = 100.0/div_up
          
     ;; loop through all classes
     for idx = 0, nr_classes-1 do begin
      qclass = classes[idx]
      if qclass ne 0 then begin ;; only proceed for classes other than 0 (reserved for nodata)
        vclass = vclass + 1
        blob = label_region(ext1 eq qclass, all_neighbors=conn8, / ulong) & mx = max(blob)
        barea = histogram(temporary(blob),/l64) & parcels = parcels + mx
        ba = barea[1:mx] & atot = total(ba)
        ;; average patch size: total area/#patches
        aps = atot/mx         
        ;; meshsize/area averaged mean patch size: 
        s = total(ba^2)
        aaps_rel = s/atot
        aaps  = s/data_area
        ;; division index:
        s = total((ba/atot)^2)
        div_rel = 1.0 - s
        
        ;; alog-scale division index, set lower end to 20.0, then scale into [100, 1]%
        div = -alog(s) & div = div_up < div & parc = div_scale * abs(div)
            
        ;; put in array
        p_ba = [ba,[p_ba]]
        p_vclass[idx] = vclass & p_qclass[idx] = qclass & p_mx[idx] = mx 
        p_atot[idx] = atot & p_div_rel[idx] = div_rel & p_parc[idx] = parc
        p_aps[idx] = aps & p_aaps_rel[idx] = aaps_rel & p_aaps[idx] = aaps
      endif      
     endfor
          
     ;; write stuff out to file
     ;; filter out 0-entry (if present) in array
     q = where(p_vclass eq 0, ct, /l64)
     if ct gt 0 then begin
       q=q[0]
       if q eq 0 then begin ;; all class numbers have positive numbers
         z = n_elements(p_vclass)
         if z eq 1 then begin ;; there is only one class in the image          
           p_qclass = p_vclass & aps = 0.0 & aaps = 0.0 & div_im = 0.0 & parc = 0.0
           goto, skip_parc
         endif
         p_vclass = p_vclass[1:*] & p_qclass = p_qclass[1:*] & p_mx = p_mx[1:*]
         p_atot = p_atot[1:*] & p_aps = p_aps[1:*] & p_parc = p_parc[1:*]
         p_aaps_rel = p_aaps_rel[1:*] & p_aaps = p_aaps[1:*] & p_div_rel = p_div_rel[1:*]
       endif else begin ;; we have also negative class numbers
         q1=q-1 & q2=q+1
         p_vclass = [p_vclass[0:q1],p_vclass[q2:*]]
         p_qclass = [p_qclass[0:q1],p_qclass[q2:*]]
         p_mx = [p_mx[0:q1],p_mx[q2:*]]
         p_atot = [p_atot[0:q1],p_atot[q2:*]]
         p_aps = [p_aps[0:q1],p_aps[q2:*]]
         p_aaps_rel = [p_aaps_rel[0:q1],p_aaps_rel[q2:*]]
         p_aaps = [p_aaps[0:q1],p_aaps[q2:*]]
         p_div_rel = [p_div_rel[0:q1],p_div_rel[q2:*]]
         p_parc = [p_parc[0:q1],p_parc[q2:*]]
       endelse
     endif
     z = n_elements(p_vclass)
     
     ;; overall image values
     ;;===================================
     aps = data_area/parcels
     
     ;; amend p_ba: take off the last entry which is -1 from the original definition
     p_ba = p_ba[0:n_elements(p_ba)-2]
     aaps = (total(p_ba^2))/data_area
     
     ;; division index:
     s = total((p_ba/data_area)^2) & div_im = 1.0 -s
     
     ;; constrain to 20.0 ~ to s = 1.0e-9
     ;; div = -alog(s) & div = 20.0 < div & parc = 100.0/20.0 * abs(div)
     ;; constrain to 10.0,  parc = 100.0/10.0 * abs(div)
     div = -alog(s) & div = div_up < div & parc = div_scale * abs(div)
     
     skip_parc:
     close,12 & openw,12, info.dir_tmp2 + 'parc.csv'
     printf,12, 'Class, Value, Count, Area[pixels], APS, AWAPS, AWAPS/data, DIVISION, PARC[%]'          
     for idx = 0, z-1 do printf, 12, strtrim(p_vclass[idx],2) + ',' + strtrim(p_qclass[idx],2) + ',' + $
      strtrim(p_mx[idx],2) + ',' + strtrim(p_atot[idx],2) + ',' + strtrim(p_aps[idx],2) + ',' + $
      strtrim(p_aaps_rel[idx],2) + ',' + strtrim(p_aaps[idx],2)+ ',' + $
      strtrim(p_div_rel[idx],2) + ',' + strtrim(p_parc[idx],2) 
     z10 = strtrim(parcels,2) & z20 = strtrim(vclass,2) & z30 = strtrim(parc,2)
     
     if conn8 eq 1 then pp1 = ' (8-connected ' else pp1 = ' (4-connected '
     pp = pp1 + 'Parcels/Classes/PARC: ' + z10 + ', ' + z20 + ', '+ z30 + '%)'
     info.add_title = pp
     pp = strmid(pp1,2,strlen(pp1)-2) + 'Parcels:, ,' + z10 + ', ' + strtrim(ulong64(data_area),2) + ',' + $
      strtrim(aps,2) + ', ,' + strtrim(aaps,2) + ',' + strtrim(div_im,2) + ',' + strtrim(parc,2)
     printf, 12, pp & close, 12
     
     ;; add a txt file to be displayed
     close, 12 & openw, 12, info.dir_tmp2 + 'parc.txt'
     printf,12, '     Class   Value      Count     Area[pixels]     APS          AWAPS       AWAPS/data     DIVISION      PARC[%]'
     for idx = 0, z-1 do printf, 12, format = '(2(i8), i12, i14, 5(f14.4))', p_vclass[idx], p_qclass[idx], $
       p_mx[idx], p_atot[idx], strtrim(p_aps[idx],2), $
       strtrim(p_aaps_rel[idx],2), strtrim(p_aaps[idx],2), strtrim(p_div_rel[idx],2), strtrim(p_parc[idx],2)
     printf, 12,'================================================================================================================'
     if conn8 eq 1 then pp1 = '8-conn. Parcels: ' else pp1 = '4-conn. Parcels: '
     printf, 12, format = '(a16, a12, i14, f14.4, a14, 3(f14.4))', pp1, z10, data_area, aps, ' ', aaps, div_im, parc
     close, 12 
     ;; show the summary image statistics
     fbn = file_basename(info.fname_input)    
     xdisplayfile, info.dir_tmp2 + 'parc.txt', title = fbn + ': parcellation summary:', width=120, /grow     
   END

   ;;*****************************************************************************************************

   'batch_parcellation':  BEGIN
     tit = 'Select (Geo-)Tif-files'
     im_file = $
       dialog_pickfile(Title = tit, get_path = path2file, $
       path = info.dir_data, default_extension = 'tif', / fix_filter, $
       / must_exist, / multiple_files, filter = ['*.tif', '*.tiff'])
     IF im_file[0] EQ '' THEN GOTO, fin ;; 'cancel' selected
     
     ;; test that the directory of the selected files has no sub-directories
     ;; this will also ensure no output file is opened in excel or thelike
     pushd, path2file
     list = file_search() & nl = n_elements(list) & nr_dir = 0
     for idx = 0, nl-1 do begin
       q = file_test(list[idx],/directory) & nr_dir = nr_dir + q
     endfor
     IF nr_dir GT 0 THEN BEGIN
       msg = 'The directory of your Batch Parcellation input files contains sub-directories.'  +  string(10b) +  string(10b) + $
         'Please set up a new directory having Batch Parcellation input files ONLY and no other sub-directories.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin
     ENDIF
     popd
     
     ;; test that we can write into the parent directory or if it exists already
     batch_type = 'batch_PARC'
     dd = file_dirname(im_file[0], / mark_directory)
     dir_batch = file_dirname(dd, / mark_directory) + batch_type + info.os_sep
     res = file_test(dir_batch, /directory, /write)
     if res eq 1 then begin ;; dir_batch already exists
       msg = 'The directory' + string(10b) + dir_batch + string(10b) + $
         'already exists. All previous content will be erased before we continue.'+ string(10b) + $
         "Please click 'Yes' to confirm or 'No' to exit"
       res = dialog_message(msg,/question)
       If res eq 'No' then goto, fin
       ;; empty it
       pushd, dir_batch
       list = file_search() & nl = n_elements(list)
       if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
       popd
     endif else begin ;; does not exist yet, create it
       file_mkdir, dir_batch
     endelse



     ;; files are now selected, reset the GUI
     ;;========================================================================
     ;; reset the front image and block any events
     ;;========================================================================
     title = 'Parcellation Batch Processing'
     goto, resetfront

     backto_batch_parcellation:
     
     ;; do the loop processing now
     ;; validate and process the images in a loop
     fn_logfile = dir_batch + batch_type + '.log'
     nr_im_files = n_elements(im_file) & time00 = systime( / sec) & okfile = 0l
     openw, 9, fn_logfile
     printf, 9, 'Parcellation batch processing logfile: ', systime()
     printf, 9, 'Number of files to be processed: ', nr_im_files
     printf, 9, '==============================================='
     close, 9
     
     msg = 'Processing selected images for Parcellation, please wait...'
     progressBar = Obj_New("SHOWPROGRESS", message = msg, xsize=300, title=title, /cancel)
     progressBar -> Start

     FOR fidx = 0, nr_im_files - 1 DO BEGIN
       counter = strtrim(fidx + 1, 2) + '/' + strtrim(nr_im_files, 2)
       ;; validate the input, if not skip it without message       
       IF progressBar -> CheckCancel() THEN BEGIN
         res = Dialog_Message('Batch-processing cancelled by user.')
         openw, 9, fn_logfile, /append
         printf, 9, 'Batch-processing cancelled by user.'
         close, 9
         progressBar -> Destroy
         Obj_Destroy, progressBar
         tvlct, rini, gini, bini
         GOTO, fin
       ENDIF


       input = im_file(fidx)
       res = strpos(input,' ') ge 0
       IF res EQ 1 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid parcellation input (empty space in directory path or input filename): ', input
         close, 9
         GOTO, skip_parcellation  ;; invalid input
       ENDIF

       type = '' & res = query_image(input, type=type)
       IF type NE 'TIFF' THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid parcellation input (not a TIFF image): ', input
         close, 9
         GOTO, skip_parcellation  ;; invalid input
       ENDIF


       res = query_tiff(input, geotiff = geotiffinfo)
       IF res EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid parcellation input file: ', input
         close, 9
         GOTO, skip_parcellation  ;; invalid input
       ENDIF

       im0 = read_tiff(input)  ;; read and check it
       Labelall_Compliance, input, im0, info.immaxsizeg * 10, 0, result
       IF result EQ 0 THEN BEGIN
         openw, 9, fn_logfile, /append
         printf, 9, ' '
         printf, 9, '==============   ' + counter + '   =============='
         printf, 9, 'Skipping invalid Parcellation input file: ', input
         close, 9
         GOTO, skip_parcellation  ;; invalid input
       ENDIF

       ;; now all is ok for processing
       time0 = systime( / sec)
       widget_control, / hourglass
       ;; rotate the image to be compliant with Guidos results!
       im0 = rotate(im0,7)
       
       ;; label map for all classes
       ;; get uniq classes
       mi = min(im0, / nan) & q = where(histogram(im0, /l64, min=mi) GT 0, nr_classes) & classes = q+mi
       sz = size(im0) & qmiss=where(im0 eq 0b,ctmiss, /l64) & data_area = sz[4]-float(ctmiss)
       ;; add outside frame of 0 to make label_region work
       ext1 = lonarr(sz(1) + 2, sz(2) + 2)
       ext1[1:sz(1), 1:sz(2)] = long(temporary(im0))
       IF info.mspa_param1_id EQ 1b THEN conn8 = 1 ELSE conn8 = 0
       parc = 0.0 & vclass = 0 & parcels = 0l;; initialize
       p_vclass = ulon64arr(nr_classes) & p_qclass = p_vclass & p_mx = p_vclass
       p_atot = fltarr(nr_classes) & p_ba = [-1] & p_aps = p_atot
       p_aaps_rel = p_atot & p_aaps = p_atot & p_parc = p_atot & p_div_rel = p_atot
       div_up = -alog(1.0e-6) & div_scale = 100.0/div_up
              
       ;; loop through all classes
       for idx = 0, nr_classes-1 do begin
         qclass = classes[idx]
         if qclass ne 0 then begin ;; only proceed for classes other than 0 (reserved for nodata)
           vclass = vclass + 1
           blob = label_region(ext1 eq qclass, all_neighbors=conn8, / ulong) & mx = max(blob)
           barea = histogram(temporary(blob),/l64) & parcels = parcels + mx
           ba = barea[1:mx] & atot = total(ba) & aps = atot/mx
           ;; meshsize/area averaged mean patch size:
           s = total(ba^2) & aaps_rel = s/atot & aaps  = s/data_area
           ;; division index:
           s = total((ba/atot)^2) & div_rel = 1.0 - s
           ;; alog-scale division index, set lower end to 20.0, then scale into [100, 1]%
           div = -alog(s) & div = div_up < div & parc = div_scale * abs(div)

           ;; put in array
           p_ba = [ba,[p_ba]]
           p_vclass[idx] = vclass & p_qclass[idx] = qclass & p_mx[idx] = mx
           p_atot[idx] = atot & p_div_rel[idx] = div_rel & p_parc[idx] = parc
           p_aps[idx] = aps & p_aaps_rel[idx] = aaps_rel & p_aaps[idx] = aaps
         endif
       endfor

       ;; write stuff out to file
       ;; filter out 0-entry (if present) in array
       q = where(p_vclass eq 0, ct, /l64)
       if ct gt 0 then begin
         q=q[0]
         if q eq 0 then begin ;; all class numbers have positive numbers
           z = n_elements(p_vclass)
           if z eq 1 then begin ;; there is only one class in the image
             p_qclass = p_vclass & aps = 0.0 & aaps = 0.0 & div_im = 0.0 & parc = 0.0 
             goto, skip_parcb
           endif
           p_vclass = p_vclass[1:*] & p_qclass = p_qclass[1:*] & p_mx = p_mx[1:*]
           p_atot = p_atot[1:*] & p_aps = p_aps[1:*] & p_parc = p_parc[1:*]
           p_aaps_rel = p_aaps_rel[1:*] & p_aaps = p_aaps[1:*] & p_div_rel = p_div_rel[1:*]
         endif else begin ;; we have also negative class numbers
           q1=q-1 & q2=q+1
           p_vclass = [p_vclass[0:q1],p_vclass[q2:*]]
           p_qclass = [p_qclass[0:q1],p_qclass[q2:*]]
           p_mx = [p_mx[0:q1],p_mx[q2:*]]
           p_atot = [p_atot[0:q1],p_atot[q2:*]]
           p_aps = [p_aps[0:q1],p_aps[q2:*]]
           p_aaps_rel = [p_aaps_rel[0:q1],p_aaps_rel[q2:*]]
           p_aaps = [p_aaps[0:q1],p_aaps[q2:*]]
           p_div_rel = [p_div_rel[0:q1],p_div_rel[q2:*]]
           p_parc = [p_parc[0:q1],p_parc[q2:*]]
         endelse
       endif
       z = n_elements(p_vclass)
       
       ;; overall image values
       ;;===================================
       aps = data_area/parcels
       ;; amend p_ba: take off the last entry which is -1 from the original definition
       p_ba = p_ba[0:n_elements(p_ba)-2]
       aaps = (total(p_ba^2))/data_area
       ;; division index:
       s = total((p_ba/data_area)^2) & div_im = 1.0 -s
       ;; constrain to 20.0 ~ to s = 1.0e-9
       div = -alog(s) & div = div_up < div & parc = div_scale * abs(div)

       skip_parcb:
       fn_parc = dir_batch + info.os_sep + file_basename(input, '.tif') + '_parc.csv'
       
       ;; test and warn if that file is currently open
       IF (file_info(fn_parc)).exists EQ 1b THEN BEGIN
        ;; check it it can be opened meaning it is accessible, if not we will get an error gt 0
         close, 9 & openu, 9, fn_parc, error = error & close,9
       ENDIF ELSE BEGIN ;; file does not exist
         error = 0
       ENDELSE
       if error ne 0 then begin  ;; file is blocked
          msg = 'The result can not be saved because your ' + string(10b) + $
           'spreadsheet application is showing the file:' + string(10b) + fn_parc + string(10b) + string(10b) +$
           'Please close your spreadsheet application' + string(10b) + 'Then run the process again.'
         res = dialog_message(msg, / error)
         GOTO, fin        
       endif else begin
         close,12 & openw,12, fn_parc
         printf,12, 'Class, Value, Count, Area[pixels], APS, AWAPS, AWAPS/data, DIVISION, PARC[%]'
         for idx = 0, z-1 do printf, 12, strtrim(p_vclass[idx],2) + ',' + strtrim(p_qclass[idx],2) + ',' + $
           strtrim(p_mx[idx],2) + ',' + strtrim(p_atot[idx],2) + ',' + strtrim(p_aps[idx],2) + ',' + $
           strtrim(p_aaps_rel[idx],2) + ',' + strtrim(p_aaps[idx],2)+ ',' + $
           strtrim(p_div_rel[idx],2) + ',' + strtrim(p_parc[idx],2)
         if conn8 eq 1 then pp1 = ' (8-connected ' else pp1 = ' (4-connected ' & z10 = strtrim(parcels,2)
         pp = strmid(pp1,2,strlen(pp1)-2) + 'Parcels:, ,' + z10 + ', ' + strtrim(ulong64(data_area),2) + ',' + $
           strtrim(aps,2) + ', ,' + strtrim(aaps,2) + ',' + strtrim(div_im,2) + ',' + strtrim(parc,2)
         printf, 12, pp & close, 12
         
         ;; txt file
         fn_out = dir_batch + info.os_sep + file_basename(input, '.tif') + '_parc.txt'
         close, 12 & openw, 12, fn_out
         printf,12, '     Class   Value      Count     Area[pixels]     APS          AWAPS       AWAPS/data     DIVISION      PARC[%]'
         for idx = 0, z-1 do printf, 12, format = '(2(i8), i12, i14, 5(f14.4))', p_vclass[idx], p_qclass[idx], $
           p_mx[idx], p_atot[idx], strtrim(p_aps[idx],2), $
           strtrim(p_aaps_rel[idx],2), strtrim(p_aaps[idx],2), strtrim(p_div_rel[idx],2), strtrim(p_parc[idx],2)
         printf, 12,'================================================================================================================'
         if conn8 eq 1 then pp1 = '8-conn. Parcels: ' else pp1 = '4-conn. Parcels: '
         printf, 12, format = '(a16, a12, i14, f14.4, a14, 3(f14.4))', pp1, z10, data_area, aps, ' ', aaps, div_im, parc
         close, 12 
         
         ;; for the log-file
         if conn8 eq 1 then pp1 = '8-conn. Parcels/APS/PARC: ' else pp1 = '4-conn. Parcels/APS/PARC: '
         ppl = pp1 + z10 + ' / ' + strtrim(aps,2) + ' / ' + strtrim(parc,2) 
       
       endelse
       ;; write the final result to the initial input dir
       okfile = okfile + 1
       openw, 9, fn_logfile, /append
       printf, 9, ' '
       printf, 9, '==============   ' + counter + '   =============='
       printf, 9, 'File: ' + input
       printf, 9, ppl
       printf, 9, 'Parcellation comp.time [sec]: ', systime( / sec) - time0
       close, 9

       skip_parcellation:
       stepn = (fidx + 1.0)/nr_im_files * 100.0
       progressBar -> Update, stepn
     ENDFOR
     progressBar -> Destroy
     Obj_Destroy, progressBar
     

     ;; inform that batch is done
     proct = systime( / sec) - time00
     IF proct GT 3600.0 THEN BEGIN
       proct2 = proct - ulong(proct/3600)*3600
       proctstr = strtrim(ulong(proct/3600.),2) + ' hrs, ' + strtrim(ulong(proct2/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDIF ELSE BEGIN
       proctstr = strtrim(ulong(proct/60.),2) + $
         ' mins, ' + strtrim(ulong(proct mod 60),2) + ' secs'
     ENDELSE
     IF proct LT 60.0 THEN proctstr = strtrim(ulong(proct),2) + ' secs'
     openw, 9, fn_logfile, /append
     printf, 9, ''
     printf, 9, '==============================================='
     printf, 9, 'Parcellation Batch Processing total comp.time: ', proctstr
     printf, 9, 'Successfully processed files: ',strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2)
     printf, 9, '==============================================='
     close, 9

     msg = 'Parcellation Batch Processing finished.' + string(10b) + $
       'Total computation time: ' + proctstr + string(10b) + $
       'Successfully processed files: '+strtrim(okfile,2)+'/'+ strtrim(nr_im_files,2) + string(10b) + string(10b) + $
       'More information can be found in the logfile: ' + string(10b) + fn_logfile
     res = dialog_message(msg, / information)

     ;; reset the colortable to the settings before the batch processing
     tvlct, rini, gini, bini
     goto,fin
   END   
    
   ;;*****************************************************************************************************

   'change':  BEGIN 
      ;; build simple difference of two images A and B
      ;; current image is A, load image B to be compared to A
      ;;
      ;; read image A
      ;;=========================================================================================
      case eventValue2 of
        'change_simple':  begin
          tit1='Simple change: select image A: ' & filt='.tif, .tiff'
          widget_control, info.w_file_save, / sensitive
          widget_control, info.w_lp11, / sensitive
        end
        'change_morph':  begin
          tit1='Morph. change: select image A: ' & filt='.tif, .tiff'
          widget_control, info.w_file_save, / sensitive        
          widget_control, info.w_lp11, / sensitive
        end
        'change_fad':  begin
          tit1='FAD_mscale: image A: ' & filt='.tif, .tiff'
        end
        'change_fos':  begin
          tit1='FOS: image A: ' & filt='.tif, .tiff'
        end
        'change_rss':  begin
          tit = 'Restoration Change Setup Information'
          msg = 'Please select the original and then the modified image.' + string(10b) + string(10b) + $
            'A) original image:'  + string(10b) + $
            '   2: Foreground (FG) objects, fixed at 2%' + string(10b) + $
            '   [3, 100]: Background (BG) resistance' + string(10b) + $
            '(resistance values of 1 or > 100 are not allowed)' + string(10b) + string(10b) + $
            'B) modified image (including all new restoration features):' + string(10b) + $
            '   0: Blocking, can not be traversed (optional)' + string(10b) + $
            '   2: Foreground (FG) objects' + string(10b) + string(10b) + $
            'Both images must have identical geospatial coverage, pixel resolution, etc.'
          res = dialog_message(msg, title=tit, / information)      
          tit1='RSS change: image A: ' & filt='.tif, .tiff'
        end
      endcase
      ;; initialise counter of non-fragm. BG-pixels needed for FAD change analysis
      im1_nfBG = 0 & im2_nfBG = 0
      
      res = $
        dialog_read_image(file = im1_file, get_path = path2file1, $
        image = im1, path = info.dir_data, query=query1, $
        TITLE=tit1, FILTER=filt, /fix_filter)
      IF res EQ 0 THEN GOTO, fin ;; 'cancel' was selected
      IF (size(query1))[0] EQ 0 THEN BEGIN
        res = dialog_message('Please use the mouse pointer to select an' + $
          string(10b) + 'image file from the list of tif-files.' + string(10b) + 'Returning...', / information)
        GOTO, fin
      ENDIF
      s = size(im1)
      IF s[0] EQ 0 THEN BEGIN
        res = dialog_message('Invalid image format or directory' + $
          string(10b) + 'instead of file selected.' + string(10b) + 'Returning...', / information)
        GOTO, fin
      ENDIF
      ;; transfer image to 2-D if necessary
      s = size(im1)
      IF s[0] EQ 3 THEN BEGIN ;; 3-dim image
        IF s[1] EQ 3 THEN BEGIN ;; 3 band image
          s = size(im1) & dim_pos = where(s EQ 3) & dim_pos = dim_pos(1)
          ;;remap true color images
          im1 = color_quan(im1, dim_pos, r, g, b, / map_all)
        ENDIF ELSE BEGIN
          msg = 'Please provide a single-band image.' + string(10b) + 'Returning...'
          res = dialog_message(msg, / information)
          GOTO, fin
        ENDELSE
      ENDIF ELSE IF s[0] EQ 2 THEN BEGIN
        info.ctbl = 0 & info.disp_colors_id = 0
      ENDIF ELSE BEGIN
        msg = 'Please provide a single-band image.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDELSE
      
      ;; --------  FAD ---------------
      IF eventValue2 eq 'change_fad' THEN BEGIN
        ;;; test for original FAD image        
        qq1a = strmid(im1_file,14,/reverse_offset) eq '_fad_mscale.tif'
        qq2a = strmid(im1_file,19,/reverse_offset) eq '_fad-app5_mscale.tif' or strmid(im1_file,19,/reverse_offset) eq '_fad-app2_mscale.tif'
        qq = qq1a + qq2a
        
        IF qq ne 1 THEN BEGIN
          res = dialog_message('Please select a GTB-generated *_fad_mscale.tif OR *_fad-app5/2_mscale.tif image.' + string(10b) + 'Returning...', / information)
          GOTO, fin
        ENDIF
        
        IF info.my_os EQ 'windows' THEN BEGIN
          cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalinfo -noct "' + im1_file + '"'
        ENDIF ELSE BEGIN
          if strlen(info.sysgdal) gt 0 then $
            cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + im1_file + '"' else $
            cmd = info.dir_fwtools + 'gdalinfo -noct "' + im1_file + '"'
        ENDELSE
        IF info.my_os EQ 'windows' THEN spawn, cmd, log, / hide ELSE spawn, cmd, log & q = log[0]
        
        qq=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_FAD") & qq=qq[0]
        IF qq LE 0 THEN BEGIN
          res = dialog_message('Input image A is not a geotiff or not a GTB-generated' + $
            string(10b) + '*_fad*_mscale.tif image.' + string(10b) + 'Returning...', / information)
          GOTO, fin
        ENDIF
        
        ;; check sav-file
        tt = strmid(im1_file,0, strlen(im1_file)-4)+'.sav'
        res = file_info(tt)
        IF res.exists NE 1b THEN BEGIN
          msg = 'FAD change analysis requires the file:' + string(10b) + file_basename(tt) + string(10b)+ 'which was not found. ' + $
            'Please do not modify FAD-created directories.' + string(10b) + 'Returning...'
          res = dialog_message(msg, / information)
          GOTO, fin
        ENDIF
        im1_sav = tt

        
        ;; check for presence of non-fragm. BG pixels
        q = where(im1 eq 106b, im1_nfBG, /l64) & im1_nfBG=im1_nfBG gt 0
      ENDIF
      
      ;; --------  FOS ---------------
      IF eventValue2 eq 'change_fos' THEN BEGIN
        ;;; test for original FOS image
        IF info.my_os EQ 'windows' THEN BEGIN
          cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalinfo -noct "' + im1_file + '"'
        ENDIF ELSE BEGIN
          if strlen(info.sysgdal) gt 0 then $
            cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + im1_file + '"' else $
            cmd = info.dir_fwtools + 'gdalinfo -noct "' + im1_file + '"'
        ENDELSE
        IF info.my_os EQ 'windows' THEN spawn, cmd, log, / hide ELSE spawn, cmd, log & q = log[0]
        
        qq=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_FOS") & qq=qq[0]
        IF qq LE 0 THEN BEGIN
          res = dialog_message('Input image A is not a geotiff or not a GTB-generated' + $
            string(10b) + '*_fos.tif image.' + string(10b) + 'Returning...', / information)
          GOTO, fin
        ENDIF
        ;; check sav-file
        tt = strmid(im1_file,0, strlen(im1_file)-4)+'.sav'
        res = file_info(tt)
        IF res.exists NE 1b THEN BEGIN
          msg = 'FOS change analysis requires the file:' + string(10b) + file_basename(tt) + string(10b)+ 'which was not found. ' + $
            'Please do not modify FOS-created directories.' + string(10b) + 'Returning...'
          res = dialog_message(msg, / information)
          GOTO, fin
        ENDIF
        im1_sav = tt
        
        ;; check for presence of non-fragm. BG pixels
        q = where(im1 eq 106b, im1_nfBG, /l64) & im1_nfBG = im1_nfBG gt 0
      ENDIF
   
  
        
      ;; read image B    
      ;;=========================================================================================
      tit1=strmid(tit1,0,strlen(tit1)-3)+'B: '
      res = $
        dialog_read_image(file = im2_file, get_path = path2file2, $
        image = im2, path = info.dir_data, query=query2, $
        TITLE=tit1, FILTER=filt, /fix_filter)
      IF res EQ 0 THEN GOTO, fin ;; 'cancel' was selected
      IF (size(query2))[0] EQ 0 THEN BEGIN
        res = dialog_message('Please use the mouse pointer to select an' + $
          string(10b) + 'image file from the list of tif-files.' + string(10b) + 'Returning...', $
          / information)
        GOTO, fin
      ENDIF
      s = size(im2)
      IF s[0] EQ 0 THEN BEGIN
        res = dialog_message('Invalid image format or directory' + string(10b) + $
          'instead of file selected.' + string(10b) + 'Returning...', / information)
        GOTO, fin
      ENDIF
      ;; transfer image to 2-D if necessary
      s = size(im2)
      IF s[0] EQ 3 THEN BEGIN ;; 3-dim image
        IF s[1] EQ 3 THEN BEGIN ;; 3 band image
          s = size(im2) & dim_pos = where(s EQ 3) & dim_pos = dim_pos(1)
          ;;remap true color images
          im2 = color_quan(im2, dim_pos, r, g, b, / map_all)
        ENDIF ELSE BEGIN
          msg = 'Please provide a single-band image.' + string(10b) + 'Returning...'
          res = dialog_message(msg, / information)
          GOTO, fin
        ENDELSE
      ENDIF ELSE IF s[0] EQ 2 THEN BEGIN
        info.ctbl = 0 & info.disp_colors_id = 0
      ENDIF ELSE BEGIN
        msg = 'Please provide a single-band image.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDELSE
     
      ;; --------  FAD ---------------
      IF eventValue2 eq 'change_fad' THEN BEGIN
        qq1b = strmid(im1_file,14,/reverse_offset) eq '_fad_mscale.tif'
        qq2b = strmid(im1_file,19,/reverse_offset) eq '_fad-app5_mscale.tif' or strmid(im1_file,19,/reverse_offset) eq '_fad-app2_mscale.tif'
        qq = qq1b + qq2b 
        IF qq ne 1 THEN BEGIN
          res = dialog_message('Please select a GTB-generated *_fad_mscale.tif OR *_fad-app5/2_mscale.tif image.' + string(10b) + 'Returning...', / information)
          GOTO, fin
        ENDIF
       ;; check that both images have the same FAD type
        res = (qq1a eq qq1b) + (qq2a eq qq2b)
        IF res ne 2 THEN BEGIN
          res = dialog_message('We can not compare FAD with FAD-APP.' + string(10b) + 'Returning...', / information)
          GOTO, fin
        ENDIF              
        IF info.my_os EQ 'windows' THEN BEGIN
          cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalinfo -noct "' + im2_file + '"'
        ENDIF ELSE BEGIN
          if strlen(info.sysgdal) gt 0 then $
            cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + im2_file + '"' else $
            cmd = info.dir_fwtools + 'gdalinfo -noct "' + im2_file + '"'
        ENDELSE
        IF info.my_os EQ 'windows' THEN spawn, cmd, log, / hide ELSE spawn, cmd, log & q = log[0]        
        qq=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_FAD") & qq=qq[0]
        IF qq LE 0 THEN BEGIN
          res = dialog_message('Input image B is not a geotiff or not a GTB-generated' + $
            string(10b) + '*_fad*_mscale.tif image.' + string(10b) + 'Returning...', / information)
          GOTO, fin
        ENDIF  
        
        ;; check sav-file
        tt = strmid(im2_file,0, strlen(im2_file)-4)+'.sav'
        res = file_info(tt)
        IF res.exists NE 1b THEN BEGIN
          msg = 'FAD change analysis requires the file:' + string(10b) + file_basename(tt) + string(10b)+ 'which was not found. ' + $
            'Please do not modify FAD-created directories.' + string(10b) + 'Returning...'
          res = dialog_message(msg, / information)
          GOTO, fin
        ENDIF
        im2_sav = tt
   
        ;; check for presence of non-fragm. BG pixels
        q = where(im2 eq 106b, im2_nfBG, /l64) & im2_nfBG = im2_nfBG gt 0
      ENDIF

      ;; --------  FOS ---------------
      IF eventValue2 eq 'change_fos' THEN BEGIN
        ;;; test for original FAD image
        IF info.my_os EQ 'windows' THEN BEGIN
          cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalinfo -noct "' + im2_file + '"'
        ENDIF ELSE BEGIN
          if strlen(info.sysgdal) gt 0 then $
            cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + im2_file + '"' else $
            cmd = info.dir_fwtools + 'gdalinfo -noct "' + im2_file + '"'
        ENDELSE
        IF info.my_os EQ 'windows' THEN spawn, cmd, log, / hide ELSE spawn, cmd, log & q = log[0]
        qq=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_FOS") & qq=qq[0]
        IF qq LE 0 THEN BEGIN
          res = dialog_message('Input image B is not a geotiff or not a GTB-generated' + $
            string(10b) + '*_fos*.tif image.' + string(10b) + 'Returning...', / information)
          GOTO, fin
        ENDIF
        ;; check for presence of non-fragm. BG pixels
        q = where(im2 eq 106b, im2_nfBG, /l64) & im2_nfBG = im2_nfBG gt 0
      ENDIF    
      IF im1_file EQ im2_file THEN BEGIN
        msg = 'You have selected the same image for Images A and B.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF    
      IF im1_nfBG ne im2_nfBG THEN BEGIN
        msg = 'One of the input images has non-fragmenting background pixels.' + string(10b) + $
          'A FOS/FAD change analysis is only meaningful if either both or none' + string(10b) + $
          'of the two input images have non-fragmenting background pixels.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF     
      ;; check sav-file
      tt = strmid(im2_file,0, strlen(im2_file)-4)+'.sav'
      res = file_info(tt)
      IF res.exists NE 1b THEN BEGIN
        msg = 'FOS change analysis requires the file:' + string(10b) + file_basename(tt) + string(10b)+ 'which was not found. ' + $
          'Please do not modify FOS-created directories.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF
      im2_sav = tt  
      
      ;; test for same fostype or same fadtype
      restore, filename=im1_sav & if (size(fadtype))[1] eq 7 then fostype = fadtype
      im1_fostype = fostype & s1len = strlen(im1_fostype)
      restore, filename=im2_sav & if (size(fadtype))[1] eq 7 then fostype = fadtype     
      im2_fostype = fostype & s2len = strlen(im2_fostype)     
      if (s1len eq 8) and (s2len eq 8) then goto, bothfosapp
      if im1_fostype ne im2_fostype then begin
        msg = 'FOS/FAD change analysis requires comparing files with the same analysis type, which is not the case for the selected files:' + string(10b) + $
        'Image A: ' + im1_fostype + string(10b) + 'Image B: ' + im2_fostype + string(10b) + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin        
      endif
      bothfosapp:
      
      q = where(im1 ne im2, ct, /l64) & q = 0
      IF ct eq 0 THEN BEGIN
        msg = 'Pixel values of Images A and B are identical.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF

      widget_control, / hourglass
;;      if eventValue2 eq 'change_simple' then GOTO, diffsim_nogeo
      
      ;; a) common area coverage of geotiff images A and B requires:
      ;; - same projection
      ;; - same pixel resolution
      ;; - same pixel center
      ;;=========================================================================================  
      ;; EPSG code of image A
      ;;=======================
      EPSG1 = '' & chrss = 1
      res = query_tiff(im1_file, tiffinfo1, geotiff = geotiffinfo1)
      IF res EQ 1 AND (size(geotiffinfo1))[0] gt 0 THEN BEGIN
        ;; im2 is geotiff, get/compare the EPSG-code
        IF info.my_os EQ 'windows' THEN BEGIN
          cmd = 'cd "' + info.dir_fwtools + $
            '" & setfw.bat & gdalinfo -noct -nomd "' + im1_file + '"'
        ENDIF ELSE BEGIN
          if strlen(info.sysgdal) gt 0 then $
            cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct -nomd "' + im1_file + '"' else $
            cmd = info.dir_fwtools + 'gdalinfo -noct -nomd "' + im1_file + '"'
        ENDELSE
        IF info.my_os EQ 'windows' THEN spawn, cmd, log1, / hide ELSE spawn, cmd, log1
        res = strsplit(log1,'EPSG',/extract)
        q = STREGEX(log1, 'EPSG', /FOLD_CASE) & q2 = where(q gt 0, ct)
        if ct gt 0 then begin
          ;; last EPSG entry
          q3 = log1(q2(n_elements(q2)-1))
          s2 = STRPOS(q3, '"', /reverse_search)
          s1 = STRPOS(strmid(q3,0,s2), '"', /reverse_search)
          EPSG1 = strmid(q3,s1+1,s2-s1-1)
        endif
      ENDIF ELSE BEGIN
        ;; image A is not a GeoTiff file.
        chrss = 0
        if (eventValue2 eq 'change_rss') then GOTO, diffrestnogeo
        if (eventValue2 eq 'change_morph') then begin
          msg = 'Image A is not a geotiff. ' + string(10b) + 'Building simple-change instead.'
          res = dialog_message(msg, / information)
          GOTO, diffsim_nogeo
        endif
        GOTO, diffsim_nogeo                 
      ENDELSE
        
      ;; EPSG code of image B
      ;;=======================
      res = query_tiff(im2_file, tiffinfo2, geotiff = geotiffinfo2)
      IF res EQ 1 AND (size(geotiffinfo2))[0] gt 0 THEN BEGIN
        ;; im2 is geotiff, get/compare the EPSG-code
        EPSG2 = ''
        IF info.my_os EQ 'windows' THEN BEGIN
          cmd = 'cd "' + info.dir_fwtools + $
            '" & setfw.bat & gdalinfo -noct -nomd "' + im2_file + '"'
        ENDIF ELSE BEGIN
          if strlen(info.sysgdal) gt 0 then $
            cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct -nomd "' + im2_file + '"' else $
            cmd = info.dir_fwtools + 'gdalinfo -noct -nomd "' + im2_file + '"'
        ENDELSE
        IF info.my_os EQ 'windows' THEN spawn, cmd, log2, / hide ELSE spawn, cmd, log2  
        res = strsplit(log2,'EPSG',/extract)
        q = STREGEX(log2, 'EPSG', /FOLD_CASE) & q2 = where(q gt 0, ct)
        if ct gt 0 then begin
          ;; last EPSG entry
          q3 = log2(q2(n_elements(q2)-1))
          s2 = STRPOS(q3, '"', /reverse_search)
          s1 = STRPOS(strmid(q3,0,s2), '"', /reverse_search)
          EPSG2 = strmid(q3,s1+1,s2-s1-1)
        endif       
      ENDIF ELSE BEGIN
        ;; image B is not a GeoTiff file.
        chrss = 0
        if (eventValue2 eq 'change_rss') then GOTO, diffrestnogeo 
        if (eventValue2 eq 'change_morph') then begin
          msg = 'Image B is not a geotiff. ' + string(10b) + 'Building simple-change instead.'
          res = dialog_message(msg, / information)
          GOTO, diffsim_nogeo
        endif
        GOTO, diffsim_nogeo
      ENDELSE
          
      ;; compare EPSG1 and EPSG2
      if epsg1 ne epsg2 then begin
        msg = 'Images A and B are geotif but have different projections: ' + string(10b)  + $
        'Geotif image A (EPSG: ' + epsg1 + ')' + string(10b)  + $
        'Geotif image B (EPSG: ' + epsg2 + ')' + string(10b)  + $
        'A common geographic data area can only be detected if both images use the same projection.' + string(10b)
        if (eventValue2 eq 'change_fad') OR (eventValue2 eq 'change_fos') OR (eventValue2 eq 'change_rss') then begin
          msg = msg + string(10b) + 'Returning...'
          res = dialog_message(msg, / information)
          GOTO, fin
        endif
        msg = msg + 'Building simple-change instead.'
        res = dialog_message(msg, / information)
        goto, diffsim_nogeo
      endif
      
      ;;compare pixel-size
      p1 = log1[WHERE(STRMATCH(log1, 'Pixel Size*', /FOLD_CASE) EQ 1)]
      p2 = log2[WHERE(STRMATCH(log2, 'Pixel Size*', /FOLD_CASE) EQ 1)]    
      if  p1 ne p2 then begin
        msg = 'Images A and B are geotif but have different pixel sizes: ' + string(10b)  + $
          'Geotif image A: ' + p1 + string(10b)  + $
          'Geotif image B: ' + p2 + string(10b)  + $
          'A common geographic data area can only be detected if both images have the same pixel size.' + string(10b) 
        if (eventValue2 eq 'change_fad') OR (eventValue2 eq 'change_fos') OR (eventValue2 eq 'change_rss') then begin
          msg = msg + string(10b) + 'Returning...'
          res = dialog_message(msg, / information)
          GOTO, fin
        endif
        msg = msg + 'Building simple-change instead.'
        res = dialog_message(msg, / information)
        goto, diffsim_nogeo
      endif

      ;; compare position
      if total(query1.position eq query2.position) lt 2.0 then begin
        msg = 'Images A and B are geotif but have different pixel positions: ' + string(10b)  + $
          'Geotif image A: ' + query1.position + string(10b)  + $
          'Geotif image B: ' + query2.position + string(10b)  + $
          'A common geographic data area can only be detected if both images have the same pixel position.' + string(10b)   
        if (eventValue2 eq 'change_fad') OR (eventValue2 eq 'change_fos') OR (eventValue2 eq 'change_rss') then begin
          msg = msg + string(10b) + 'Returning...'
          res = dialog_message(msg, / information)
          GOTO, fin
        endif
        msg = msg + 'Building simple-change instead.'
        res = dialog_message(msg, / information)
        goto, diffsim_nogeo
      endif
      
      ;;========================================================================================
      ;;========================================================================================
      ;; we should now have the same coverage area to do FOS/FAD/RSS change
      ;;===================================================================================================
      ;;========================================================================================
      ;; for FAD/FOS/RSS change we want the two image areas to have the identical size/extent
      if (eventValue2 eq 'change_fad') OR (eventValue2 eq 'change_fos') OR (eventValue2 eq 'change_rss') then begin
        
        ;;========================================================================================
        ;; 0) before doing any processing verify that all required files are available
        ;;========================================================================================                
        
        ;;======================  R S S  stuff  ===============================================
        if (eventValue2 eq 'change_rss') then begin
          diffrestnogeo:
          title = 'Change in RSS Processing'
          IF chrss EQ 0 THEN BEGIN
            msg = 'The current and the original image do NOT have or share a common geoheader.' + $
              'Restoration Change analysis will be conducted but might not be meaningful.'
            res = dialog_message(msg, / information, title = tit)
          ENDIF          
          goto, resetfront
          backto_change_rss:
          
          fn_a = im1_file & fn_b = im2_file
          im1 = read_tiff(fn_a) & im1 = rotate(im1,7) 
          im2 = read_tiff(fn_b) & im2 = rotate(im2,7) 
          
          ;; get topdir of im1_file which will be used to save the results
          outdir = file_dirname(file_dirname(im1_file)) + info.os_sep

          ;; test if same FG-coverage
          q = abs(total((im2 EQ 2b) - (im1 EQ 2b)))
          IF q LT 0.1 THEN BEGIN ;; both images are identical
            msg = 'The current and the original network are identical, -> no change.' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information, title = tit)
            GOTO, fin
          ENDIF
          
          ;; verify image properties for Restoration
          histoorig = histogram(im1) ;; the original image
          histo = histogram(im2) ;; the modified one
          
          IF histoorig[1] GT 0 THEN BEGIN
            msg = 'Original restoration map has invalid resistance of 1b.' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information, title = tit)
            GOTO, fin
          ENDIF
;          IF histo[1] GT 0 THEN BEGIN
;            msg = 'Current resistance map has invalid resistance of 1b.' + string(10b) + 'Returning...'
;            res = dialog_message(msg, / information, title = tit)
;            GOTO, fin
;          ENDIF
          ;; test for presence of FG-objects and correct resistance values
          IF histoorig[2] EQ 0 THEN BEGIN
            msg = 'Original restoration map has no FG-objects (2b).' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information, title = tit)
            GOTO, fin
          ENDIF
          IF histo[2] EQ 0 THEN BEGIN
            msg = 'Current restoration map has no FG-objects (2b).' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information, title = tit)
            GOTO, fin
          ENDIF
          IF total(histoorig[101:*]) GT 0.0 THEN BEGIN
            msg = 'Original restoration map has invalid resistance > 100b.' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information, title = tit)
            GOTO, fin
          ENDIF
          ;; check which resistance we have
          q = where(histoorig[3:100] gt 0, ct, /l64)
          IF ct EQ 1 THEN c_size = strtrim(q[0]+3,2) ELSE c_size = 'var'

          ;; get all components of FG-objects
          ;; labeling must be done on extended image to avoid
          ;; zeroed boundaries, go back to original dimension later

          ;; restore pixels, here only those that were added wrt im1!!
          restpix = where((im2 eq 2b) and (im1 ne 2b), ct_rp, /l64)
          
          ; first for the original image
          im = im1 & iloop = 1 & sz = size(im)
          rss_again:
          eew = 2  & eew2 = eew * 2
          ext = bytarr(sz[1] + eew2, sz[2] + eew2)
          ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = im eq 2b
          qm = where(im EQ 0b, ctqm, /l64) ;; missing pixels in original dimensions
          data_area = float(sz[4]) - ctqm
          if iloop eq 1 then begin
            ;; build distance map for quality of restore pixels
            bgdist =  morph_distance(ext, / background, neighbor = 3, /no_copy)
            bgdist = bgdist[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1]           
            if ct_rp gt 0 then begin
              quality = mean(bgdist[restpix]) ;; average of BG-distance below restore pixels
              expense = im1[restpix] & expense = long64(total(expense)) ;; sum of resistance below restore pixels
            endif else begin
              quality = -1
              expense = -1
            endelse   
            bgdist = 0                    
          endif                  
          im = temporary(ext) ;; free up space, note that im is now the extended area

          ;; FG-components
          lbl_comp = label_region(im, / all, / ulong) & im = 0
          ;nr_comp = max(lbl_comp) ;; total # of components

          ;; get area by component
          h_comp_area = histogram(lbl_comp, / l64)
          ;obj_big = max(h_comp_area[1: * ])

          ;; PCnum:= overall connectivity. Sum of [ (areas per component)^2 ]
          pcnum_orig = total((h_comp_area[1: * ])^2, / double)

          ;; ECA: equivalent connected component area = sqrt(pcnum) [unit area, hectares]
          ECA_orig = sqrt(pcnum_orig)
          ECA_max = total(h_comp_area[1: * ])
          DOC_orig = ECA_orig/ECA_max*100.0
          ;RAC_orig = ECA_max / data_area *100.0
          ;aps = ECA_MAX/nr_comp

          ;; CNOA: Criticial New Object Area
          ;b = ECA_max & c = ECA_orig
          ;CNOA = (2.0 * b * c^2)/(b^2 - c^2)
          ;CNOA = ulong64(cnoa+1.0)

          ;; save stuff for change
          if iloop eq 1 then begin
            ;eca_max0 = eca_max
            eca_orig0 = eca_orig
            doc_orig0 = doc_orig
            ;rac_orig0 = rac_orig
           ; nr_comp0 = nr_comp
            ;obj_big0 = obj_big
            ;aps0 = aps
            ;cnoa0 = cnoa
          endif

          IF iloop EQ 2 then GOTO, rss_done
          iloop = 2 & im = temporary(im2) 
          GOTO, rss_again
          rss_done:

          ;; build the difference of new to original
          ;delta_ecamax = eca_max - eca_max0
          delta_eca = eca_orig - eca_orig0
          gain = doc_orig - doc_orig0
          ;delta_rac = rac_orig - rac_orig0
          ;delta_nr_comp = nr_comp - nr_comp0
          ;delta_obj_big = obj_big - obj_big0
          ;delta_aps = aps - aps0
          ;delta_cnoa = cnoa - cnoa0
          expense_t = 'EXP_' + c_size
          effic = delta_eca / float(expense)

          ;; write out the differences as csv and xdisplayfile
          close, 1 & openw, 1, info.dir_data + 'rss_change.csv', error=error
          IF (error NE 0) then begin
            msg = 'Please close your spreadsheet application, then try again.' + $
              string(10b) + 'Returning...'
            res = dialog_message(msg, /information)
            close,1
            goto,fin
          ENDIF
          printf, 1, 'REST_PIX, AVDIST_RP,' + expense_t + ', EFFIC, ECA_ORIG, ECA_NEW, DELTA_ECA, COH_ORIG, COH_NEW, DELTA_COH'
          rowstr = strtrim(ct_rp, 2) + ',' + strtrim(quality,2) + ',' +  strtrim(expense,2) + ',' + strtrim(effic,2) + ',' + $
            strtrim(eca_orig0,2) + ',' + strtrim(eca_orig,2) + ',' + strtrim(delta_eca,2) + ',' + $
            strtrim(doc_orig0,2) + ',' + strtrim(doc_orig,2) + ',' + strtrim(gain, 2)
          printf, 1, rowstr & close, 1

          statsfiletxt = info.dir_tmp + 'rss_change.txt'
          close, 11 & openw, 11, statsfiletxt
          printf, 11, format='(3x,2(a15), 8(a18))', 'REST_PIX', 'AVDIST_RP', expense_t, 'EFFIC', $
            'ECA_ORIG', 'ECA_NEW', 'DELTA_ECA', 'COH_ORIG', 'COH_NEW', 'DELTA_COH'
          printf, 11, format = '(10(a20))', strtrim(ct_rp, 2), strtrim(quality,2), strtrim(expense,2), strtrim(effic,2),$
            strtrim(eca_orig0,2), strtrim(eca_orig,2), strtrim(delta_eca,2),$
            strtrim(doc_orig0,2), strtrim(doc_orig,2), strtrim(gain, 2)
          printf, 11, ''
          printf, 11, 'Note: statistics saved to: ' + info.dir_data + 'rss_change.csv'
          IF chrss EQ 0 THEN BEGIN
             printf, 11, ''
              printf, 11, 'The current and the original image do NOT have or share a common geoheader.'
              printf, 11, 'Restoration Change summary might not be meaningful.'
          ENDIF   
          close, 11
          xdisplayfile, statsfiletxt, title = tit, width = 140       
          GOTO, fin
        ENDIF
             
        
        ;;======================  F O S  stuff  ===============================================
        if (eventValue2 eq 'change_fos') then begin
          fn_a = im1_file
          fn_b = im2_file
          a_pref = strmid(im1_file,strpos(fn_a, '_fos',/reverse_search))
          b_pref = strmid(im2_file,strpos(fn_b, '_fos',/reverse_search))

          IF a_pref NE b_pref THEN BEGIN
            msg = 'FOS type or moving window dimensions of image A and B are different.' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information)
            GOTO, fin
          ENDIF
                   
          ;; check the sav-files and ensure they both use the same FOS
          tt = strmid(im1_file,0, strlen(im1_file)-4) + '.sav'
          res = file_info(tt)
          IF res.exists NE 1b THEN BEGIN
            msg = 'FOS change analysis requires the file:' + string(10b) +  file_basename(tt) + string(10b)+ 'which was not found. ' + $
              'Please do not modify FOS-created directories.' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information)
            GOTO, fin
          ENDIF
          a_sav = tt

          tt = strmid(im2_file,0, strlen(im2_file)-4) + '.sav'
          res = file_info(tt)
          IF res.exists NE 1b THEN BEGIN
            msg = 'FOS change analysis requires the file:' + string(10b) +  file_basename(tt) + string(10b)+ 'which was not found. ' + $
              'Please do not modify FOS-created directories.' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information)
            GOTO, fin
          ENDIF          
          b_sav = tt
          
          restore, a_sav
          a_xdim=xdim & a_ydim=ydim & a_fostype = fostype;;& a_geotiff_log=geotiff_log & a_rare=rare & a_patchy=patchy & a_transitional=transitional
          ;;a_dominant=dominant & a_interior=interior & a_intact=intact & a_fgarea=fgarea & a_hec = hec & a_acr = acr
          a_conn = conn_str & a_pres = pixres_str & a_kdim = kdim_str
          ;; check if fad_av was saved, if so then use it
          a_tt = (size(fad_av))[1]
          if a_tt eq 4 then a_fad_av = fad_av
          
          restore, b_sav
          b_xdim=xdim & b_ydim=ydim & b_fostype = fostype ;;& b_geotiff_log=geotiff_log & b_rare=rare & b_patchy=patchy & b_transitional=transitional
          ;;b_dominant=dominant & b_interior=interior & b_intact=intact & b_fgarea=fgarea & b_hec = hec & b_acr = acr
          b_conn = conn_str & b_pres = pixres_str & b_kdim = kdim_str  
          ;; check if fad_av was saved, if so then use it
          b_tt = (size(fad_av))[1]
          if b_tt eq 4 then b_fad_av = fad_av
          fad_avok = a_tt + b_tt
     
          res = (a_xdim eq b_xdim) + (a_ydim eq b_ydim) + (a_conn eq b_conn) + (a_pres eq b_pres) + (a_kdim eq b_kdim) + (a_fostype eq b_fostype)
          
          if res ne 6b then begin
            msg = 'FOS change analysis requires identical values for' + string(10b) + $
              'X/Y-image dimension, FOS type, FG-connectivity,' + string(10b) + $
              'Pixel Resolution, and Observation Scale.' + string(10b) + string(10b) + $
              'The selected images have different settings. ' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information)
            GOTO, fin           
          endif
                   
          title = 'Change in FOS Processing'
          goto, resetfront
          backto_change_fos:
          
          ;; 2) the change matrix for the FOS
          ;;===============================================================================================
          ;;========================================================================================
          ;; FOS image details for A, B
          ;;==============================================================                                        
          im1 = read_tiff(fn_a) & im2 = read_tiff(fn_b)
          ;; get topdir of im1_file which will be used to save the results
          outdir = file_dirname(file_dirname(im1_file)) + info.os_sep  
          
          ;; make a simplified output for FE4.7 2-class analysis
          if fostype eq 'FOS-APP2' then begin
            change = dblarr(3,3) & change0 = change
            ;; exclude missing data from both maps, temporarily set them to 150b
            q = where(im1 eq 102b or im2 eq 102b, ctmiss, /l64)
            if ctmiss gt 0 then begin
              im1[q]=150b & im2[q]=150b
            endif
            ;; collapse all background types in im1 and im2
            q = where(im2 gt 100b and im2 lt 150b, ct, /l64) & if ct gt 0 then im2[q]=110b
            q = where(im1 gt 100b and im1 lt 150b, ct, /l64) & if ct gt 0 then im1[q]=110b
            ch = change0 ; reset change vector
            
            ;; get pixels of each class type in im1 and look what they changed to in im2
            if ct gt 0 then begin ;; im1 has BG-pixels
              h=histogram(im2[q]) & ch = [h[110],total(h[0:39]),total(h[40:100])]
              change[*,0] = ch
            endif
            ch = ch*0 & q = where(im1 lt 40b, ct, /l64)
            if ct gt 0 then begin ;; im1 has separated pixels
              h=histogram(im2[q]) & ch = [h[110],total(h[0:39]),total(h[40:100])]
              change[*,1] = ch
            endif
            ch = ch*0 & q = where(im1 ge 40b and im1 le 100b, ct, /l64)
            if ct gt 0 then begin ;; im1 has continuous pixels
              h=histogram(im2[q]) & ch = [h[110],total(h[0:39]),total(h[40:100])]
              change[*,2] = ch
            endif
            uchange = strtrim(ulong64(change),2)
            
            ;; save the tables into a txt-file
            f_out = outdir + strlowcase(fostype) + '-change.txt' 
            close,12 & openw,12, f_out
            printf,12, fostype + ': Fragmentation class change from A -> B'
            printf,12, 'A-' + fn_a
            printf,12, 'B-' + fn_b
            printf,12, '=============================================================================================================================================='
            printf,12, 'Fragmentation class at observation scale: ' + hec + ' hectares/' + acr + ' acres'
            printf,12, '(Pixel resolution: ' + pixres_str + '[m], Window size: ' + kdim_str + 'x' + kdim_str +')'
            printf,12, '=============================================================================================================================================='
            printf,12, '# pixels A->B  :     B0-Background           B1-Separated         B2-Continuous'
            printf,12, format='(a16,7(a18))','A0-Background  :', uchange[*,0]
            printf,12, format='(a16,7(a18))','A1-Separated   :', uchange[*,1]
            printf,12, format='(a16,7(a18))','A2-Continuous  :', uchange[*,2]
            gain=total(change[1:*,0]) & loss=total(change[0,1:*]) & nc=gain-loss & if nc lt 0.0 then sig = '-' else sig = '' & nc2 = strtrim(ulong64(abs(nc)),2)
            printf,12, 'Gross area gain (Class A0 -> Class B*): ' + strtrim(ulong64(gain),2) + ' pixels'
            printf,12, 'Gross area loss (Class A* -> B0): ' + strtrim(ulong64(loss),2) + ' pixels'
            printf,12, 'Net area change (A->B): ' + sig + nc2 + ' pixels'
            if fad_avok eq 8 then printf,12, 'FAD_av (A->B) [%]: ' + strtrim(a_fad_av,2) + ' -> ' + $
               strtrim(b_fad_av,2) + ': ' + strtrim(a_fad_av - b_fad_av,2)
            close, 12
            
            ;; save the tables as a csv-file
            z=strtrim(change,2) 
            f_out = outdir + strlowcase(fostype) + '-change.csv'
            
            ;; test and warn if that file is currently open
            IF (file_info(f_out)).exists EQ 1b THEN BEGIN
              ;; check it it can be opened meaning it is accessible, if not we will get an error gt 0
              close, 9 & openu, 9, f_out, error = error & close,9
            ENDIF ELSE BEGIN ;; file does not exist
              error = 0
            ENDELSE

            IF (error NE 0) then begin ;; file is blocked
              msg = 'Please close your spreadsheet application, then try again.' + $
                string(10b) + 'Returning...'
              res = dialog_message(msg, /information)
              goto, fin
            ENDIF

            close,12 & openw,12, f_out
            printf,12, fostype + ': Fragmentation class change from A -> B ' 
            printf,12, 'A-' + fn_a
            printf,12, 'B-' + fn_b
            printf,12, 'Fragmentation class at observation scale: ' + hec + ' hectares/' + acr + ' acres'
            printf,12, '(Pixel resolution: ' + pixres_str + '[m] Window size: ' + kdim_str + 'x' + kdim_str +')'
            printf,12, ' '
            printf,12, '# pixels, B0-Background, B1-Separated, B2-Continuous'
            printf,12, 'A0-Background,  '+z[0,0]+', '+z[1,0]+', '+z[2,0]
            printf,12, 'A1-Separated,   '+z[0,1]+', '+z[1,1]+', '+z[2,1]
            printf,12, 'A2-Continuous,  '+z[0,2]+', '+z[1,2]+', '+z[2,2]
            printf,12, '  '
            printf,12, 'Gross area gain (Class A0 -> Class B*): ' + strtrim(gain,2) + ' pixels'
            printf,12, 'Gross area loss (Class A* -> B0): ' + strtrim(loss,2) + ' pixels'
            printf,12, 'Net area change (A->B): ' + strtrim(nc,2) + ' pixels'
            if fad_avok eq 8 then printf,12, 'FAD_av (A->B) [%]: ' + strtrim(a_fad_av,2) + ' -> ' + $
              strtrim(b_fad_av,2) + ': ' + strtrim(a_fad_av - b_fad_av,2)
            close, 12
            goto, skip_otherfoschange
          endif
           
          change = dblarr(7, 7) & change0 = change
          ;; potential values in scale images are the actual FAD values:
          ;; 1-100, 101-BG, 102-missing, 105-special BG, 106-specialBG non-fragm.
          ;;               
          ;; exclude missing data from both maps, temporarily set them to 150b
          q = where(im1 eq 102b or im2 eq 102b, ctmiss, /l64)
          if ctmiss gt 0 then begin
            im1[q]=150b & im2[q]=150b
          endif
          ;; collapse all background types in im1 and im2
          q = where(im2 gt 100b and im2 lt 150b, ct, /l64) & if ct gt 0 then im2[q]=110b
          q = where(im1 gt 100b and im1 lt 150b, ct, /l64) & if ct gt 0 then im1[q]=110b
          ch = change0 ; reset change vector

          ;; get pixels of each class type in im1 and look what they changed to in im2
          if ct gt 0 then begin ;; im1 has BG-pixels
            h=histogram(im2[q]) & ch = [h[110],total(h[0:9]),total(h[10:39]),total(h[40:59]),total(h[60:89]),total(h[90:99]),h[100]]
            change[*,0] = ch
          endif
          ch = ch*0 & q = where(im1 lt 10b, ct, /l64)
          if ct gt 0 then begin ;; im1 has rare pixels
            h=histogram(im2[q]) & ch = [h[110],total(h[0:9]),total(h[10:39]),total(h[40:59]),total(h[60:89]),total(h[90:99]),h[100]]
            change[*,1] = ch
          endif
          ch = ch*0 & q = where(im1 ge 10b and im1 le 39b, ct, /l64)
          if ct gt 0 then begin ;; im1 has patchy pixels
            h=histogram(im2[q]) & ch = [h[110],total(h[0:9]),total(h[10:39]),total(h[40:59]),total(h[60:89]),total(h[90:99]),h[100]]
            change[*,2] = ch
          endif
          ch = ch*0 & q = where(im1 ge 40b and im1 le 59b, ct, /l64)
          if ct gt 0 then begin ;; im1 has transitional pixels
            h=histogram(im2[q]) & ch = [h[110],total(h[0:9]),total(h[10:39]),total(h[40:59]),total(h[60:89]),total(h[90:99]),h[100]]
            change[*,3] = ch
          endif
          ch = ch*0 & q = where(im1 ge 60b and im1 le 89b, ct, /l64)
          if ct gt 0 then begin ;; im1 has dominant pixels
            h=histogram(im2[q]) & ch = [h[110],total(h[0:9]),total(h[10:39]),total(h[40:59]),total(h[60:89]),total(h[90:99]),h[100]]
            change[*,4] = ch
          endif
          ch = ch*0 & q = where(im1 ge 90b and im1 lt 100b, ct, /l64)
          if ct gt 0 then begin ;; im1 has interior pixels
            h=histogram(im2[q]) & ch = [h[110],total(h[0:9]),total(h[10:39]),total(h[40:59]),total(h[60:89]),total(h[90:99]),h[100]]
            change[*,5] = ch
          endif
          ch = ch*0 & q = where(im1 eq 100b, ct, /l64)
          if ct gt 0 then begin ;; im1 has 100-intact pixels
            h=histogram(im2[q]) & ch = [h[110],total(h[0:9]),total(h[10:39]),total(h[40:59]),total(h[60:89]),total(h[90:99]),h[100]]
            change[*,6] = ch
          endif

          ;; calculate percentage of change in the sub-matrix
          perc = change*0
          sum_below = total(change[1,2:*],/double) + total(change[2,3:*],/double) + total(change[3,4:*],/double) + total(change[4,5:*],/double) + change[5,6]
          sum_above = total(change[2:*,1],/double) + total(change[3:*,2],/double) + total(change[4:*,3],/double) + total(change[5:*,4],/double) + change[6,5]
          for ix = 1,6 do begin
            for iy = 1,6 do begin
              if iy gt ix then perc[ix,iy]=change[ix,iy]/sum_below*100.0
              if iy lt ix then perc[ix,iy]=change[ix,iy]/sum_above*(-100.0)
            endfor
          endfor
          ;; get integer numbers
          if fostype eq 'FOS-APP5' then begin
            change = change[0:5,0:5] & perc = perc[0:5,0:5]
          endif
          uchange = strtrim(ulong64(change),2)

          ;; save the tables into a txt-file
          f_out = outdir + strlowcase(fostype) + '-change.txt'    
          close,12 & openw,12, f_out
          printf,12, fostype + ': Fragmentation class change from A -> B'
          printf,12, 'A-' + fn_a 
          printf,12, 'B-' + fn_b
          printf,12, '=============================================================================================================================================='
          printf,12, 'Fragmentation class at observation scale: ' + hec + ' hectares/' + acr + ' acres'
          printf,12, '(Pixel resolution: ' + pixres_str + '[m], Window size: ' + kdim_str + 'x' + kdim_str +')'
          printf,12, '=============================================================================================================================================='
          if fostype eq 'FOS' then printf,12, '# pixels A->B  :     B0-Background           B1-Rare         B2-Patchy    B3-Transitional      B4-Dominant       B5-Interior         B6-Intact'
          if fostype eq 'FOS-APP5' then printf,12, '# pixels A->B  :     B0-Background           B1-Rare         B2-Patchy    B3-Transitional      B4-Dominant       B5-Interior'
          printf,12, format='(a16,7(a18))','A0-Background  :', uchange[*,0]
          printf,12, format='(a16,7(a18))','A1-Rare        :', uchange[*,1]
          printf,12, format='(a16,7(a18))','A2-Patchy      :', uchange[*,2]
          printf,12, format='(a16,7(a18))','A3-Transitional:', uchange[*,3]
          printf,12, format='(a16,7(a18))','A4-Dominant    :', uchange[*,4]
          printf,12, format='(a16,7(a18))','A5-Interior    :', uchange[*,5]
          if fostype eq 'FOS' then printf,12, format='(a16,7(a18))','A6-Intact      :', uchange[*,6]
          printf,12, '  '
          gain=total(change[1:*,0]) & loss=total(change[0,1:*]) & nc=gain-loss & if nc lt 0.0 then sig = '-' else sig = '' & nc2 = strtrim(ulong64(abs(nc)),2)
          printf,12, 'Gross area gain (Class A0 -> Class B*): ' + strtrim(ulong64(gain),2) + ' pixels'
          printf,12, 'Gross area loss (Class A* -> B0): ' + strtrim(ulong64(loss),2) + ' pixels'
          printf,12, 'Net area change (A->B): ' + sig + nc2 + ' pixels'
          if fad_avok eq 8 then printf,12, 'FAD_av (A-B) [%]: ' + strtrim(a_fad_av,2) + ' - ' + $
            strtrim(b_fad_av,2) + ': ' + strtrim(a_fad_av - b_fad_av,2)
          printf,12, '  '
          printf,12, 'Relative fragmentation value increase is found below the matrix diagonal and expressed with positive percentages.'
          printf,12, 'Relative fragmentation value decrease is found above the matrix diagonal and expressed with negative percentages.'
          if fostype eq 'FOS' then printf,12, '% change A->B  :         B1-Rare       B2-Patchy   B3-Transitional   B4-Dominant     B5-Interior       B6-Intact'
          if fostype eq 'FOS-APP5' then printf,12, '% change A->B  :         B1-Rare       B2-Patchy   B3-Transitional   B4-Dominant     B5-Interior'
          printf,12, format='(8(a16))','A1-Rare        :',perc[1:*,1]
          printf,12, format='(8(a16))','A2-Patchy      :',perc[1:*,2]
          printf,12, format='(8(a16))','A3-Transitional:',perc[1:*,3]
          printf,12, format='(8(a16))','A4-Dominant    :',perc[1:*,4]
          printf,12, format='(8(a16))','A5-Interior    :',perc[1:*,5]
          if fostype eq 'FOS' then printf,12, format='(8(a16))','A6-Intact      :',perc[1:*,6]
          printf,12, '  '
          close,12

          ;; save the tables as a csv-file
          z=strtrim(change,2) & zp=strtrim(perc,2)
          f_out = outdir + strlowcase(fostype) + '-change.csv'
          
          ;; test and warn if that file is currently open
          IF (file_info(f_out)).exists EQ 1b THEN BEGIN
            ;; check it it can be opened meaning it is accessible, if not we will get an error gt 0
            close, 9 & openu, 9, f_out, error = error & close,9
          ENDIF ELSE BEGIN ;; file does not exist
            error = 0
          ENDELSE

          IF (error NE 0) then begin ;; file is blocked
            msg = 'Please close your spreadsheet application, then try again.' + $
              string(10b) + 'Returning...'
            res = dialog_message(msg, /information)
            goto, fin
          ENDIF 
         
          close,12 & openw,12, f_out
          printf,12, fostype + ': Fragmentation class change from A -> B'
          printf,12, 'A-' + fn_a 
          printf,12, 'B-' + fn_b
          printf,12, 'Fragmentation class at observation scale: ' + hec + ' hectares/' + acr + ' acres'
          printf,12, '(Pixel resolution: ' + pixres_str + '[m] Window size: ' + kdim_str + 'x' + kdim_str +')'
          printf,12, ' '
          if fostype eq 'FOS' then begin
            printf,12, '# pixels, B0-Background, B1-Rare, B2-Patchy, B3-Transitional, B4-Dominant, B5-Interior, B6-Intact'
            printf,12, 'A0-Background,  '+z[0,0]+', '+z[1,0]+', '+z[2,0]+', '+z[3,0]+', '+z[4,0]+', '+z[5,0]+', '+z[6,0]
            printf,12, 'A1-Rare,        '+z[0,1]+', '+z[1,1]+', '+z[2,1]+', '+z[3,1]+', '+z[4,1]+', '+z[5,1]+', '+z[6,1]
            printf,12, 'A2-Patchy,      '+z[0,2]+', '+z[1,2]+', '+z[2,2]+', '+z[3,2]+', '+z[4,2]+', '+z[5,2]+', '+z[6,2]
            printf,12, 'A3-Transitional,'+z[0,3]+', '+z[1,3]+', '+z[2,3]+', '+z[3,3]+', '+z[4,3]+', '+z[5,3]+', '+z[6,3]
            printf,12, 'A4-Dominant,    '+z[0,4]+', '+z[1,4]+', '+z[2,4]+', '+z[3,4]+', '+z[4,4]+', '+z[5,4]+', '+z[6,4]
            printf,12, 'A5-Interior,    '+z[0,5]+', '+z[1,5]+', '+z[2,5]+', '+z[3,5]+', '+z[4,5]+', '+z[5,5]+', '+z[6,5]
            printf,12, 'A6-Intact,      '+z[0,6]+', '+z[1,6]+', '+z[2,6]+', '+z[3,6]+', '+z[4,6]+', '+z[5,6]+', '+z[6,6]
          endif else if fostype eq 'FOS-APP5' then begin
            printf,12, '# pixels, B0-Background, B1-Rare, B2-Patchy, B3-Transitional, B4-Dominant, B5-Interior'
            printf,12, 'A0-Background,  '+z[0,0]+', '+z[1,0]+', '+z[2,0]+', '+z[3,0]+', '+z[4,0]+', '+z[5,0]
            printf,12, 'A1-Rare,        '+z[0,1]+', '+z[1,1]+', '+z[2,1]+', '+z[3,1]+', '+z[4,1]+', '+z[5,1]
            printf,12, 'A2-Patchy,      '+z[0,2]+', '+z[1,2]+', '+z[2,2]+', '+z[3,2]+', '+z[4,2]+', '+z[5,2]
            printf,12, 'A3-Transitional,'+z[0,3]+', '+z[1,3]+', '+z[2,3]+', '+z[3,3]+', '+z[4,3]+', '+z[5,3]
            printf,12, 'A4-Dominant,    '+z[0,4]+', '+z[1,4]+', '+z[2,4]+', '+z[3,4]+', '+z[4,4]+', '+z[5,4]
            printf,12, 'A5-Interior,    '+z[0,5]+', '+z[1,5]+', '+z[2,5]+', '+z[3,5]+', '+z[4,5]+', '+z[5,5]
          endif
          printf,12, '  '
          printf,12, 'Gross area gain (Class A0 -> Class B*): ' + strtrim(gain,2) + ' pixels'
          printf,12, 'Gross area loss (Class A* -> B0): ' + strtrim(loss,2) + ' pixels'
          printf,12, 'Net area change (A->B): ' + strtrim(nc,2) + ' pixels'
          if fad_avok eq 8 then printf,12, 'FAD_av (A-B) [%]: ' + strtrim(a_fad_av,2) + ' - ' + $
            strtrim(b_fad_av,2) + ': ' + strtrim(a_fad_av - b_fad_av,2)
          printf,12, '  '
          printf,12, 'Relative fragmentation value increase is found below the matrix diagonal and expressed with positive percentages.'
          printf,12, 'Relative fragmentation value decrease is found above the matrix diagonal and expressed with negative percentages.'
          if fostype eq 'FOS' then begin
            printf,12, '% change A->B  :,  B1-Rare, B2-Patchy, B3-Transitional, B4-Dominant, B5-Interior, B6-Intact'
            printf,12, 'A1-Rare        :,'+zp[1,1]+','+zp[2,1]+','+zp[3,1]+','+zp[4,1]+','+zp[5,1]+','+zp[6,1]
            printf,12, 'A2-Patchy      :,'+zp[1,2]+','+zp[2,2]+','+zp[3,2]+','+zp[4,2]+','+zp[5,2]+','+zp[6,2]
            printf,12, 'A3-Transitional:,'+zp[1,3]+','+zp[2,3]+','+zp[3,3]+','+zp[4,3]+','+zp[5,3]+','+zp[6,3]
            printf,12, 'A4-Dominant    :,'+zp[1,4]+','+zp[2,4]+','+zp[3,4]+','+zp[4,4]+','+zp[5,4]+','+zp[6,4]
            printf,12, 'A5-Interior    :,'+zp[1,5]+','+zp[2,5]+','+zp[3,5]+','+zp[4,5]+','+zp[5,5]+','+zp[6,5]
            printf,12, 'A6-Intact      :,'+zp[1,6]+','+zp[2,6]+','+zp[3,6]+','+zp[4,6]+','+zp[5,6]+','+zp[6,6]
          endif else if fostype eq 'FOS-APP5' then begin
            printf,12, '% change A->B  :,  B1-Rare, B2-Patchy, B3-Transitional, B4-Dominant, B5-Interior'
            printf,12, 'A1-Rare        :,'+zp[1,1]+','+zp[2,1]+','+zp[3,1]+','+zp[4,1]+','+zp[5,1]
            printf,12, 'A2-Patchy      :,'+zp[1,2]+','+zp[2,2]+','+zp[3,2]+','+zp[4,2]+','+zp[5,2]
            printf,12, 'A3-Transitional:,'+zp[1,3]+','+zp[2,3]+','+zp[3,3]+','+zp[4,3]+','+zp[5,3]
            printf,12, 'A4-Dominant    :,'+zp[1,4]+','+zp[2,4]+','+zp[3,4]+','+zp[4,4]+','+zp[5,4]
            printf,12, 'A5-Interior    :,'+zp[1,5]+','+zp[2,5]+','+zp[3,5]+','+zp[4,5]+','+zp[5,5]           
          endif        
          close,12
                   
          skip_otherfoschange:
          msg = 'FOS change analysis finished. ' + string(10b) + $
            'Change matrix tables (txt, csv) were saved to:' + string(10b) + outdir
          res = dialog_message(msg, / information)         
          goto, contnormal ;;diffsim_finish
        endif        
        ;;======================  end of F O S  stuff  ========================================
            
        ;; FAD: we asked for the _mscale file but need to verify 7 files: 5 scales, mscale and the sav file
        a_pref = strmid(im1_file,0, strlen(im1_file)-11)
        b_pref = strmid(im2_file,0, strlen(im2_file)-11)
        fn_a = strarr(8) & fn_b = fn_a
        kdim_str = ['7', '13', '27', '81', '243','', '']
        
        for isc = 1, 7 do begin       
          ext = '_' + strtrim(kdim_str[isc-1],2) + '.tif'
          if isc eq 6 then ext = '_mscale.tif'
          if isc eq 7 then ext = '_mscale.sav'
          tt = a_pref + ext & res = file_info(tt)
          IF res.exists NE 1b THEN BEGIN
            msg = 'FAD change analysis requires the file:' + string(10b) +  file_basename(tt) + string(10b)+ 'which was not found. ' + $
              'Please do not modify FAD-created directories.' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information)
            GOTO, fin
          ENDIF
          fn_a[isc] = tt
          
          tt = b_pref + ext & res = file_info(tt)
          IF res.exists NE 1b THEN BEGIN
            msg = 'FAD change analysis requires the file:' + string(10b) +  file_basename(tt) + string(10b)+ 'which was not found. ' + $
              'Please do not modify FAD-created directories.' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information)
            GOTO, fin
          ENDIF
          fn_b[isc] = tt         
        endfor
        
        ;; restore sav files
        restore,fn_a[7] & a_xdim=xdim & a_ydim=ydim & a_fadtype = fadtype
        ;; check if fad_av was saved, if so then use it
        a_tt = (size(fad_av))[1]
        if a_tt eq 6 then a_fad_av = fad_av

        restore, fn_b[7] & b_xdim=xdim & b_ydim=ydim & b_fadtype = fadtype 
        ;; check if fad_av was saved, if so then use it
        b_tt = (size(fad_av))[1]        
        if b_tt eq 6 then b_fad_av = fad_av
        fad_avok = a_tt + b_tt
       
        res = (a_xdim eq b_xdim) + (a_ydim eq b_ydim) + (a_fadtype eq b_fadtype)

        if res ne 3b then begin
          msg = 'FAD change analysis requires identical values for' + string(10b) + $
            'X/Y-image dimension and FAD type. ' + string(10b) + $
            'The selected images have different settings. ' + string(10b) + 'Returning...'
          res = dialog_message(msg, / information)
          GOTO, fin
        endif
       ;;========================================================================================
        ;; 1) reset the viewport image
        ;;========================================================================================
        title = 'Change in FAD Processing'
        goto, resetfront
        backto_change_fad:
     
        ;;========================================================================================
        ;; 2) the matrix change:  calculate it for all 6 observations (5 + summary)
        ;;===============================================================================================
        kstr = ['', '7x7', '13x13', '27x27', '81x81', '243x243', 'average over 7x7-13x13-27x27-81x81-243x243'] + ' pixels'
        kdim_str = ['', '7', '13', '27', '81', '243','mscale']
        for isc = 1, 6 do begin
          ;; loop over the 6 scales
          change = dblarr(7, 7) & ext = strtrim(kdim_str[isc],2)
          im1 = read_tiff(fn_a[isc]) & im2 = read_tiff(fn_b[isc])
          ;; potential values in scale images are the actual FAD values: 
          ; 1-100, 101-BG, 102-missing, 105-special BG, 106-specialBG non-fragm.
                            
          ;; exclude missing data from both maps, temporarily set them to 150b
          q = where(im1 eq 102b or im2 eq 102b, ctmiss, /l64)
          if ctmiss gt 0 then begin
            im1[q]=150b & im2[q]=150b
          endif
          ;; collapse all background types in im1 and im2
          q = where(im2 gt 100b and im2 lt 150b, ct, /l64) & if ct gt 0 then im2[q]=110b
          q = where(im1 gt 100b and im1 lt 150b, ct, /l64) & if ct gt 0 then im1[q]=110b
                    

          ;; get pixels of each class type in im1 and look what they changed to in im2
          ch = dblarr(7) ; reset change vector and look for BG pixels in im1     
          if ct gt 0 then begin ;; im1 has BG-pixels
            h=histogram(im2[q]) & ch = [h[110],total(h[0:9]),total(h[10:39]),total(h[40:59]),total(h[60:89]),total(h[90:99]),h[100]]
            change[*,0] = ch
          endif
          ch = ch*0 & q = where(im1 lt 10b, ct, /l64)
          if ct gt 0 then begin ;; im1 has rare pixels
            h=histogram(im2[q]) & ch = [h[110],total(h[0:9]),total(h[10:39]),total(h[40:59]),total(h[60:89]),total(h[90:99]),h[100]]
            change[*,1] = ch
          endif
          ch = ch*0 & q = where(im1 ge 10b and im1 le 39b, ct, /l64)
          if ct gt 0 then begin ;; im1 has patchy pixels
            h=histogram(im2[q]) & ch = [h[110],total(h[0:9]),total(h[10:39]),total(h[40:59]),total(h[60:89]),total(h[90:99]),h[100]]
            change[*,2] = ch
          endif
          ch = ch*0 & q = where(im1 ge 40b and im1 le 59b, ct, /l64)
          if ct gt 0 then begin ;; im1 has transitional pixels
            h=histogram(im2[q]) & ch = [h[110],total(h[0:9]),total(h[10:39]),total(h[40:59]),total(h[60:89]),total(h[90:99]),h[100]]
            change[*,3] = ch
          endif
          ch = ch*0 & q = where(im1 ge 60b and im1 le 89b, ct, /l64)
          if ct gt 0 then begin ;; im1 has dominant pixels
            h=histogram(im2[q]) & ch = [h[110],total(h[0:9]),total(h[10:39]),total(h[40:59]),total(h[60:89]),total(h[90:99]),h[100]]
            change[*,4] = ch
          endif
          ch = ch*0 & q = where(im1 ge 90b and im1 lt 100b, ct, /l64)
          if ct gt 0 then begin ;; im1 has interior pixels
            h=histogram(im2[q]) & ch = [h[110],total(h[0:9]),total(h[10:39]),total(h[40:59]),total(h[60:89]),total(h[90:99]),h[100]]
            change[*,5] = ch
          endif
          ch = ch*0 & q = where(im1 eq 100b, ct, /l64)
          if ct gt 0 then begin ;; im1 has intact pixels
            h=histogram(im2[q]) & ch = [h[110],total(h[0:9]),total(h[10:39]),total(h[40:59]),total(h[60:89]),total(h[90:99]),h[100]]
            change[*,6] = ch
          endif
                    
          ;; calculate percentage of change in the sub-matrix
          perc = change*0
          sum_below = total(change[1,2:*],/double) + total(change[2,3:*],/double) + total(change[3,4:*],/double) + total(change[4,5:*],/double) + change[5,6]
          sum_above = total(change[2:*,1],/double) + total(change[3:*,2],/double) + total(change[4:*,3],/double) + total(change[5:*,4],/double) + change[6,5]
          for ix = 1,6 do begin
            for iy = 1,6 do begin
              if iy gt ix then perc[ix,iy]=change[ix,iy]/sum_below*100.0
              if iy lt ix then perc[ix,iy]=change[ix,iy]/sum_above*(-100.0)
            endfor
          endfor 
          ;; get integer numbers
          uchange = strtrim(ulong64(change),2)
          if fadtype eq 'FAD' then lx = 6 else lx = 5
         
          ;; save the tables into tmp as a txt-file
          close,12 & openw,12, info.dir_tmp + fadtype + '_change_' + ext + '.txt'
          printf,12, fadtype + ': Fragmentation class change from A -> B at observation scale: ' + kstr[isc]
          printf,12, 'A-' + fn_a[isc] + '   ->   ' 
          printf,12, 'B-' + fn_b[isc]
          printf,12, '=============================================================================================================================================='
          if fadtype eq 'FAD' then printf,12, '# pixels A->B  :     B0-Background           B1-Rare         B2-Patchy    B3-Transitional      B4-Dominant       B5-Interior         B6-Intact'
          if fadtype eq 'FAD-APP5' then printf,12, '# pixels A->B  :     B0-Background           B1-Rare         B2-Patchy    B3-Transitional      B4-Dominant       B5-Interior'
          printf,12, format='(a16,7(a18))','A0-Background  :', uchange[0:lx,0]
          printf,12, format='(a16,7(a18))','A1-Rare        :', uchange[0:lx,1]
          printf,12, format='(a16,7(a18))','A2-Patchy      :', uchange[0:lx,2]
          printf,12, format='(a16,7(a18))','A3-Transitional:', uchange[0:lx,3]
          printf,12, format='(a16,7(a18))','A4-Dominant    :', uchange[0:lx,4]
          printf,12, format='(a16,7(a18))','A5-Interior    :', uchange[0:lx,5]
          if fadtype eq 'FAD' then printf,12, format='(a16,7(a18))','A6-Intact      :', uchange[*,6]
          printf,12, '  '
          gain=total(change[1:*,0]) & loss=total(change[0,1:*]) & nc=gain-loss & if nc lt 0.0 then sig = '-' else sig = '' & nc2 = strtrim(ulong64(abs(nc)),2)
          printf,12, 'Gross area gain (Class A0 -> Class B*): ' + strtrim(ulong64(gain),2) + ' pixels'
          printf,12, 'Gross area loss (Class A* -> B0): ' + strtrim(ulong64(loss),2) + ' pixels'
          printf,12, 'Net area change (A->B): ' + sig + nc2 + ' pixels'
          if fad_avok eq 12 then begin
            printf, 12, '========================================================================================='            
            printf, 12, 'Observation scale:        1          2           3           4           5         mscale'
            printf, 12, 'Neighborhood area:       7x7       13x13       27x27       81x81      243x243'
            deltafad_av = a_fad_av - b_fad_av           
            printf,12, format='(a18,7(a12))','Diff: FAD_AV(A-B):', deltafad_av            
          endif          
          printf,12, '  '
          printf,12, 'Relative fragmentation value increase is found below the matrix diagonal and expressed with positive percentages.'
          printf,12, 'Relative fragmentation value decrease is found above the matrix diagonal and expressed with negative percentages.'
          if fadtype eq 'FAD' then printf,12, '% change A->B  :         B1-Rare       B2-Patchy   B3-Transitional   B4-Dominant     B5-Interior       B6-Intact'
          if fadtype eq 'FAD-APP5' then printf,12, '% change A->B  :         B1-Rare       B2-Patchy   B3-Transitional   B4-Dominant     B5-Interior'
          printf,12, format='(8(a16))','A1-Rare        :',perc[1:lx,1]
          printf,12, format='(8(a16))','A2-Patchy      :',perc[1:lx,2]
          printf,12, format='(8(a16))','A3-Transitional:',perc[1:lx,3]
          printf,12, format='(8(a16))','A4-Dominant    :',perc[1:lx,4]
          printf,12, format='(8(a16))','A5-Interior    :',perc[1:lx,5]
          if fadtype eq 'FAD' then printf,12, format='(8(a16))','A6-Intact      :',perc[1:*,6]
          printf,12, '  '
          close,12
          
          ;; save the tables into tmp as a csv-file
          z=strtrim(change,2) & zp=strtrim(perc,2)           
          close,12 & openw,12, info.dir_tmp + fadtype + '_change_' + ext + '.csv'          
          printf,12, fadtype + ': Fragmentation class change: A-' + fn_a[isc] + '   ->   ' + 'B-' + fn_b[isc] + ' at observation scale: ' + kstr[isc]
          if fadtype eq 'FAD' then begin
            printf,12, '# pixels, B0-Background, B1-Rare, B2-Patchy, B3-Transitional, B4-Dominant, B5-Interior, B6-Intact'
            printf,12, 'A0-Background,  '+z[0,0]+', '+z[1,0]+', '+z[2,0]+', '+z[3,0]+', '+z[4,0]+', '+z[5,0]+', '+z[6,0]
            printf,12, 'A1-Rare,        '+z[0,1]+', '+z[1,1]+', '+z[2,1]+', '+z[3,1]+', '+z[4,1]+', '+z[5,1]+', '+z[6,1]
            printf,12, 'A2-Patchy,      '+z[0,2]+', '+z[1,2]+', '+z[2,2]+', '+z[3,2]+', '+z[4,2]+', '+z[5,2]+', '+z[6,2]
            printf,12, 'A3-Transitional,'+z[0,3]+', '+z[1,3]+', '+z[2,3]+', '+z[3,3]+', '+z[4,3]+', '+z[5,3]+', '+z[6,3]
            printf,12, 'A4-Dominant,    '+z[0,4]+', '+z[1,4]+', '+z[2,4]+', '+z[3,4]+', '+z[4,4]+', '+z[5,4]+', '+z[6,4]
            printf,12, 'A5-Interior,    '+z[0,5]+', '+z[1,5]+', '+z[2,5]+', '+z[3,5]+', '+z[4,5]+', '+z[5,5]+', '+z[6,5]
            printf,12, 'A6-Intact,      '+z[0,6]+', '+z[1,6]+', '+z[2,6]+', '+z[3,6]+', '+z[4,6]+', '+z[5,6]+', '+z[6,6]
          endif else begin ;; FAD-APP5
            printf,12, '# pixels, B0-Background, B1-Rare, B2-Patchy, B3-Transitional, B4-Dominant, B5-Interior'
            printf,12, 'A0-Background,  '+z[0,0]+', '+z[1,0]+', '+z[2,0]+', '+z[3,0]+', '+z[4,0]+', '+z[5,0]
            printf,12, 'A1-Rare,        '+z[0,1]+', '+z[1,1]+', '+z[2,1]+', '+z[3,1]+', '+z[4,1]+', '+z[5,1]
            printf,12, 'A2-Patchy,      '+z[0,2]+', '+z[1,2]+', '+z[2,2]+', '+z[3,2]+', '+z[4,2]+', '+z[5,2]
            printf,12, 'A3-Transitional,'+z[0,3]+', '+z[1,3]+', '+z[2,3]+', '+z[3,3]+', '+z[4,3]+', '+z[5,3]
            printf,12, 'A4-Dominant,    '+z[0,4]+', '+z[1,4]+', '+z[2,4]+', '+z[3,4]+', '+z[4,4]+', '+z[5,4]
            printf,12, 'A5-Interior,    '+z[0,5]+', '+z[1,5]+', '+z[2,5]+', '+z[3,5]+', '+z[4,5]+', '+z[5,5]
          endelse                   
          printf,12, '  '
          printf,12, 'Gross area gain (Class A0 -> Class B*): ' + strtrim(gain,2) + ' pixels'
          printf,12, 'Gross area loss (Class A* -> B0): ' + strtrim(loss,2) + ' pixels'
          printf,12, 'Net area change (A->B): ' + strtrim(nc,2) + ' pixels'          
          if fad_avok eq 12 then begin
            z = strtrim(deltafad_av,2)
            printf,12, 'Observation scale:, 1, 2, 3, 4, 5, Summary'
            printf, 12, 'Neighborhood area:, 7x7, 13x13, 27x27, 81x81, 243x243,' 
            printf,12,'Diff: FAD_AV(A-B):, ' +z[0]+', '+z[1]+', '+z[2]+', '+z[3]+', '+z[4]+', '+z[5]
          endif                  
          printf,12, '  '
          printf,12, 'Relative fragmentation value increase is found below the matrix diagonal and expressed with positive percentages.'
          printf,12, 'Relative fragmentation value decrease is found above the matrix diagonal and expressed with negative percentages.'
          if fadtype eq 'FAD' then begin
            printf,12, '% change A->B,  B1-Rare, B2-Patchy, B3-Transitional, B4-Dominant, B5-Interior, B6-Intact'
            printf,12, 'A1-Rare,'+zp[1,1]+','+zp[2,1]+','+zp[3,1]+','+zp[4,1]+','+zp[5,1]+','+zp[6,1]
            printf,12, 'A2-Patchy,'+zp[1,2]+','+zp[2,2]+','+zp[3,2]+','+zp[4,2]+','+zp[5,2]+','+zp[6,2]
            printf,12, 'A3-Transitional,'+zp[1,3]+','+zp[2,3]+','+zp[3,3]+','+zp[4,3]+','+zp[5,3]+','+zp[6,3]
            printf,12, 'A4-Dominant,'+zp[1,4]+','+zp[2,4]+','+zp[3,4]+','+zp[4,4]+','+zp[5,4]+','+zp[6,4]
            printf,12, 'A5-Interior,'+zp[1,5]+','+zp[2,5]+','+zp[3,5]+','+zp[4,5]+','+zp[5,5]+','+zp[6,5]
            printf,12, 'A6-Intact,'+zp[1,6]+','+zp[2,6]+','+zp[3,6]+','+zp[4,6]+','+zp[5,6]+','+zp[6,6]           
          endif else begin ;; FAD-APP5
            printf,12, '% change A->B,  B1-Rare, B2-Patchy, B3-Transitional, B4-Dominant, B5-Interior'
            printf,12, 'A1-Rare,'+zp[1,1]+','+zp[2,1]+','+zp[3,1]+','+zp[4,1]+','+zp[5,1]
            printf,12, 'A2-Patchy,'+zp[1,2]+','+zp[2,2]+','+zp[3,2]+','+zp[4,2]+','+zp[5,2]
            printf,12, 'A3-Transitional,'+zp[1,3]+','+zp[2,3]+','+zp[3,3]+','+zp[4,3]+','+zp[5,3]
            printf,12, 'A4-Dominant,'+zp[1,4]+','+zp[2,4]+','+zp[3,4]+','+zp[4,4]+','+zp[5,4]
            printf,12, 'A5-Interior,'+zp[1,5]+','+zp[2,5]+','+zp[3,5]+','+zp[4,5]+','+zp[5,5]
          endelse       
          close,12

        endfor ;; loop over observation scales
        
        ;; show the summary image statistics
        xdisplayfile, info.dir_tmp + fadtype + '_change_mscale.txt', title = 'FAD change for mscale image', width=100,/grow

        ;;========================================================================================
        ;; 3) the FAD change chart
        ;;==============================================================
        ;;a) restore the sav-file to do the graph-plot
        restore,fn_a[7]
        a_xdim=xdim & a_ydim=ydim & a_geotiff_log=geotiff_log & a_rare=rare & a_patchy=patchy & a_transitional=transitional
        a_dominant=dominant & a_interior=interior & a_intact=intact & a_fgarea=fgarea
        restore,fn_b[7]
        b_xdim=xdim & b_ydim=ydim & b_geotiff_log=geotiff_log & b_rare=rare & b_patchy=patchy & b_transitional=transitional
        b_dominant=dominant & b_interior=interior & b_intact=intact & b_fgarea=fgarea

        restore, info.dir_guidossub + 'fadcolors.sav' & tvlct,r,g,b
        info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 8 ;; fad
        scales = indgen(6)+1 & x_sum = [5.8, 6.2]
        if fadtype eq 'FAD' then begin
          b1 = PLOT(scales[0:4], b_intact[0:4], Color=[0,120,0], thick=3, yrange=[-4,104], xrange=[0.2, 9.9],$
            ytitle='Foreground proportion [%]', xtitle='              Observation scale | MultiScale | Legend', $
            title='Change in ' +fadtype + ': A -> B', xticklen=0.02,yticklen=0.02,xminor=1, xtickv=[1,2,3,4,5],/buffer)
          b1a = PLOT(x_sum, [b_intact[5],b_intact[5]], Color=[0,120,0], thick=3, /overplot)
          y2 = b_interior+b_intact
          b2 = PLOT(scales[0:4],y2[0:4], Color=[0,175,0], thick=3, /overplot)
          b2a = PLOT(x_sum, [y2[5],y2[5]], Color=[0,175,0], thick=3, /overplot)
        endif else begin ;; FAD-APP5
          b1 = PLOT(scales[0:4], b_interior[0:4], Color=[0,175,0], thick=3, yrange=[-4,104], xrange=[0.2, 9.9],$
            ytitle='Foreground proportion [%]', xtitle='              Observation scale | MultiScale | Legend', $
            title='Change in ' +fadtype + ': A -> B', xticklen=0.02,yticklen=0.02,xminor=1, xtickv=[1,2,3,4,5],/buffer)
          b1a = PLOT(x_sum, [b_interior[5],b_interior[5]], Color=[0,175,0], thick=3, /overplot)
          y2 = b_interior
        endelse
        y2 = b_dominant+y2
        b3 = PLOT(scales[0:4],y2[0:4], Color=[140,200,100], thick=3,/overplot)
        b3a = PLOT(x_sum, [y2[5],y2[5]], Color=[140,200,100], thick=3, /overplot)
        y2 = b_transitional+y2
        b4 = PLOT(scales[0:4],y2[0:4], Color=[255,200,0], thick=3,/overplot)
        b4a = PLOT(x_sum, [y2[5],y2[5]], Color=[255,200,0], thick=3, /overplot)
        y2 = b_patchy+y2
        b5 = PLOT(scales[0:4],y2[0:4], Color=[250,140,90], thick=3,/overplot)
        b5a = PLOT(x_sum, [y2[5],y2[5]], Color=[250,140,90], thick=3, /overplot)
        y2 = b_rare+y2
        b6 = PLOT(scales[0:4],y2[0:4], Color=[215,50,40], thick=3,/overplot)
        b6a = PLOT(x_sum, [y2[5],y2[5]], Color=[215,50,40], thick=3, /overplot)
        a = plot([5.5, 5.5],[-4, 104], /data, color='Black',/overplot, thick=3)
        a = plot([6.5, 6.5],[-4, 104], /data, color='Black',/overplot, thick=3)
        a = text(6.7,95, fadtype, /data,/current)
        a = text(6.7,90,'Fragmentation class: ',/data,/current)
        c = symbol(6.9,85,'square',/data, /sym_filled, sym_color=[215,50,40],sym_size=2,LABEL_STRING='Rare')
        c = symbol(6.9,78,'square',/data, /sym_filled, sym_color=[250,140,90],sym_size=2,LABEL_STRING='Patchy')
        c = symbol(6.9,71,'square',/data, /sym_filled, sym_color=[255,200,0],sym_size=2,LABEL_STRING='Transitional')
        c = symbol(6.9,64,'square',/data, /sym_filled, sym_color=[140,200,100],sym_size=2,LABEL_STRING='Dominant')
        c = symbol(6.9,57,'square',/data, /sym_filled, sym_color=[0,175,0],sym_size=2,LABEL_STRING='Interior')
        if fadtype eq 'FAD' then c = symbol(6.9,50,'square',/data, /sym_filled, sym_color=[0,120,0],sym_size=2,LABEL_STRING='Intact')
        q = plot([6.8, 7.2],[40, 40], /data, color='Black',/overplot, thick=2, linestyle=1)
        a = text(7.4, 39, 'Time A',/data)
        q = plot([6.8, 7.2],[34, 34], /data, color='Black',/overplot, thick=2)
        a = text(7.4, 33, 'Time B',/data)
        ;; now the time A stats
        if fadtype eq 'FAD' then begin
          b1 = PLOT(scales[0:4], a_intact[0:4], Color=[0,120,0], thick=3, linestyle=1, /overplot)
          b1a = PLOT(x_sum, [a_intact[5],a_intact[5]], Color=[0,120,0], thick=3, linestyle=1, /overplot)
        endif
        y2 = a_interior+a_intact
        b2 = PLOT(scales[0:4],y2[0:4], Color=[0,175,0], thick=3, linestyle=1, /overplot)
        b2a = PLOT(x_sum, [y2[5],y2[5]], Color=[0,175,0], thick=3, linestyle=1, /overplot)
        y2 = a_dominant+y2
        b3 = PLOT(scales[0:4],y2[0:4], Color=[140,200,100], thick=3, linestyle=1,/overplot)
        b3a = PLOT(x_sum, [y2[5],y2[5]], Color=[140,200,100], thick=3, linestyle=1, /overplot)
        y2 = a_transitional+y2
        b4 = PLOT(scales[0:4],y2[0:4], Color=[255,200,0], thick=3, linestyle=1,/overplot)
        b4a = PLOT(x_sum, [y2[5],y2[5]], Color=[255,200,0], thick=3, linestyle=1, /overplot)
        y2 = a_patchy+y2
        b5 = PLOT(scales[0:4],y2[0:4], Color=[250,140,90], thick=3, linestyle=1,/overplot)
        b5a = PLOT(x_sum, [y2[5],y2[5]], Color=[250,140,90], thick=3, linestyle=1, /overplot)
        y2 = a_rare+y2
        b6 = PLOT(scales[0:4],y2[0:4], Color=[215,50,40], thick=3, linestyle=1,/overplot)
        b6a = PLOT(x_sum, [y2[5],y2[5]], Color=[215,50,40], thick=3, linestyle=1, /overplot)

        ;; area change
        str = long64(b_fgarea) - long64(a_fgarea) & str = strtrim(str,2)
        a = text(6.7,20,'FG-Area change [pixels]:',/data,/current)
        a = text(6.7,15, str, /data, /current)
        b1.save,info.dir_tmp + fadtype + '_change_barplot.png', resolution=300
        ;; open barplot image
        IF info.my_os EQ 'apple' THEN BEGIN
          spawn, 'open ' + info.dir_tmp + fadtype + '_change_barplot.png'
        ENDIF ELSE IF info.my_os EQ 'windows' THEN BEGIN
          pushd, info.dir_tmp
          spawn, 'start ' + fadtype + '_change_barplot.png', / nowait
          popd
        ENDIF ELSE BEGIN ;; Linux
          IF strlen(info.xdgop) EQ 0 THEN BEGIN
            st = "Please install xdg-open to automatically" + $
              "display barplots within GuidosToolbox."
            result = dialog_message(st, / information)
          ENDIF ELSE BEGIN
            spawn, info.xdgop + ' "' + info.dir_tmp + fadtype + '_change_barplot.png' + '"'
          ENDELSE
        ENDELSE
      
        ;; Show dialog info to save the FAD change analysis
        ;; we will save: the chart and 6 tables for the 5 observation + summary scale
        msg = 'FAD change analysis finished. Please select: ' + string(10b) + $
          'Yes: Save chart + 6 change matrix tables (txt, csv), or' + string(10b) + $
          'No: Continue without saving the results.' 
        res = dialog_message(msg, / question)
        
        IF res EQ 'Yes' THEN BEGIN
          ;; save all in a zip file
          fname = fadtype + '_change.zip'
          fname_def = info.dir_data + fname

          newfadzipname:
          dir_fadchange = $
            dialog_pickfile(file = fname, get_path = path2file, $
            / write, / directory, path = info.dir_data, title = fadtype + ' change output directory')
          IF (strlen(dir_fadchange) - strlen(path2file) EQ 4) OR $
            (dir_fadchange EQ '') THEN GOTO, fin  ;; no name or 'cancel' selected

          ;; fix a M$ bug ;; to really?
          ;; IF info.my_os EQ 'windows' THEN dir_fadchange = dir_fadchange + fname + '\'
          ;; check if that zip already exist
          fadzip = strmid(dir_fadchange,0,strlen(dir_fadchange)-1) 
          if fadzip eq fname_def then fadzip = fadzip else fadzip = dir_fadchange + fname 
          tt = file_info(fadzip) & tt = tt.exists 
          IF tt EQ 1b THEN BEGIN
            msg = 'A zip archive with this name already exist.' + $
              string(10b) + 'Overwrite (Yes) or select new name (No)?'
            res = dialog_message(msg, / question)
            IF res EQ 'No' THEN GOTO, newfadzipname
          ENDIF

          ;; ok, now save the fadchange files
          pushd, info.dir_tmp
          dd = fadtype + '_change'
          file_delete,dd,/allow, /recursive, /quiet
          file_mkdir, dd
          file_copy,fadtype + '_change_*',dd,/overwrite          
                  
          ;; build the archive
          file_zip, dd, 'tempfadx.zip'                        
          popd
          file_move, info.dir_tmp + 'tempfadx.zip', fadzip, /overwrite
          msg = "FAD change results were saved to:" + string(10b) + fadzip
          result = dialog_message(msg, / information)
          
        ENDIF   ;; end of saving FAD change results
        goto, fin        
      endif
      ;;===================================================================================================
      ;;======   end of FAD change   ========
      ;;===================================================================================================


      
          
      ;; if same projection get common area 
      ;;==================================== 
      ;; common framebox for A and B
      ;; pixel size
      ;; xx = strsplit(p1,',',/extract)
      ;; px1 = strsplit(xx[0],'(',/extract) & px1 = abs(double(strtrim(px1[1],2)))
      ;; px2 = strsplit(xx[1],')',/extract) & px2 = abs(double(strtrim(px2[0],2)))
      ;; pstr = '-ps '+ strtrim(px1,2) + ' ' + strtrim(px2,2)
      
      ;; upper left
      q = where(STREGEX(log1, 'Upper Left', /FOLD_CASE) eq 0) & st = log1[q[0]]
      xx = strsplit(st,',',/extract)
      xx1 = strsplit(xx[0],'(',/extract) & ulx1 = double(strtrim(xx1[1],2))
      xx2 = strsplit(xx[1],')',/extract) & uly1 = double(strtrim(xx2[0],2))
      q = where(STREGEX(log2, 'Upper Left', /FOLD_CASE) eq 0) & st = log2[q[0]]
      xx = strsplit(st,',',/extract)
      xx1 = strsplit(xx[0],'(',/extract) & ulx2 = double(strtrim(xx1[1],2))
      xx2 = strsplit(xx[1],')',/extract) & uly2 = double(strtrim(xx2[0],2))
      ;; lower right
      q = where(STREGEX(log1, 'Lower Right', /FOLD_CASE) eq 0) & st = log1[q[0]]
      xx = strsplit(st,',',/extract)
      xx1 = strsplit(xx[0],'(',/extract) & lrx1 = double(strtrim(xx1[1],2))
      xx2 = strsplit(xx[1],')',/extract) & lry1 = double(strtrim(xx2[0],2))
      q = where(STREGEX(log2, 'Lower Right', /FOLD_CASE) eq 0) & st = log2[q[0]]
      xx = strsplit(st,',',/extract)
      xx1 = strsplit(xx[0],'(',/extract) & lrx2 = double(strtrim(xx1[1],2))
      xx2 = strsplit(xx[1],')',/extract) & lry2 = double(strtrim(xx2[0],2))

      ;; common area
      ;; xleftcommon: xlc, xrc  ytopcommon: ytc, ybc
      ;; do not use long(xlc) etc because this will create rounding errors 
      ;; and may result in empty lines/rows for the difference image 
      if ulx1 gt ulx2 then xlc=ulx1 else xlc=ulx2 ;& xlc=long(xlc)
      if lrx1 lt lrx2 then xrc=lrx1 else xrc=lrx2 ;& xrc=long(xrc)
      
      if uly1 lt uly2 then ytc=uly1 else ytc=uly2 ;& ytc=long(ytc)
      if lry1 gt lry2 then ybc=lry1 else ybc=lry2 ;& ybc=long(ybc)
      
      ;; check if the common area matches
      if (xrc le xlc) or (ybc ge ytc) then begin
        ;; no overlap
        msg = 'Image A and B do not overlap.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      endif
        
      ;; extract common area from A and B       
      ;; define gdal_translate
      IF info.my_os EQ 'windows' THEN BEGIN
         gtrans = info.windrive + ' & cd "' + info.dir_fwtools + '" & setfw.bat & '
         gtrans = gtrans + 'cd "' + info.dir_tmp + $
                  '" & gdal_translate -co ' + $
                  '"COMPRESS=LZW" -projwin '
      ENDIF ELSE BEGIN ;; linux/apple
         if strlen(info.sysgdal) gt 0 then $
          gtrans = 'unset LD_LIBRARY_PATH; gdal_translate -co ' + '"COMPRESS=LZW" -projwin ' else $
          gtrans = info.dir_fwtools + 'gdal_translate -co ' + '"COMPRESS=LZW" -projwin '
      ENDELSE
      gtrans1 = gtrans + strtrim(xlc, 2) + ' ' + strtrim(ytc, 2) + $
               ' ' + strtrim(xrc, 2) + ' ' + strtrim(ybc, 2) + ' ' + $
               im1_file + ' ' + info.dir_tmp + 'im1com.tif'
      IF info.my_os EQ 'windows' THEN $
        spawn, gtrans1, log, / hide ELSE spawn, gtrans1, log
      gtrans2 = gtrans + strtrim(xlc, 2) + ' ' + strtrim(ytc, 2) + $
        ' ' + strtrim(xrc, 2) + ' ' + strtrim(ybc, 2) + ' ' + $
        im2_file + ' ' + info.dir_tmp + 'im2com.tif'
      IF info.my_os EQ 'windows' THEN $
        spawn, gtrans2, log, / hide ELSE spawn, gtrans2, log
      

      ;; check if they have a common data area
      im1com = read_tiff(info.dir_tmp + 'im1com.tif', geotiff=geotiff_com)
      im2com = read_tiff(info.dir_tmp + 'im2com.tif')
      mask1=im1com gt 0b & mask2=im2com gt 0b & tmp=mask1+mask2
      q=where(tmp eq 2b, ct, /l64)
      if ct eq 0 then begin
        ;; no overlap in data area
        msg = 'Image A and B do not share a common data area' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      endif

      if eventValue2 eq 'change_simple' then begin
        im1 = temporary(im1com) 
        im2 = temporary(im2com)       
        restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b
        info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 3 ;; classification
        * info.geotiffinfo = geotiff_com & info.is_geotiff = 1
        GOTO, diffsimgeo
      endif
      
      ;; do the morph change
      ;;=========================================================
      ;; test if they are MSPA-compliant
      MSPA_Compliance, info.dir_tmp + 'im1com.tif', im1com, info.immaxsizeg, 1, result
      IF result EQ 0 THEN GOTO, fin  ;; invalid input
      MSPA_Compliance, info.dir_tmp + 'im2com.tif', im2com, info.immaxsizeg, 1, result
      IF result EQ 0 THEN GOTO, fin  ;; invalid input   

      restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b 
      info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 3 ;; classification
      * info.geotiffinfo = geotiff_com & info.is_geotiff = 1
            
      ;;  1) dist22
      ;;=========================================================
      ;; build distance map
      fm90 = temporary(im1com)
      fmdistg, info.dir_tmp + 'im1com.tif', 2, 2, imdist90
      fmdistg, info.dir_tmp + 'im2com.tif', 2, 2, imdist00
      
      ;; core2core image. 208=coreFG, 192=coreBG
      loss = where((imdist90 EQ 208b) AND (imdist00 EQ 192b), ctloss, /l64)
      gain = where((imdist90 EQ 192b) AND (imdist00 EQ 208b), ctgain, /l64)
      c2c = imdist90 * 0b
      IF ctloss GT 0 THEN c2c(loss) = 192b
      IF ctgain GT 0 THEN c2c(gain) = 208b

      ;; 2) difference map fmask: 1990-2000
      ;;=========================================================
      fm00 = temporary(im2com)
      difffm = (fm90 EQ 1b AND fm00 EQ 1b) * 11b + $
        (fm90 EQ 1b AND fm00 EQ 2b) * 12b + $
        (fm90 EQ 2b AND fm00 EQ 1b) * 21b + $
        (fm90 EQ 2b AND fm00 EQ 2b) * 22b
      q = where(fm90 EQ 3b OR fm90 EQ 0b OR fm00 EQ 3b OR fm00 EQ 0b, ct, /l64)
      IF ct GT 0 THEN difffm(q) = 3b
      
      ;; area at time A and B
      im1_2b = total(fm90 eq 2b,/double) & fm90 = 0
      im2_2b = total(fm00 eq 2b,/double) & fm00 = 0
      
      ;; 3a) reconstruction of gains/losses with c2c(dist22) as seeds
      ;;=========================================================
      losses = (difffm EQ 21b) & gains = (difffm EQ 12b) & sel = bytarr(3, 3) + 1b
      seedloss = c2c EQ 192b & tt0 = total(seedloss) & tt1 = tt0 + 1
      WHILE tt1 GT tt0 DO BEGIN
        tt0 = total(seedloss)
        seedloss = dilate(seedloss, sel) * losses
        tt1 = total(seedloss)
      ENDWHILE
      seedgain = c2c EQ 208b & tt0 = total(seedgain) & tt1 = tt0 + 1
      WHILE tt1 GT tt0 DO BEGIN
        tt0 = total(seedgain)
        seedgain = dilate(seedgain, sel) * gains
        tt1 = total(seedgain)
      ENDWHILE

      rec = seedgain * 208b + seedloss * 192b
      
      ;; 3b) closing reconstruction
      ;;=========================================================
      ;; color code corresponding to MSPA forest definition:
      ;; loss - red: 21b    gain - green: 12b   missing: 255b   spurious: 176b
      diffsim = morph_close(seedgain, sel) * 12b + morph_close(seedloss, sel) * 21b
        
      ;; some pixels are both (12+21) so assign those 33b to 12b
      q=where(diffsim eq 33b,ct, /l64) & if ct gt 0 then diffsim(q)=12b
      
      
      ;; test: 196 = 11, 212 = 22, 0
      difffm = (difffm eq 11b)*11b + (difffm eq 22b)*22b + (difffm eq 3b)*255b
      q = where(diffsim eq 12b,ct, /l64) & if ct gt 0 then difffm(q) = 12b
      q = where(diffsim eq 21b,ct, /l64) & if ct gt 0 then difffm(q) = 21b
      q = where(difffm eq 0b,ct, /l64) & if ct gt 0 then difffm(q) = 176b
      diffsim = temporary(difffm)
      
      ;; 4) labeling change areas
      ;;=========================================================
      ;; wrong to apply to all!
      ;; lab_reccl = label_region(reccl, / ulong, / all_neighbors)
      ;; reccl = diffsim
      ;loss = reccl EQ 21b & gain = reccl EQ 12b
      ;lloss = label_region(loss, / ulong, / all_neighbors) & mxl = max(lloss)
      ;ggain = label_region(gain, / ulong, / all_neighbors)
      
      ;ggain = (ggain GT 0) * mxl + ggain
      ;lab_reccl = lloss + ggain
      ;fn = info.dir_data + 'labreccl.tif'
      ;write_tiff, fn, lab_reccl, red = r, green = g, blue = b, /long, geotiff=geotiff_com

      ;diffsim=gain*12b+(loss*21b)
      ;fn = info.dir_data + 'labreccl_changes.tif'
      ;write_tiff, fn, diffsim, red = r, green = g, blue = b, geotiff = geotiff_com
   
   
      ;; elasticity
      s = replicate(1b, 3, 3) ;; SE
      z = (diffsim eq 22b or diffsim eq 21b) & fma = total(z) & z = erode(z,s) & fia = total(z)
      z = (diffsim eq 22b or diffsim eq 12b) & fmb = total(z) & z = erode(z,s) & fib = total(z)
      z = 0 & elasticity = 'NA'
      ptot = 100.0/fmA*fmB - 100.0 
      IF abs(fia - fib) LT 0.000001 THEN pitot = 0.0 else pitot = 100/fia*fib - 100.0 
      IF abs(ptot) GT 0.000001 THEN elasticity = pitot/ptot

      info.title = 'MCD (A->B) FG: ' + strtrim(ptot,2) + ', FGi: ' + strtrim(pitot,2) + $
        ', Elasticity: ' + strtrim(elasticity,2)
        
      ;; do statistics
      openw, 1, info.dir_tmp + 'mcd.txt'
      printf, 1, info.title
      ;; get change MCD stats
      hh = histogram(diffsim)
      gain = strtrim(hh[12],2)
      loss = strtrim(hh[21],2)
      stable = strtrim(hh[22],2)
      spurious = strtrim(hh[176],2)
      printf, 1, 'FG cover A [pixels]: ' + strtrim(long64(im1_2b),2)
      printf, 1, 'FG cover B [pixels]: ' + strtrim(long64(im2_2b),2)
      nc = long64(im2_2b-im1_2b)
      printf, 1, 'Net change [pixels]: ' + strtrim(nc,2)
      printf, 1, '  '
      printf, 1, 'MCD-Loss [pixels]: ' + loss
      printf, 1, 'MCD-Stable [pixels]: ' + stable
      printf, 1, 'MCD-Gain [pixels]: ' + gain
      printf, 1, 'MCD-Spurious [pixels]: ' + spurious
      printf, 1, '  '
      printf, 1, 'Note: Spurious pixels are part of Gain as well as Loss!'
      printf, 1, 'Spurious gain pixels at time B = FG-area at time B - stable - gain '
      sg = im2_2b - hh[22] - hh[12]
      printf, 1, 'Spurious gain B [pixels]: ' + strtrim(long64(sg),2)
      printf, 1, '====================================================='
      fgc = hh[22]+hh[12]+sg
      printf, 1, 'FG-cover B = MCD-Stable + MCD-Gain + MCD-Spurious-Gain [pixels]: ' 
      printf, 1, strtrim(long64(fgc),2) + ' = ' +  stable + ' + ' + gain + ' + ' + strtrim(long64(sg),2) 
      
      close, 1
      xdisplayfile, info.dir_tmp + 'mcd.txt', title = 'MCD statistics', done_button = 'Close'
      
      goto, diffsim_finish
   
      ;; b) not having equal area or are not geotiff 
      ;;===========================================================
      diffsim_nogeo:
      s1 = size(im1) & s2 = size(im2)
      xcom = s1[1] < s2[1] & ycom = s1[2] < s2[2] & datcom = s1[3] > s2[3]
      if datcom gt 1 then begin
        res = dialog_message('Both images must be of type Byte' + string(10b) + 'Returning...', / information)
        GOTO, fin
      endif
      im1 = im1[0:xcom-1,0:ycom-1] & im2 = im2[0:xcom-1,0:ycom-1]

      
      diffsimgeo:
      ;; set land to be land in either image
      land = (im1 gt 0b) * (im2 gt 0b) ;; land = 1b

      ;; area in common at time A and B
      im1_2b = total(im1 eq 2b,/double)
      im2_2b = total(im2 eq 2b,/double)

      ;; reset both fmaps to the area of land in common
      im1 = temporary(im1) * land & im2 = temporary(im2) * land
      qmiss = where(im1 eq 0b or im2 eq 0b,ct_qmiss, /l64)
      
      diffsim = (im1 eq 1b) * (im2 eq 1b)*11b ;; 11 - stable nonforest
      tmp = (im1 eq 2b) * (im2 lt 2b)*21b ;; 21 - forest loss
      diffsim = temporary(diffsim) + temporary(tmp) 
      tmp = (im1 eq 2b) * (im2 eq 2b)*22b  ;; 22 - stable forest
      diffsim = temporary(diffsim) + temporary(tmp) 
      tmp = (im1 lt 2b) * (im2 eq 2b)*12b ;; 12 - forest gain
      diffsim = temporary(diffsim) + temporary(tmp) * temporary(land) 
      if ct_qmiss gt 0 then diffsim[qmiss] = 255b & qmiss=0
      im1 = 0 & im2 = 0      
      info.title = 'Simple change (A->B)' 
      
      ;; do statistics
      openw, 1, info.dir_tmp + 'sd.txt'
      printf, 1, info.title
      ;; get change SD stats
      hh = histogram(diffsim)
      gain = strtrim(hh[12],2)
      loss = strtrim(hh[21],2)
      stable = strtrim(hh[22],2)
      printf, 1, 'FG area A [pixels]: ' + strtrim(long64(im1_2b),2)
      printf, 1, 'FG area B [pixels]: ' + strtrim(long64(im2_2b),2)
      nc = long64(im2_2b-im1_2b)
      printf, 1, 'Net change [pixels]: ' + strtrim(nc,2)
      printf, 1, '  '
      printf, 1, 'Loss [pixels]: ' + loss
      printf, 1, 'Stable [pixels]: ' + stable
      printf, 1, 'Gain [pixels]: ' + gain
      printf, 1, '====================================================='
      fgc = hh[22]+hh[12]
      printf, 1, 'FG-cover B = Stable + Gain [pixels]: '      
      printf, 1, strtrim(long64(fgc),2) + ' = ' + stable + ' + ' + gain    
      close, 1
      xdisplayfile, info.dir_tmp + 'sd.txt', title = 'Simple change statistics', done_button = 'Close'
 
      diffsim_finish:
      
      ;; if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
        info.selsubregion_id = 0
        ;; deactivate zoomfactor selector
        widget_control, info.w_zoomfac, sensitive = 1
        widget_control, info.w_selsubregion, set_value = 'Zoom Mode'
        ;; restore the prezoomed process image
        * info.process = * info.prezoomprocess
        ;; disable button and enable motion events in w_draw
        widget_control, info.w_draw, Draw_Motion_Events = 1
        widget_control, info.w_draw, Draw_Button_Events = 0
        info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF  
      
      s = size(diffsim)    
      ;; max-display on screen, keep the rescale factor as integer
      xf = fix((float(s(1)) / info.screen_size(0) * 1.4) * 10) / 10.0
      yf = fix((float(s(2)) / info.screen_size(1) * 1.4) * 10) / 10.0
      info.resfac = ceil(xf > yf) > 1
      info.bigim = info.resfac GT 1
     
      * info.process = temporary(rotate(diffsim,7))
      * info.fr_image = * info.process

      IF info.bigim THEN BEGIN
        * info.image0 = $
          congrid( * info.fr_image, s(1) / info.resfac, s(2) / info.resfac)
        s = size( * info.image0)
      ENDIF ELSE * info.image0 = * info.fr_image
     
      info.xsize = s(1) & info.ysize = s(2)

      info.is_mspa = 0 & info.is_fragm = 0 & info.is_contort = 0 & info.is_dist = 0 & info.is_influ = 0
      info.is_cs22 = 0 & info.is_nw = 0 & info.is_cost = 0
      info.add_title = ''  
      
      if eventValue2 eq 'change_simple' or eventValue2 eq 'change_morph' then begin
        restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b
        info.ctbl = - 1 & info.autostretch_id = 0 & info.disp_colors_id = 3 ;; classification
      endif      
     
   END
   
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   'delta_lm':  BEGIN
     ;; build simple difference of two heatmaps A and B
     ;;
     ;; read heatmap A and B
     ;;=========================================================================================
     fnsav_a = dialog_pickfile(Title = 'Change LM: heatmap A: ', get_path = path2file, path = info.dir_data, $
       default_extension = 'sav', / fix_filter, / must_exist, filter = ['*_heatmap.sav'])
     IF strlen(fnsav_a) eq 0 THEN GOTO, fin ;; 'cancel' selected

     fnsav_b = dialog_pickfile(Title = 'Change LM: heatmap B: ', get_path = path2file, path = info.dir_data, $
       default_extension = 'sav', / fix_filter, / must_exist, filter = ['*_heatmap.sav'])
     IF strlen(fnsav_b) eq 0 THEN GOTO, fin ;; 'cancel' selected
     
     if fnsav_a eq fnsav_b then begin
       msg = 'The heatmap files of A and B must be different.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin      
     endif
     
     restore, fnsav_a 
     ;; make sure we have the right stuff in this sav-file
     if n_elements(hmap) eq 0 then begin
       msg = 'The heatmap file:' + string(10b) + fnsav_a + string(10b) + 'has no valid heatmap information.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin     
     endif
     kdim_str_a = kdim_str & hn_a = hn & hmap_a = hmap
         
     restore, fnsav_b
     if n_elements(hmap) eq 0 then begin
       msg = 'The heatmap file:' + string(10b) + fnsav_b + string(10b) + 'has no valid heatmap information.' + string(10b) + string(10b) + 'Returning...'
       res = dialog_message(msg, / information)
       GOTO, fin     
     endif
     kdim_str_b = kdim_str & hn_b = hn & hmap_b = hmap
    
     ;; compare heatmaps A and B
     hn = hn_b -hn_a  ;; the difference from A to B
     hmax = max(hn[1:*]) & hmin = min(hn[1:*]) & eps = 0.000005 & cl_neg = 19 ;; the color for negative changes
     
     ;; get current colors
     tvlct, r_curr, g_curr, b_curr, / get
     
     ;; load the LM-colors, define symbol and stuff     
     restore, info.dir_guidossub + 'lmcolors.sav' & tvlct, r, g, b        
     a = FINDGEN(49) * (!PI*2/48.) & USERSYM, COS(A), SIN(A), /FILL ;; a circle use symsize=8
     tri = read_png(info.dir_guidossub + 'triangle.png') & sz = size(tri,/dim)
     window, 11, xsize=sz[1], ysize=sz[2], /pixmap, retain=2 & tv, tri, /true

     ;; row 1
     y1 = 225 & y2 = 270
     subt = hn[191] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 280,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 280,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 280,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[192] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 355,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 355,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 355,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[71] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 425,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 425,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 425,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[72] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 495,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 495,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 495,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device       
     subt = hn[73] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 570,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 570,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 570,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[74] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 640,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 640,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 640,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device       
     subt = hn[75] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 710,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 710,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 710,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[131] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 785,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 785,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 785,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device       
     subt = hn[132] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 855,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 855,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 855,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[133] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 927,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 927,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 927,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[134] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1000,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1000,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1000,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[135] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1070,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1070,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1070,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device       
     subt = hn[45] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1142,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1142,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1142,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[44] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1215,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1215,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1215,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[43] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1285,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1285,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1285,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[42] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1355,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1355,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1355,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device       
     subt = hn[41] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1425,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1425,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1425,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[182] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1500,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1500,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1500,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[181] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1570,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1570,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1570,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device

     ;; row 2
     y1 = 350 & y2 = 395
     subt = hn[61] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 355,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 355,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 355,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device    
     subt = hn[62] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 425,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 425,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 425,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[111] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 495,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 495,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 495,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[112] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 570,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 570,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 570,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[114] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 640,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 640,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 640,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[200] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 710,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 710,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 710,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[201] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 785,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 785,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 785,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[202] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 855,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 855,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 855,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device       
     subt = hn[203] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 927,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 927,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 927,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[204] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1000,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1000,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1000,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[205] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1070,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1070,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1070,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[206] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1142,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1142,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1142,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[103] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1215,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1215,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1215,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device       
     subt = hn[102] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1285,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1285,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1285,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[101] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1355,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1355,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1355,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device       
     subt = hn[52] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1425,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1425,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1425,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[51] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1500,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1500,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1500,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device 

     ;; row 3
     y1 = 475 & y2 = 520
     subt = hn[63] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 427,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 427,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 427,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[64] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 495,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 495,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 495,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[113] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 570,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 570,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 570,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[222] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 640,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 640,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 640,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[223] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 710,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 710,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 710,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[224] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 785,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 785,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 785,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[225] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 855,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 855,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 855,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[226] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 927,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 927,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 927,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[227] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1000,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1000,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1000,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[228] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1070,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1070,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1070,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[207] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1142,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1142,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1142,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[208] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1215,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1215,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1215,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[104] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1285,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1285,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1285,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device       
     subt = hn[54] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1355,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1355,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1355,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[53] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1425,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1425,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1425,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device

     ;; row 4   delta:   125
     y1 = 600 & y2 = 645
     subt = hn[65] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 495,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 495,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 495,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[155] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 570,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 570,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 570,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[221] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 640,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 640,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 640,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[220] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 710,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 710,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 710,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[235] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 785,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 785,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 785,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[234] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 855,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 855,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 855,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[236] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 927,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 927,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 927,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[230] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1000,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1000,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1000,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[229] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1070,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1070,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1070,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[210] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1142,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1142,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1142,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[209] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1215,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1215,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1215,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[141] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1285,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1285,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1285,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[55] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1355,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1355,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1355,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device

     ;; row 5   delta:   125
     y1 = 725 & y2 = 770
     subt = hn[154] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 570,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 570,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 570,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[153] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 640,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 640,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 640,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[219] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 710,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 710,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 710,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[218] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 785,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 785,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 785,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[233] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 855,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 855,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 855,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device       
     subt = hn[232] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 927,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 927,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 927,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[231] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1000,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1000,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1000,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[212] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1070,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1070,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1070,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[211] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1142,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1142,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1142,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[143] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1215,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1215,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1215,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[142] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1285,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1285,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1285,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device

     ;; row 6   delta:   125
     y1 = 850 & y2 = 895
     subt = hn[152] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 640,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 640,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 640,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[151] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 710,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 710,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 710,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[217] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 785,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 785,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 785,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[216] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 855,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 855,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 855,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[215] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 927,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 927,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 927,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[214] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1000,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1000,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1000,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[213] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1070,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1070,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1070,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[145] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1142,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1142,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1142,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[144] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1215,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1215,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1215,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device

     ;; row 7   delta:   125
     y1 = 975 & y2 = 1020
     subt = hn[95] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 710,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 710,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 710,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[94] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 785,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 785,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 785,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[124] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 855,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 855,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 855,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device      
     subt = hn[122] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 927,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 927,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 927,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[123] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1000,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1000,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1000,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[84] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1070,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1070,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1070,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[85] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1142,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1142,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1142,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device

     ;; row 8   delta:   125
     y1 = 1100 & y2 = 1145
     subt = hn[93] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 785,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 785,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 785,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device
     subt = hn[92] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 855,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 855,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 855,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[121] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 927,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 927,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 927,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[82] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1000,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1000,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1000,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device     
     subt = hn[83] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1070,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1070,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1070,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device 

     ;; row 9   delta:   125
     y1 = 1225 & y2 = 1270
     subt = hn[91] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 855,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 855,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 855,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device
     subt = hn[172] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 927,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 927,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 927,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device
     subt = hn[81] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1000,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1000,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1000,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device

     ;; row 10   delta:   125
     y1 = 1350
     subt = hn[171] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 927,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 927,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 927,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device

     ;; the 3 extremes
     y1 = 95 & y2 = 1582
     subt = hn[190] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 87,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 87,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 87,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device
      
     subt = hn[180] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 1742,y1+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 1742,y1, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 1742,y1, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device
     
     subt = hn[170] & cl = (subt eq hmax) or (subt eq hmin) & cl_circ = cl*20 & cl_nr = (1-cl)*20
     plots, 925,y2+8, PSYM = 8, symsize=7, color=cl_circ, /device & t = round(subt)
     if subt ge 0.0 then xyouts, 925,y2, strtrim(t,2), charsize=3, charthick=3, color=cl_nr, alignment=0.5, /device else $
      xyouts, 925,y2, strtrim(abs(t),2), charsize=3, charthick=3, color=cl_neg, alignment=0.5, /device        

     wset,11 & res = tvrd(/true) & wdelete, 11
     write_png, info.dir_tmp + 'delta_heatmap.png', res
     
     ;; restore current colors
     tvlct, r_curr, g_curr, b_curr


     ;; write csv output
     ;;==============================================
     hns = round(hn*1000)/1000.0 & dot = strpos(hns,'.') & hnss = strarr(n_elements(hns))
     for i = 0, n_elements(hns)-1 do hnss[i] = strmid(hns[i],0,dot[i]+4)

     openw,12, info.dir_tmp + 'delta_heatmap.csv'
     printf,12, 'Delta Landscape Mosaic: B(Window size: ' + kdim_str_b + ') - A(Window size: ' + kdim_str_a + ')'+ ', , , , , , , , , , , , , , , , , , , , ,'
     printf,12, ', , , , , , , , , , ,' +hnss[170]+ ', , , , , , , , , ,'
     printf,12, ', , , , , , , , , , ,'+hnss[171]+ ', , , , , , , , , ,'
     printf,12, ', , , , , , , , , ,'+hnss[91]+','+hnss[172]+','+hnss[81]+', , , , , , , , ,'
     printf,12, ', , , , , , , , ,'+hnss[93]+','+hnss[92]+','+hnss[121]+','+hnss[82]+','+hnss[83]+', , , , , , , ,'
     printf,12, ', , , , , , , ,'+hnss[95]+','+hnss[94]+','+hnss[124]+','+hnss[122]+','+hnss[123]+','+hnss[84]+','+hnss[85]+', , , , , , ,'
     printf,12, ', , , , , , ,'+hnss[152]+','+hnss[151]+','+hnss[217]+','+hnss[216]+','+hnss[215]+','+hnss[214]+','+$
       hnss[213]+','+hnss[145]+','+hnss[144]+', , , , , ,'
     printf,12, ', , , , , ,'+hnss[154]+','+hnss[153]+','+hnss[219]+','+hnss[218]+','+hnss[233]+','+hnss[232]+','+$
       hnss[231]+','+hnss[212]+','+hnss[211]+','+hnss[143]+','+hnss[142]+', , , , ,'
     printf,12, ', , , , ,'+hnss[65]+','+hnss[155]+','+hnss[221]+','+hnss[220]+','+hnss[235]+','+hnss[234]+','+hnss[236]+','+$
       hnss[230]+','+hnss[229]+','+hnss[210]+','+hnss[209]+','+hnss[141]+','+hnss[55]+ ', , , ,'
     printf,12, ', , , ,'+hnss[63]+','+hnss[64]+','+hnss[113]+','+hnss[222]+','+hnss[223]+','+hnss[224]+','+hnss[225]+','+$
       hnss[226]+','+hnss[227]+','+hnss[228]+','+hnss[207]+','+hnss[208]+','+hnss[104]+','+hnss[54]+','+hnss[53]+', , ,'
     printf,12, ', , ,'+hnss[61]+','+hnss[62]+','+hnss[111]+','+hnss[112]+','+hnss[114]+','+hnss[200]+','+hnss[201]+','+$
       hnss[202]+','+hnss[203]+','+hnss[204]+','+hnss[205]+','+hnss[206]+','+hnss[103]+','+hnss[102]+','+$
       hnss[101]+','+hnss[52]+','+hnss[51]+', ,'
     printf,12, ', ,'+hnss[191]+','+hnss[192]+','+hnss[71]+','+hnss[72]+','+hnss[73]+','+hnss[74]+','+hnss[75]+','+$
       hnss[131]+','+hnss[132]+','+hnss[133]+','+hnss[134]+','+hnss[135]+','+hnss[45]+','+hnss[44]+','+$
       hnss[43]+','+hnss[42]+','+hnss[41]+','+hnss[182]+','+hnss[181]+','
     printf,12, ','+hnss[190]+', , , , , , , , , , , , , , , , , , , ,'+hnss[180]
     close,12
     
     ;; open heatmap image
     IF info.my_os EQ 'apple' THEN BEGIN
       spawn, 'open ' + info.dir_tmp + 'delta_heatmap.png'
     ENDIF ELSE IF info.my_os EQ 'windows' THEN BEGIN
       pushd, info.dir_tmp
       spawn, 'start delta_heatmap.png', / nowait
       popd
     ENDIF ELSE BEGIN ;; Linux
       IF strlen(info.xdgop) EQ 0 THEN BEGIN
         st = "Please install xdg-open to automatically" + $
           "display images within GuidosToolbox."
         result = dialog_message(st, / information)
       ENDIF ELSE BEGIN
         spawn, info.xdgop + ' "' + info.dir_tmp + 'delta_heatmap.png' + '"'
       ENDELSE
     ENDELSE 
     
     ;; save results to data and inform
     file_copy, info.dir_tmp + 'delta_heatmap.png', info.dir_data + 'delta_heatmap.png',/overwrite
     file_copy, info.dir_tmp + 'delta_heatmap.csv', info.dir_data + 'delta_heatmap.csv',/overwrite
     
     msg = "The following LM heatmap change results were saved:" + string(10b) + $
       info.dir_data + 'delta_heatmap.png' + string(10b) + info.dir_data + 'delta_heatmap.csv' + string(10b) + string(10b) + $
       'Please rename these files to avoid them being overwritten in a future LM-change analysis.' + string(10b) + 'Returning...'
     res = dialog_message(msg, / information)    

   END
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;        C O N T O R T I O N
   ;;  always done with 8-connectivity, else we have even more objects...
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   'contortion':  BEGIN
      ;; 1) if in zoom mode, quit zoom mode
      IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
        info.selsubregion_id = 0
        ;; deactivate zoomfactor selector
        widget_control, info.w_zoomfac, sensitive = 1
        widget_control, info.w_selsubregion, $
          set_value = 'Zoom Mode'
        ;; restore the prezoomed process image
        * info.process = * info.prezoomprocess
        ;; disable button and enable motion events in w_draw
        widget_control, info.w_draw, Draw_Motion_Events = 1
        widget_control, info.w_draw, Draw_Button_Events = 0
        info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
      ENDIF
      
      ;; check for contortion
      if info.is_contort GT 0 then begin
       ;; restore contortion image
       restore, filename = info.dir_guidossub + 'contorttmp.sav' ;; restore images
       
       ;; check old object size, if it has changed then reset contortion to original image
       if fix(info.mspa_size_current) ne small_lt_contort then begin
         msg='Object size limit changed.' + string(10b) + $
           'Recalculating contortion of original image' + string(10b) + $
           'using the new size limit.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         * info.contort = 0 & contort1=0 
         do_contort = 1
         goto, set2original
       endif
       
       ;; check which contortion type was selected
       qq=strmid(eventValue2,10,1)
       ;; uncheck label
       info.do_label_groups_id = 0

        case qq of
          ;; normal contortion
          '1':begin
             tt = bytscl(contort1, Min=2, Top=252) + 3b
             ;; add back data array of missing, BG (-1, 0, 1): assign to 0,1,2
             mask=where(contort1 lt 2l, /l64) & tt(mask)=byte(contort1(mask)+1l)
             * info.process = temporary(tt)
             * info.contort = temporary(contort1) & mask=0
             info.add_title = ' (Contortion, obj with core >= ' + info.mspa_size_current + $
               ' pixels: ' + objlstr + '/' + obj_laststr + ' objects)'
             info.is_contort = 1
          end
        endcase
        goto, endcontort
      endif
   
      contort_cont:
      ;; 2) check for input compliance:
      MSPA_Compliance, info.fname_input, * info.fr_image, info.immaxsize, 1, result
      IF result EQ 0 THEN GOTO, fin  ;; invalid input

      ;; constrain to maximum of 5000 x 5000
      ;;===============================     
      ;; we must process the full resolution image
      image0 = (* info.fr_image eq 2b) ;use only FG=2b 
      sz = size(image0,/dim) & fsz = float(sz[0])*sz[1] & mxfsz=25000100
      IF fsz GT mxfsz THEN BEGIN
        msg = "Exceeded maximum image dimensions for contortion: 5000x5000" + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
      ENDIF
 
      ;; reset mspa
      info.is_mspa = 0 & info.mspa_stats_show = 0b & info.is_fragm = 0 & info.is_dist = 0 & info.is_influ = 0
      info.do_mspa_stats_id = 0 & info.is_cs22 = 0 & info.is_nw = 0 & info.is_cost = 0
      ;; enforce 8-connectivity for the FG 
      info.mspa_param1_id = 1
      widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id

      ;; test if size was never changed then set to default
      if info.small_lt_old eq -1 then begin
        info.mspa_size_old = '1' & info.mspa_size_current = '1000' ;; was '200' before
        widget_control, info.w_mspa_param2, set_value = ['1000','1','2','3','4','5','6','7','8','9','10']
        widget_control, info.w_mspa_param2, set_combobox_select = 0  
      endif
      small_lt = ulong64(info.mspa_size_current) & info.small_lt_old = small_lt
      ;; this one will go in the sav-file to be rechecked if other contortion options are selected
      small_lt_contort = small_lt 

      ;; label map for the foreground pixels
      sz = size(image0,/dim) & ext1 = lonarr(sz(0) + 2, sz(1) + 2) & sz2=size(ext1,/dim)
      ext1[1:sz(0), 1:sz(1)] = long(temporary(image0)) & all_n = 1 ;8-connectivity
      ;; label full FG only
      allobjects = label_region(ext1, all_neighbors=all_n, / ulong) 
      ;; object area of each FG full object: obj_area
      obj_area = histogram(allobjects, reverse_indices = revind, / l64) & objtot = n_elements(obj_area)-1
      ;; we constrain the contortion analysis to objects having a core area
      s = replicate(1b, 3, 3) & core_objects = erode(allobjects,s)*allobjects & allobjects = 0
      ;; get core_object IDs
      core_ids = where(histogram(core_objects) gt 0,ct) & core_objects = 0
      IF ct LT 2 THEN BEGIN
        ;; no core objects available so no Contortion
        msg = "Objects are too small for Contortion" + string(10b) + $
         'Try reducing the object size via the EdgeWidth parameter' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin       
      ENDIF
      obj_last=n_elements(core_ids)-1 ;; because first entry is background   
      
      ;; re-assign ext1 to output data range:
      ;; -1 missing, 0 BG, 1 FG
      ;; single points and lines have contortion = 2 because a point or a line  
      ;; is technically a rectangle
      ;; objects with an extended area can have a contortion of 2 or more
      ext1[1:sz(0), 1:sz(1)] = long(* info.fr_image) - 1l   
      ;;ext2=float(ext1) ;& ext3=ext2  ;; ext1/2/3 = contort1/2/3
      objl=0l ;; counter for processed objects & lines
      time0 = systime( / sec)
      
      widget_control, / hourglass
      tit="Contortion of FG objects"
      progressBar = Obj_New("SHOWPROGRESS", xsize=300, title=tit)
      progressBar -> Start

      FOR il = 1l, obj_last DO BEGIN
        cc = core_ids[il]
        ;; area indices of object A
        indices = revind[revind[cc]:revind[cc+1]-1] & area=obj_area(cc) ;; area=float(obj_area(cc))
        
        ;; 1) skip neglected objects
        IF area LT small_lt THEN goto, skipcort 
        
        ;; skip objects not having a core area

        ;; 2) normal case of extended objects
        ;;======================================= 
        ;; x/y-coord of boundary of object A
        b = Find_Boundary(indices, XSize=sz2(0), YSize=sz2(1)) 
        ;perimlength=float(n_elements(b(0,*))+1)
              
        ;; normal cases       
        xb = [reform(b[0,*]),b[0,0],b[0,1]] & yb = [reform(b[1,*]),b[1,0],b[1,1]] & q = n_elements(xb)-1
        dxb = intarr(q) & dyb = dxb ;; stepwise difference
        ;; old way
        ;; for idx = 0l,q-1 do dxb(idx) = xb[idx+1]-xb[idx]
        ;; for idx = 0l,q-1 do dyb(idx) = yb[idx+1]-yb[idx]       
        dxb = fix((shift(xb,-1)-xb)[0:q-1]) & dyb = fix((shift(yb,-1)-yb)[0:q-1])
        ;;test
        ;; add nonzeros before and after the sequence in order to catch the entire valid sequence        
        dxb = [5,dxb,6] & dyb = [5,dyb,6]
        ;; remove zeroes which are not of interest for the directional changes
        q=where(dxb eq 0,ct,complement=complement) & dxb=dxb(complement)
        q=where(dyb eq 0,ct,complement=complement) & dyb=dyb(complement)
        ;; get uniq presence of 1 and -1
        dxb = dxb(uniq(dxb)) & dyb = dyb(uniq(dyb))
        ;; dxb/dyb has each 2 elements too much (5 and 6), remove them from the counting
        ;; as we only need the values 1 and -1. From the sum we need to remove another 3 counters
        ;; so we get only the niumber of the directional changes in x/y
        contortion = (n_elements(dxb) + n_elements(dyb) - 7) > 2
        
;        u_dxb = dxb(uniq(dxb)) & u_dyb = dyb(uniq(dyb)) ;& print,u_dxb,u_dyb
;        ;; remove zeros
;        q=where(u_dxb eq 0,ct,complement=complement) & u_dxb=u_dxb(complement)
;        q=where(u_dyb eq 0,ct,complement=complement) & u_dyb=u_dyb(complement)
;        ;; do the same again
;        u_dxb = [0,u_dxb,0] & u_dyb=[0,u_dyb,0]
;        u_dxb = u_dxb(uniq(u_dxb)) & u_dyb = u_dyb(uniq(u_dyb))
;        ;; remove zeros
;        q=where(u_dxb eq 0,ct,complement=complement) & u_dxb=u_dxb(complement)
;        q=where(u_dyb eq 0,ct,complement=complement) & u_dyb=u_dyb(complement)
;        contortion = n_elements(u_dxb) + n_elements(u_dyb) - 2l
               
        skipcort0:
        ext1(indices) = contortion 
        objl=objl+1l
        
        skipcort:
        zz = round((il+1)*100/obj_last)
        progressBar->Update, zz & wait,0.000001
      ENDFOR ; end loop over objects
 
      progressBar -> Destroy
      Obj_Destroy, progressBar
      print, 'Contortion comp.time [sec]: ', systime( / sec) - time0

      ;; go back to original size
      contort1 = temporary(ext1[1:sz(0), 1:sz(1)])
      objlstr=strtrim(objl,2) & obj_laststr=strtrim(objtot,2)
      
      ;; for the GUI-display re-scale the actual data-array (contort1) 
      ;; into colorbyte array (tt) to be displayed in Guidos
      ;; the data array(contort1) has: 
      ;; -1 missing, 0 BG, 1 neglected objects, 2-> x contortion of objects with real area
      ;; actual contortion values start from 2 to whatever.
      ;;
      ;; the image doisplay array (tt):
      ;; consider minimum contortion data value of 2 (maximum data value is max) 
      ;; and set maximum byt-value for rescale to 252
      ;; bytscl will then rescale this range into [0, 252] byte 
      ;; then shift this range by 3 byte to obtain [3-255] byte
      tt = bytscl(contort1, Min=2, Top=252) + 3b  
      ;; add back data array of missing, BG (-1, 0, 1): assign to 0,1,2
      mask=where(contort1 lt 2l) & tt(mask)=byte(contort1(mask)+1l)
      ;; now we have the complete range of [0, 255]
      * info.process = temporary(tt)
      
      info.add_title = ' (Contortion, objects with core >= ' + info.mspa_size_current + $
        ' pixels: ' + objlstr + '/' + obj_laststr + ' objects)' 
      info.is_contort = 1
      
      ;; save the actual contortion data and assign to info structure to be read out
      save, contort1,small_lt_contort, objlstr, obj_laststr, filename = info.dir_guidossub + 'contorttmp.sav'
      * info.contort = temporary(contort1) 

      endcontort:
      * info.fr_image = * info.process
      widget_control, info.w_labelstr, set_value = 'Contortion range: '
      widget_control, info.w_label_t1, set_value = ['X','25','50','100']
      widget_control, info.w_label_t2, set_value = ['X','300','800','2000']
      widget_control, info.w_label_t1, set_combobox_select = 1 & info.label_t1 = 25
      widget_control, info.w_label_t2, set_combobox_select = 1 & info.label_t2 = 300

      ;; uncheck label
      info.do_label_groups_id = 0
      widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id

      ;; restore the contortion color table
      restore, info.dir_guidossub + 'contcolors.sav' & tvlct, r, g, b
      info.ctbl = - 1 & info.disp_colors_id = 6 & info.autostretch_id = 0

   END

;;-----------------------------------------------------------------------
;;---------------  help menu --------------------------------------------
;;-----------------------------------------------------------------------
   'guidos_manual':  BEGIN
      IF info.my_os EQ 'apple' THEN BEGIN
         spawn, 'open ' + info.dir_guidos + 'GuidosToolbox_Manual.pdf'
         GOTO, fin
      ENDIF

      widget_control, / hourglass
      IF info.my_os EQ 'windows' THEN BEGIN
        pushd, info.dir_guidos
        spawn, 'start GuidosToolbox_Manual.pdf', / nowait
        popd
        GOTO, fin
      ENDIF ELSE BEGIN ;; Linux
        cmd = info.acroread_exe + ' "' + info.dir_guidos + 'GuidosToolbox_Manual.pdf' + '"'
        spawn, cmd + ' &'
        GOTO, fin
      ENDELSE
   END

   ;;*****************************************************************************************************

   'mspa_guide':  BEGIN
      IF info.my_os EQ 'apple' THEN BEGIN
         spawn, 'open ' + info.dir_guidos + 'MSPAstandalone/MSPA_Guide.pdf'
         GOTO, fin
      ENDIF

      widget_control, / hourglass
      IF info.my_os EQ 'windows' THEN BEGIN
        pushd, info.dir_guidos + 'MSPAstandalone'
        spawn, 'start MSPA_Guide.pdf', / nowait
        popd
        GOTO, fin
      ENDIF ELSE BEGIN ;; Linux
        cmd = info.acroread_exe + ' "' + info.dir_guidos + 'MSPAstandalone/MSPA_Guide.pdf' + '"'
        spawn, cmd + ' &'
        GOTO, fin
      ENDELSE
   END


   ;;*****************************************************************************************************

   'news':  BEGIN    
     ;; the local resulting file
     version_file = info.dir_tmp + 'news'
     ;; delete the file if any was present
     file_delete, version_file, / quiet
     widget_control, / hourglass

     ;; If the url object throws an error it will be caught here
     CATCH, errorStatus
     IF (errorStatus NE 0) THEN BEGIN
       CATCH, / CANCEL
       goto, url_cont88
     ENDIF

     oUrl = OBJ_NEW('IDLnetUrl')
     oUrl -> SetProperty, URL_SCHEME = 'https'
     oUrl -> SetProperty, PROXY_HOSTNAME = info.proxhost
     oUrl -> SetProperty, PROXY_PORT = info.proxport
     oUrl -> SetProperty, URL_HOST = 'forest.jrc.ec.europa.eu'
     oUrl -> SetProperty, URL_PATH = 'guidos/news'
     fn = oUrl -> Get(FILENAME = version_file)
     url_cont88:
     OBJ_DESTROY, oUrl

     ;; check if the file exists and what it contains
     res = file_info(version_file)
         
     IF res.exists EQ 1b THEN BEGIN
        xdisplayfile, version_file, $
         title = 'GuidosToolbox: Latest News...', done_button = 'Close', / block, / modal, group = event.top
     ENDIF ELSE BEGIN  ;; inform that there was no internet
        str = 'An internet connection is required to check' + $
          string(10b) + 'for GuidosToolbox News.'
        res = dialog_message(title = 'GuidosToolbox: Latest News...', / information, str)
     ENDELSE
     GOTO, fin
   END

   ;;*****************************************************************************************************

   'productsheets':  BEGIN
     webl = ' https://forest.jrc.ec.europa.eu/activities/lpa/gtb/#Productsheets'
     IF info.my_os EQ 'apple' THEN BEGIN
       spawn, 'open' + webl
     ENDIF ELSE IF info.my_os EQ 'windows' THEN BEGIN
       spawn, 'start' + webl,/hide
     ENDIF ELSE BEGIN
       IF strlen(info.html_exe) EQ 0 THEN BEGIN
         st = "No html-browser found. Please install one" + $
           string(10b) + "then open the website:" + $
           string(10b) + "https://forest.jrc.ec.europa.eu/activities/lpa/gtb/#Productsheets"
         result = dialog_message(st, / information)
       ENDIF ELSE BEGIN
         cmd = 'unset LD_LIBRARY_PATH; ' + info.html_exe + webl
         spawn, cmd + ' &'
       ENDELSE
     ENDELSE
     GOTO, fin
   END


   ;;*****************************************************************************************************

   'homepage':  BEGIN     
      case eventvalue2 OF
        'homepage_gtb': webl = ' https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
        'homepage_gwb': webl = ' https://forest.jrc.ec.europa.eu/activities/lpa/gwb/'
        'homepage_itb': webl = ' https://forobs.jrc.ec.europa.eu/products/software/impact.php'
        'homepage_gis': webl = ' https://docs.qgis.org/latest/en/docs/gentle_gis_introduction/'
        'homepage_crs': webl = ' https://www.nrcan.gc.ca/node/9309'
        'homepage_gda': webl = ' https://gdal.org'
        'homepage_cfr': webl = ' http://conefor.org'
        'homepage_opf': webl = ' http://www.openforis.org'
        'homepage_spl': webl = ' https://sepal.io'
        'homepage_atl': webl = ' https://forest.jrc.ec.europa.eu/european-atlas/'        
        ELSE: GOTO, fin
      ENDCASE
      
      IF info.my_os EQ 'apple' THEN BEGIN
         spawn, 'open' + webl
      ENDIF ELSE IF info.my_os EQ 'windows' THEN BEGIN
        spawn, 'start' + webl,/hide
      ENDIF ELSE BEGIN
        IF strlen(info.html_exe) EQ 0 THEN BEGIN
           st = "No web-browser found. Please install one" 
           result = dialog_message(st, / information)
        ENDIF ELSE BEGIN
           cmd = 'unset LD_LIBRARY_PATH; ' + info.html_exe + webl
           spawn, cmd + ' &'
        ENDELSE
      ENDELSE
      GOTO, fin
   END

   ;;*****************************************************************************************************

   'gt_changelog':  BEGIN
      xdisplayfile, info.dir_guidos + 'changelog.txt', title = 'GuidosToolbox changelog: ', $
        done_button = 'Close', / block, / modal, group = event.top
      GOTO, fin
   END

   ;;*****************************************************************************************************

   'gt_eula':  BEGIN
     IF info.my_os EQ 'apple' THEN BEGIN
       spawn, 'open ' + info.dir_guidos + '../../../../../EULA_GTB.pdf'
       GOTO, fin
     ENDIF

     widget_control, / hourglass
     IF info.my_os EQ 'windows' THEN BEGIN
       pushd, info.dir_guidos 
       spawn, 'start EULA_GTB.pdf', / nowait
       popd
       GOTO, fin
     ENDIF ELSE BEGIN ;; Linux
       IF info.isBDAP THEN cmd = info.acroread_exe + ' "' + info.dir_guidos + 'EULA_GTB.pdf' + '"' ELSE $
        cmd = info.acroread_exe + ' "' + info.dir_guidos + '../../EULA_GTB.pdf' + '"'
       spawn, cmd + ' &'
       GOTO, fin
     ENDELSE
   END

   ;;*****************************************************************************************************

   'check4updates':  BEGIN
      ;; setup and delete the version file
      ;;compare the current version with the one available on the homepage
      v_curr = info.gtb_version & vbase_curr = strmid(strtrim(v_curr,2),0,3)
      v_curr = fix(round(v_curr*1000))
      
      ;; the local resulting file
      version_file = info.dir_guidossub + 'version.txt'
      ;; delete the file if any was present
      file_delete, version_file, / quiet
      widget_control, / hourglass

      ;; If the url object throws an error it will be caught here
      CATCH, errorStatus
      IF (errorStatus NE 0) THEN BEGIN
         CATCH, / CANCEL
         goto, url_cont
      ENDIF    

      oUrl = OBJ_NEW('IDLnetUrl')
      oUrl -> SetProperty, URL_SCHEME = 'https'
      oUrl -> SetProperty, PROXY_HOSTNAME = info.proxhost
      oUrl -> SetProperty, PROXY_PORT = info.proxport
      oUrl -> SetProperty, URL_HOST = 'ies-ows.jrc.ec.europa.eu'
      oUrl -> SetProperty, URL_PATH = 'gtb/version.txt'
      fn = oUrl -> Get(FILENAME = version_file)
      url_cont:
      OBJ_DESTROY, oUrl

      ;; check if the file exists and what it contains
      res = file_info(version_file)
      IF res.exists EQ 1b THEN BEGIN
         ;; check that it is small else there was an error to
         ;; retrieve the version info
         IF res.size LT 20 THEN BEGIN ;; all is ok!
            openr, 1, info.dir_guidossub + 'version.txt'
            newv='' & readf, 1, newv & close, 1
            newv_base = strmid(strtrim(newv,2),0,3)
            newvfix = fix(round(float(strmid(strtrim(newv,2),0,5))*1000))
            delta = newvfix - v_curr > 0
            
            
            ;; Workshop version test
            ;;===========================
            if eventvalue2 eq 'installgws' then begin
              fn_gws = info.dir_data + 'GWSversion.txt'
              gws = file_info(fn_gws)
              if gws.exists eq 1b then begin
                GWS_curr = 0.0 & openr, 1, fn_gws & readf, 1, GWS_curr & close, 1
              endif else begin
                GWS_curr = 2015.0
              endelse
              
              GWS_new = float((strsplit(newv,'__',/extract))[1])
              GWS_delta = abs(GWS_new - GWS_curr) gt 0.0001
              
              IF GWS_delta eq 0 THEN BEGIN ;; inform that GWS is uptodate
                str = 'You have the latest GWS material'
                res = dialog_message(title = 'GWS information', $
                  / information, str)
                GOTO, fin
              ENDIF ELSE BEGIN   ;; incremental update available or not installed
                
                str = 'New GWS (GTB Workshop) material available' + string(10b) + $
                  'Do you want to download and install it?'
                res = dialog_message(title = 'GWS information', / question, str)
                IF res EQ 'No' THEN  GOTO, fin
                                
                pushd, info.dir_tmp
                gws_file = info.dir_tmp + 'GWS' + strtrim(gws_new,2)+'.zip'
                gws_archive = file_basename(gws_file)
                gws_archivebase = strmid(gws_archive,0,strpos(gws_archive,'.',/reverse_search))

                ;; If the url object throws an error it will be caught here
                CATCH, errorStatus
                IF (errorStatus NE 0) THEN BEGIN
                  CATCH, / CANCEL
                  goto, url_cont3
                ENDIF
                
                oProgressbar = Obj_New('cgprogressbar', TITLE='Downloading GWS')
                oUrl = OBJ_NEW('IDLnetUrl', URL_SCHEME = 'https', PROXY_HOSTNAME = info.proxhost, PROXY_PORT = info.proxport, $
                  URL_HOSTNAME = 'ies-ows.jrc.ec.europa.eu/gtb/GWS/'+gws_archive,$
                  URL_USERNAME = '', URL_PASSWORD = '', CALLBACK_FUNCTION ='UrlBigFileGetCallbackStatus', $
                  CALLBACK_DATA=oProgressbar)
                VersionFileName = gws_file
                oProgressbar->Start
                retrievedFilePath = oUrl->Get(FILENAME=VersionFileName)
                oUrl->GetProperty, RESPONSE_CODE=RespCode
                oUrl->CloseConnections
                url_cont3:
                OBJ_DESTROY, oUrl
                oProgressbar->Destroy
                                      
                ;; b) extract it and run update
                IF info.isBDAP THEN BEGIN
                  file_mkdir, 'bdap/bdap'
                  file_move, gws_archive, 'bdap/bdap/'
                  cd, 'bdap/bdap/'
                ENDIF

                file_unzip, gws_archive
                IF info.my_os EQ 'windows' THEN BEGIN
                  pushd, gws_archivebase
                  ;; remove the pause line from the batch command-file
                  fn = 'installGWS_Windows.cmd' & flines = strarr(file_lines(fn))
                  openr,1,fn & readf,1,flines & close,1
                  flines2=strmid(flines,0,5) & q=where(flines eq 'pause') & q=q[0]
                  openw,1,fn & for i=0,q-1 do printf,1,flines(i) & close,1
                  spawn, 'installGWS_Windows.cmd', /hide
                ENDIF ELSE IF info.my_os EQ 'apple' THEN BEGIN
                  pushd, gws_archivebase
                  spawn, 'chmod u+x installGWS*'
                  spawn, './installGWS_Mac'
                ENDIF ELSE BEGIN
                  pushd, gws_archivebase
                  spawn, 'chmod u+x installGWS*'
                  spawn, './installGWS_Linux'
                ENDELSE                                        

                ;; c) inform 
                str = 'GWS is now installed and available' + string(10b) + $
                  'in the GuidosToolbox/data folder.'
                res = dialog_message(title = 'GWS information', / information, str)
                popd
                popd
                
                ;; show the website
                webl = ' https://forest.jrc.ec.europa.eu/activities/lpa/gtb-workshops/'
                IF info.my_os EQ 'apple' THEN BEGIN
                  spawn, 'open' + webl
                ENDIF ELSE IF info.my_os EQ 'windows' THEN BEGIN
                  spawn, 'start' + webl,/hide
                ENDIF ELSE BEGIN
                  IF strlen(info.html_exe) EQ 0 THEN BEGIN
                    st = "No html-browser found. Please install one" + $
                      string(10b) + "to go to the workshop page:" + $
                      string(10b) + "https://forest.jrc.ec.europa.eu/activities/lpa/gtb-workshops/"
                    result = dialog_message(st, / information)
                  ENDIF ELSE BEGIN
                    cmd = 'unset LD_LIBRARY_PATH; ' + info.html_exe + webl
                    spawn, cmd + ' &'
                  ENDELSE
                ENDELSE               
                GOTO, fin
              endelse  
            endif

            ;; program version test
            ;;===========================
            fl_curr = float(vbase_curr) & fl_new = float(newv_base) & isnew = (fl_new - fl_curr) gt 0.02
            IF isnew THEN BEGIN
               ;; inform about new Guidos version
               newGTB = 'GuidosToolbox' + strtrim(newv_base,2)
               IF info.my_os EQ 'windows' THEN BEGIN
                 IF (info.sysarch EQ 64) THEN newGTB = newGTB + '_64windows.exe' ELSE newGTB = newGTB + '_32windows.exe'
               ENDIF ELSE BEGIN
                 IF info.my_os eq 'apple' THEN newGTB = newGTB + '_OSX.dmg' ELSE newGTB = newGTB + '_linux.run'
               ENDELSE

               str = 'New release: GuidosToolbox ' + strtrim(newv_base,2) + ' available.' + string(10b) + $
                 'Do you want to download the new release?' + string(10b) + string(10b) + $
                 'Alternative manual installation: ' + string(10b) + $
                 'Download and run the installer: "' + newGTB +'"' 
               res = dialog_message(title = 'GTB update information', / question, str)
               IF res EQ 'No' THEN  GOTO, fin
               
               ;; a) download the file 
               ;;=============================
               IF info.my_os EQ 'windows' THEN downdir = GETENV('userprofile') + '\Downloads\' ELSE downdir = getenv('HOME')+'/Downloads/'
               ;; test if exists and if not then create it
               res = file_info(downdir) & res = res.directory
               if res eq 0 then file_mkdir, downdir
               
               pushd, downdir
               GTB_file = downdir + newGTB
               GTB_archive = file_basename(GTB_file)

               ;; a) the installation help
               CATCH, errorStatus
               IF (errorStatus NE 0) THEN BEGIN
                 CATCH, / CANCEL
                 goto, url_cont8
               ENDIF
               ginst_file = downdir + 'GuidosToolbox_Installation.pdf'
               oUrl = OBJ_NEW('IDLnetUrl')
               oUrl -> SetProperty, URL_SCHEME = 'https'
               oUrl -> SetProperty, PROXY_HOSTNAME = info.proxhost
               oUrl -> SetProperty, PROXY_PORT = info.proxport
               oUrl -> SetProperty, URL_HOST = 'ies-ows.jrc.ec.europa.eu'
               oUrl -> SetProperty, URL_PATH = 'gtb/GTB/GuidosToolbox_Installation.pdf'
               fn = oUrl -> Get(FILENAME = ginst_file)
               url_cont8:
               OBJ_DESTROY, oUrl

               ;; If the url object throws an error it will be caught here
               CATCH, errorStatus
               IF (errorStatus NE 0) THEN BEGIN
                 CATCH, / CANCEL
                 goto, url_cont7
               ENDIF

               oProgressbar = Obj_New('cgprogressbar', TITLE='Downloading new GTB release')
               oUrl = OBJ_NEW('IDLnetUrl', URL_SCHEME = 'https', PROXY_HOSTNAME = info.proxhost, PROXY_PORT = info.proxport, $
                 URL_HOSTNAME = 'ies-ows.jrc.ec.europa.eu/gtb/GTB/'+GTB_archive,$
                 URL_USERNAME = '', URL_PASSWORD = '', CALLBACK_FUNCTION ='UrlBigFileGetCallbackStatus', $
                 CALLBACK_DATA=oProgressbar)
               VersionFileName = GTB_file
               oProgressbar->Start
               retrievedFilePath = oUrl->Get(FILENAME=VersionFileName)
               oUrl->GetProperty, RESPONSE_CODE=RespCode
               oUrl->CloseConnections
               url_cont7:
               OBJ_DESTROY, oUrl
               oProgressbar->Destroy
               
               ;; b) inform about the new release
               str = 'New release ' + newGTB  + string(10b) + $
                 'has been downloaded into the directory: ' + string(10b) + downdir + string(10b) + string(10b) + $
                 'Please read the installation instructions ' + string(10b) + $
                 'before upgrading to the new version.'
               res = dialog_message(title = 'GTB update information', / information, str)
               
               
               ;; c) open the downdir
               pushd, '..'
               IF info.my_os EQ 'apple' THEN BEGIN
                 spawn, 'open Downloads'
               ENDIF ELSE IF info.my_os EQ 'windows' THEN BEGIN
                 basedir=GETENV('userprofile')
                 pushd, basedir & spawn, 'start Downloads', /nowait, /hide & popd
               ENDIF ELSE BEGIN ;; Linux
                 cmd = info.fmanager + ' Downloads' & spawn, cmd + ' &'
               ENDELSE
               popd
               
               ;; d) show the installation instructions
               IF info.my_os EQ 'apple' THEN BEGIN
                 spawn, 'open ' + ginst_file
               ENDIF ELSE IF info.my_os EQ 'windows' THEN BEGIN
                 pushd, downdir & spawn, 'start GuidosToolbox_Installation.pdf', / nowait, /hide & popd
               ENDIF ELSE BEGIN ;; Linux
                 cmd = info.acroread_exe + ' "' + ginst_file + '"'
                 spawn, cmd + ' &'
               ENDELSE

               popd      
             GOTO, fin
                           
            ENDIF ELSE IF delta eq 0 THEN BEGIN ;; inform that Guidos is uptodate
               str = 'You have the latest program version and revision of GuidosToolbox ' + vbase_curr
               res = dialog_message(title = 'GTB update information', $
                             / information, str)
               GOTO, fin
            ENDIF ELSE BEGIN   ;; incremental version update available
               str = 'Revision release available for GuidosToolbox ' + vbase_curr + string(10b) + $
                  'Do you want to download and install the revision release?' + string(10b) + $
                  '(GuidosToolbox will have to be restarted)'
               res = dialog_message(title = 'GTB update information', / question, str)
               IF res EQ 'No' THEN  GOTO, fin

               ;; a) download the file                
               pushd, info.dir_tmp              
               bugfix_file = info.dir_tmp + 'GTB_' + strtrim(newvfix,2)+'.zip'
               bugfix_archive = file_basename(bugfix_file)
               bugfix_archivebase = strmid(bugfix_archive,0,strpos(bugfix_archive,'.',/reverse_search))
               
               ;; If the url object throws an error it will be caught here
               CATCH, errorStatus
               IF (errorStatus NE 0) THEN BEGIN
                 CATCH, / CANCEL
                 goto, url_cont2
               ENDIF
               
               oProgressbar = Obj_New('cgprogressbar', TITLE='Downloading GTB revision release')
               oUrl = OBJ_NEW('IDLnetUrl', PROXY_HOSTNAME = info.proxhost, PROXY_PORT = info.proxport, $
                 URL_SCHEME = 'https', URL_HOSTNAME = 'ies-ows.jrc.ec.europa.eu/gtb/GTB/'+bugfix_archive,$
                 URL_USERNAME = '', URL_PASSWORD = '', CALLBACK_FUNCTION ='UrlBigFileGetCallbackStatus', $
                 CALLBACK_DATA=oProgressbar)
               VersionFileName = bugfix_file
               oProgressbar->Start
               retrievedFilePath = oUrl->Get(FILENAME=VersionFileName)
               oUrl->GetProperty, RESPONSE_CODE=RespCode
               oUrl->CloseConnections
               url_cont2:
               OBJ_DESTROY, oUrl
               oProgressbar->Destroy
                            
               ;; b) extract it and run update
               file_unzip, bugfix_archive
               IF info.my_os EQ 'windows' THEN BEGIN
                 pushd, bugfix_archivebase
                 ;; remove the pause line from the batch command-file
                 fn = 'installGTB_rev_Windows.cmd' & flines = strarr(file_lines(fn))
                 openr,1,fn & readf,1,flines & close,1
                 flines2=strmid(flines,0,5) & q=where(flines eq 'pause') & q=q[0]
                 openw,1,fn & for i=0,q-1 do printf,1,flines(i) & close,1               
                 spawn, 'installGTB_rev_Windows.cmd', /hide
               ENDIF ELSE IF info.my_os EQ 'apple' THEN BEGIN
                 pushd, bugfix_archivebase
                 spawn, 'chmod u+x installGTB*'
                 spawn, './installGTB_rev_Mac' 
               ENDIF ELSE BEGIN
                 pushd, bugfix_archivebase
                 spawn, 'chmod u+x installGTB*'
                 spawn, './installGTB_rev_Linux'                                  
               ENDELSE           
               
               ;; c) inform to restart
               str = 'Revision release for GuidosToolbox ' + vbase_curr + ' is now installed.' + string(10b) + $
                 'We will now exit from GuidosToolbox. Please ' + string(10b) + $
                 'restart GuidosToolbox to use the updated version.'
                res = dialog_message(title = 'GTB update information', / information, str)
               popd
               popd       
               
               ;; clean up tmp
               pushd, info.dir_tmp
               list = file_search() & nl = n_elements(list)
               IF list[0] NE '' THEN FOR i = 0, nl - 1 DO file_delete, list[i], / allow_nonexistent, / quiet, / recursive
               popd

               ;; clean up potential tmp sav-files
               file_delete, info.dir_guidossub + 'contorttmp.sav', / allow_nonexistent, / quiet
               file_delete, info.dir_guidossub + 'fragmtmp.sav', / allow_nonexistent, / quiet

               widget_control, event.top, / destroy
               exit                              
            ENDELSE

         ENDIF ELSE BEGIN  ;; inform that file was not found
            str = 'Version information could not be downloaded.' + string(10b) + $
                  'Please contact Peter.Vogt@ec.europa.eu'
            res = dialog_message(title = 'GTB update information', / information, str)
         ENDELSE
         file_delete, version_file, / quiet  ;; delete the file

      ENDIF ELSE BEGIN  ;; inform that there was no internet
         str = 'An internet connection is required to check' + $
               string(10b) + 'for GTB program or GWS updates.'
         res = dialog_message(title = 'GTB update information', / information, str)
      ENDELSE

      GOTO, fin
   END


   ;;*****************************************************************************************************

   'about':  BEGIN
      v = strtrim(info.gtb_version, 2) & vbase = strmid(v, 0, 3)
      fv = fix(round(float(v)*1000)) & fvb = fix(round(float(vbase)*1000)) & strvrev = strtrim(fv - fvb,2)
      CASE info.my_os OF
         'windows':BEGIN
            gdd = '- OpenEV (http://openev.sourceforge.net)' + string(10b) + $
                  '- GDAL 1.11.3 (https://gdal.org)' 
            IF strlen(info.qgis_exe) GT 0 THEN gdd = gdd + string(10b) + '- QGIS (https://www.qgis.org)'
         END
         'linux':BEGIN
            spawn,'unset LD_LIBRARY_PATH; gdalinfo --version', res & res = res[0]
            res = (strsplit(res,',',/extract))[0]
            gdd = '- ' + res + ' (https://gdal.org)'
            IF strlen(info.qgis_exe) GT 0 THEN BEGIN
              res=''
              gdd = gdd + string(10b) + '- QGIS ' + res + '(https://www.qgis.org)'
            ENDIF
         END
         'apple':BEGIN
            spawn,'/Library/Frameworks/GDAL.framework/Programs/gdalinfo --version', res & res = res[0]
            res = (strsplit(res,',',/extract))[0]
            gdd = '- ' + res + ' (W.Kyngesburye, https://www.kyngchaos.com)'
            IF strlen(info.qgis_exe) GT 0 THEN BEGIN
              q = strpos(info.qgis_exe,'Contents') & plist = strmid(info.qgis_exe,0,q+9) + 'Info.plist'
              cmd = 'echo $(/usr/libexec/PlistBuddy -c "print CFBundleShortVersionString" "' + plist + '")'
              spawn, cmd, res & res = res[0]             
              gdd = gdd + string(10b) + '- QGIS ' + res + ' (https://www.qgis.org)'
            ENDIF
            spawn, 'sw_vers -productVersion', res & res = res[0]
            osd = 'Mac OS X [' + res + ']'
         END
      ENDCASE     
      aa = ', Revision '  + strvrev + ' (' + strtrim(!version.memory_bits,2) + ' bit)'
      
      str_about = '           GTB ' + vbase + aa + string(10b) + $
                  string(10b) + 'Copyright ' + string(169b) + $
                  ' Peter Vogt, EC-JRC, July 2022' + string(10b) + $
                  'GTB is free and open-source software.' + string(10b) + string(10b) + $
                  'On this PC, GTB has access to: ' + string(10b) + $
                  '- mspa (v2.3), ggeo (P.Soille, P.Vogt)' + string(10b) + $
                  '- spatcon, recode (K.Riitters)' + string(10b) + gdd
      ;; add info on image size
      mspamax = '10000' & mbavail = 'N/A'
      if info.my_os eq 'linux' then begin
        ;; find out how much available RAM (MB) we have: free+buffers+cache
        spawn,"free|awk 'FNR == 2 {print $7}'", mbavail & mbavail = float(mbavail[0])/1024 ;; available
        spawn,"free|awk 'FNR == 3 {print $4}'", mbavail2 & mbavail2 = float(mbavail2[0])/1024 ;; swap
        mbavail = mbavail + mbavail2          
        info.immaxsize = uint(mbavail/19) & mspamax = strtrim(long(sqrt(info.immaxsize) * 1000),2)
      endif else if info.my_os eq 'apple' then begin
        spawn, "vm_stat | grep free | awk '{ print $3 }' | sed 's/\.//'",fra & fra=float(fra[0])
        spawn,"vm_stat | grep inactive | awk '{ print $3 }' | sed 's/\.//'", frb & frb=float(frb[0])
        spawn,"vm_stat | grep speculative | awk '{ print $3 }' | sed 's/\.//'", frc & frc=float(frc[0])
        spawn,"vm_stat | grep purgeable | awk '{ print $3 }' | sed 's/\.//'",frd & frd=float(frd[0])
        mbavail = (fra+frb+frc+frd)*4096/1048576
        info.immaxsize = uint(mbavail/19) & mspamax = strtrim(long(sqrt(info.immaxsize) * 1000),2)
      endif 
      str_about = str_about + string(10b) + string(10b) + 'Maximum image dimension [pixels]: ' + string(10b) + $
        '- GTB: 30000 x 30000' + string(10b) + $
        '- Contortion/ConeforInputs: 5000 x 5000' + string(10b) + $
        '- MSPA: ' + mspamax + ' x ' + mspamax + string(10b) + $
        '- For MSPA-processing of larger images please use: ' + string(10b) + $
        '  GWB (GuidosToolbox Workbench), or slow and less ideal:' + string(10b) + $
        '  File -> Batch Process -> Pattern -> ' + string(10b) + $
        '          Morphological -> MSPA Tiling' + string(10b) + string(10b) + $
        'Additional information is available under: ' + string(10b) + $
        '     Help -> GTB Documentation '
      
      ;; define output depending on info panel or for bug reporting
      ;;===============================================================
      if eventValue2 eq 'about_system' then begin
        GTBreport = info.dir_data + 'GTBbugreport.txt'        
        close, 11 & openw, 11, GTBreport
        printf, 11, '==============================================================================='
        printf, 11, '                             GTB bug report: '
        printf, 11, '==============================================================================='
        printf, 11, 'Please complete and send this bug report to: Peter.Vogt@ec.europa.eu' 
        printf, 11, '==============================================================================='
        printf, 11, 'Date: ' + systime()
        printf, 11, 'GTB-version: ' + vbase + aa
        printf, 11, 'Title-bar: ' + info.title + ' ' + info.add_title 
        printf, 11, ''
        printf, 11, '==============================================================================='
        printf, 11, '                             Image information: '
        printf, 11, '==============================================================================='
                    
        goto, sysinfofile  ;; Draw_Motion_Events is now switched off
        sysinfofiledone: 
        imdetails = file_lines(tmp) & imd = strarr(imdetails) & buginfo = ''
        openr, 5, tmp & readf, 5, imd & close, 5 & file_delete, tmp, / quiet
        for id = 5, imdetails -1 do printf, 11, imd(id)
        printf, 11, '==============================================================================='
        printf, 11, '                             System information: '
        printf, 11, '==============================================================================='
        printf, 11, 'MSPA-max: ' + mspamax
        printf, 11, 'Free RAM: ' + strtrim(mbavail,2)
        printf, 11, ' '

        ;; add OS-specific info                   
        CASE info.my_os OF
          'windows':BEGIN
             spawn, 'systeminfo', osd        
             for id = 0, n_elements(osd) -1 do printf, 11, osd[id]
          END
          'linux':BEGIN
            ;; get the distro info
            osd = 'Unknown [unknown]'
            spawn, 'unset LD_LIBRARY_PATH; which xdg-open 2>/dev/null', res &  res = res(0)
            IF strmid(res, 0, 1) NE '/' THEN BEGIN ;; not found
              buginfo = 'Please install xdg-open to display text files.' + string(10b)
            ENDIF
          
            ;; first try inxi
            spawn, 'unset LD_LIBRARY_PATH; which inxi 2>/dev/null', res &  res = res(0)
            IF strmid(res, 0, 1) EQ '/' THEN BEGIN ;;  found
              spawn, res + ' -v 4', osd
              printf, 11, 'INXI:'
              for id = 0, n_elements(osd) -1 do printf, 11, osd[id]
              goto, show_info
            ENDIF ELSE BEGIN
              buginfo = buginfo + 'Please install inxi for detailed system information.' + string(10b)
            ENDELSE
           
            ;; or this 
            IF (file_info('/etc/os-release')).exists EQ 1b THEN BEGIN
              spawn, 'unset LD_LIBRARY_PATH; cat /etc/os-release', osd
              for id = 0, n_elements(osd) -1 do printf, 11, osd[id]
            ENDIF ELSE BEGIN
              spawn, 'unset LD_LIBRARY_PATH; ls /etc/*-release', ct & ct = ct[n_elements(ct)-1]
              spawn, 'unset LD_LIBRARY_PATH; cat ' + ct, osd
              for id = 0, n_elements(osd) -1 do printf, 11, osd[id]             
            ENDELSE
            spawn, 'unset LD_LIBRARY_PATH; uname -a', osd
            for id = 0, n_elements(osd) -1 do printf, 11, osd[id]         
            printf, 11, '#CPU :' + strtrim(!cpu.HW_NCPU,2)
            spawn, 'unset LD_LIBRARY_PATH; free -m', osd
            for id = 0, n_elements(osd) -1 do printf, 11, osd[id]

          END     
          'apple':BEGIN
             spawn, 'system_profiler SPHardwareDataType', osd
             for id = 0, n_elements(osd) -1 do printf, 11, osd[id]
          END
        ENDCASE
        show_info:
        
        ;; finalize the bug report and close the file
        res = file_test(info.dir_data + 'nolimits.txt')
        printf, 11, ''
        printf, 11, 'Cheat code in use: ' + strtrim(res,2)
        res = file_test(info.dir_data + 'noproxycheck.txt')
        printf, 11, 'Proxy test disabled: ' + strtrim(res,2)
        printf, 11, ''
        printf, 11, '==============================================================================='
        printf, 11, '                             Bug report details:'
        printf, 11, '==============================================================================='
        printf, 11, 'Please provide detailed instructions on all steps needed'
        printf, 11, 'to reproduce the problem. If applicable provide:'
        printf, 11, '- public access to download the (zip-compressed) input image,'
        printf, 11, '- public access to download an incorrect result,'
        printf, 11, '- and/or attach screenshots to the bug report email.'
        printf, 11, '==============================================================================='
        printf, 11, 'Detailed problem description:'
        printf, 11, ' '
        close, 11 
        
        ;; remove funny strings which may be introduced by inxi
        if info.my_os eq 'linux' then begin
          spawn, "unset LD_LIBRARY_PATH; sed -i 's/12//g' " + GTBreport
          spawn, "unset LD_LIBRARY_PATH; sed -i 's///g' " + GTBreport      
        endif

        buginfo = buginfo + 'A bug report template has been created at:' + string(10b) + $
          GTBreport + string(10b) + string(10b) + $
          'Please complete and send this bug report to: ' + string(10b)+ $
          '              Peter.Vogt@ec.europa.eu'                 
        result = dialog_message (title = 'Bug report', buginfo)       
        
        ;; show the bug report file
        ;;================================
        CASE info.my_os OF
          'windows':BEGIN
            pushd, info.dir_data
            spawn, 'start ' + 'GTBbugreport.txt', / nowait
            popd
          END
          'linux':BEGIN
            spawn, 'unset LD_LIBRARY_PATH; which xdg-open 2>/dev/null', res &  res = res(0)
            IF strmid(res, 0, 1) EQ '/' THEN BEGIN ;;  found
              spawn, res + ' ' + GTBreport + ' &'
            ENDIF
          END
          'apple':BEGIN
            spawn, 'open -e ' + GTBreport
          END
        ENDCASE
        ;; switch motion events back on
        widget_control, info.w_draw, Draw_Motion_Events = 1
        
        
        ;; normal About info
      endif else begin
        result = dialog_message (title = 'About GTB', / information, str_about)
      endelse     
      GOTO, fin
   END
   ELSE: GOTO, fin
ENDCASE

goto, contnormal

resetfront:
;;========================================================================
;; reset the front image and block any events
;;========================================================================
;; if in zoom mode, quit zoom mode
IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
  info.selsubregion_id = 0
  ;; deactivate zoomfactor selector
  widget_control, info.w_zoomfac, sensitive = 1
  widget_control, info.w_selsubregion, set_value = 'Zoom Mode'
  ;; restore the prezoomed process image
  * info.process = * info.prezoomprocess
  ;; disable button and enable motion events in w_draw
  widget_control, info.w_draw, Draw_Motion_Events = 1
  widget_control, info.w_draw, Draw_Button_Events = 0
  info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
ENDIF

mev = 0 ;; set motion events to off
READ_JPEG, info.dir_guidossub + 'guidos.jpg', welcome
IF (size(welcome))[0] EQ 3 THEN BEGIN
  s = size(welcome) & dim_pos = where(s EQ 3) & dim_pos = dim_pos(1)
  welcome = color_quan(welcome, dim_pos, rini, gini, bini, / map_all)
  tvlct, rini, gini, bini
ENDIF
image0 = welcome & process = image0

s = size(image0)
;; max-display on screen, keep the rescale factor as integer
xf = fix((float(s(1)) / info.screen_size(0) * 1.4) * 10) / 10.0
yf = fix((float(s(2)) / info.screen_size(1) * 1.4) * 10) / 10.0
info.resfac = ceil(xf > yf) > 1
info.bigim = info.resfac GT 1

* info.image0 = image0
* info.process = image0
* info.prezoomprocess = image0
* info.undo = image0
* info.subimage = image0
* info.fr_image = image0
* info.fr_undo = image0
* info.orig_image = image0
;info.bigim = 0
* info.data_min = 0b
* info.data_max = 2b
info.datatype = ''
info.ctbl = - 1
info.disp_colors_id = 12
info.disp_range_id = 0
info.selsubregion_id = 0
info.autostretch_id = 1b 
info.title = title
info.add_title = ''
info.is_mspa = 0 & info.is_contort = 0
info.is_fragm = 0
info.mspa_stats_show = 0b
info.do_mspa_stats_id = 0

cmd = 'Please wait for ' + title + ' to finish.'
widget_control, info.w_iminfo, sensitive = 1
widget_control, info.w_iminfo2, sensitive = 1
WIDGET_CONTROL, info.w_rdpx, SET_VALUE = cmd
widget_control, info.w_tools, sensitive = 1
widget_control, info.w_pa, sensitive = 1
widget_control, info.w_file, sensitive = 1
widget_control, info.w_help, sensitive = 1
widget_control, info.w_disp_colors, set_combobox_select = info.disp_colors_id, sensitive = 1
widget_control, info.w_autostretch, set_value = info.autostretch_id, sensitive = 1
widget_control, info.w_disp_range, set_value = info.disp_range_id, sensitive = 1
widget_control, info.w_zoomfac, sensitive = 1

wset, info.pix_id
guidos_image, * info.process, info.autostretch_id
s = size( * info.process)
widget_control, info.w_drawbase, map = 0
widget_control, info.w_draw, / destroy

info.w_draw = widget_draw(info.w_drawbase, xsize = s(1), ysize = s(2), retain = 2)

widget_control, info.w_draw, / realize
widget_control, info.w_draw, get_value = draw_ID & info.draw_ID = draw_ID
widget_control, info.w_drawbase, map = 1
widget_control, info.tlb, tlb_set_title = info.title + info.add_title
wset, info.draw_id
guidos_image, * info.process, info.autostretch_id

widget_control, info.w_lp12, sensitive = 1
widget_control, info.w_label, sensitive = info.is_mspa or info.is_fragm or info.is_dist or info.is_contort eq 1 or info.is_influ gt 0 ;;;eq 1 ??? 
widget_control, info.w_pa_connectivity1, sensitive = 1
widget_control, info.w_pa_connectivity2, sensitive = 1
widget_control, info.w_pa_connectivity3, sensitive = 1
widget_control, info.w_mspa_stats, set_value = transpose(replicate('n/a', 14, 2))
widget_control, info.w_do_mspa_stats, set_value = info.do_mspa_stats_id



;; enable processing etc buttons
widget_control, info.w_lp11, / sensitive
widget_control, info.w_lp12, / sensitive
widget_control, info.w_label, sensitive = info.is_mspa OR info.is_fragm or info.is_dist or info.is_cost or info.is_contort eq 1 or info.is_influ gt 0
widget_control, info.w_lp1222, sensitive = info.is_mspa
widget_control, info.w_pa_connectivity1, sensitive = info.is_mspa
widget_control, info.w_pa_connectivity2, sensitive = info.is_nw
widget_control, info.w_pa_connectivity20, sensitive = info.is_nw
widget_control, info.w_pa_connectivity3, sensitive = info.is_nw
widget_control, info.w_sgeotiff, sensitive = info.is_geotiff
IF info.mspa_stats_show EQ 0b THEN widget_control, info.w_mspa_stats, set_value = transpose(replicate('n/a', 14, 2))
widget_control, info.w_do_mspa_stats, set_value = info.do_mspa_stats_id
widget_control, info.w_tools, / sensitive
widget_control, info.w_pa, / sensitive
widget_control, info.w_autostretch, / sensitive, set_value = info.autostretch_id
widget_control, info.w_file_save, / sensitive
widget_control, info.w_pa_morph, / sensitive
widget_control, info.w_batch, / sensitive
widget_control, info.w_disp_range, set_value = info.disp_range_id
widget_control, info.w_c2b, sensitive = info.datatype NE 'byte'
widget_control, info.w_c2i, sensitive = info.datatype NE 'integer'
widget_control, info.w_c2l, sensitive = info.datatype NE 'long integer'
widget_control, info.w_c2s, sensitive = info.datalayers EQ 3
condition = info.is_mspa EQ 0 OR info.is_contort EQ 0 OR info.is_nw EQ 0 OR info.is_cost eq 0 OR $
  info.is_dist EQ 0 OR info.is_influ EQ 0 AND (info.epsg NE '4326' AND info.is_geotiff EQ 1)
widget_control, info.w_c2ge, sensitive = condition EQ 1
widget_control, info.w_recode, sensitive = info.datatype EQ 'byte'


case eventvalue of
  'batch_ci': goto, backto_batch_ci
  'batch_mspanw': goto, backto_batch_mspanw
  'batch_ent': goto, backto_batch_ent
  'batch_hmc': goto, backto_batch_hmc
  'batch_cont': goto, backto_batch_cont
  'batch_eucldist': goto, backto_batch_eucldist
  'batch_parcellation': goto, backto_batch_parcellation
  'batch_accounting': goto, backto_batch_accounting
  'batch_mspa': goto, backto_batch_mspa
  'batch_spa': goto, backto_batch_spa
  'mspatile': goto, backto_mspatile
  'batch_p2': goto, backto_batch_p2
  'batch_p22': goto, backto_batch_p22
  'batch_p23': goto, backto_batch_p23
  'batch_sumd': goto, backto_batch_sumd
  'batch_shannon': goto, backto_batch_shannon
  'batch_lm': goto, backto_batch_lm
  'batch_lmms': goto, backto_batch_lmms
  'batch_recode': goto, backto_batch_recode
  'batch_fad': goto, backto_batch_fad
  'batch_fos': goto, backto_batch_fos
  'batch_rss': goto, backto_batch_rss
  'change': begin
    if eventValue2 eq 'change_fad' then goto, backto_change_fad
    if eventValue2 eq 'change_fos' then goto, backto_change_fos
    if eventValue2 eq 'change_rss' then goto, backto_change_rss
  end
endcase
;;========================================================================

contnormal:

;;-----------------------------------------------------------------------
;;-----------------------------------------------------------------------
;; when big fullres image update accordingly
* info.process = * info.fr_image
IF info.bigim THEN BEGIN
   s = size( * info.process,/dim)
   * info.process = congrid(temporary( * info.process), s[0] / info.resfac, s[1] / info.resfac)
ENDIF

;; data range
mi = min( * info.fr_image, max = mx, / nan)
* info.data_min = mi & * info.data_max = mx

redisplay:
;; the datatype may change due to the selected processing option
info.datatype = info.dtypes(size(* info.fr_image, / type))

;; display the image in the draw and zoomwindow and
;; make the draw widget window the current graphics window
IF info.ctbl GE 0 THEN loadct, info.ctbl, / silent

;; update the colortable indicator
widget_control, info.w_disp_colors, set_combobox_select = info.disp_colors_id
frag_colors = (info.disp_colors_id EQ 3 OR info.disp_colors_id EQ 4)
widget_control, info.w_autostretch, set_value = info.autostretch_id, / sensitive
widget_control, info.w_disp_range, set_value = info.disp_range_id

;; update the pixmap image
wset, info.pix_id

IF frag_colors THEN guidos_image, * info.process, 0  ELSE $
 guidos_image, * info.process, info.autostretch_id
 s = size( * info.process,/dim)

;; create a draw widget sized to the current image
widget_control, info.w_drawbase, map = 0
widget_control, info.w_draw, / destroy
IF s[0] GT info.xsize OR s[1] GT info.ysize THEN BEGIN
  info.w_draw = widget_draw(info.w_drawbase, xsize = s[0], $
    ysize = s[1], x_scroll_size = s[0] < info.xsize, $
    y_scroll_size = s[1] < info.ysize, $
    / app_scroll, retain = 2, motion_events = mev)
ENDIF ELSE BEGIN
  info.w_draw = widget_draw(info.w_drawbase, xsize = s[0], $
    ysize = s[1], retain = 2, motion_events = mev)
ENDELSE

widget_control, info.w_draw, / realize
widget_control, info.w_draw, get_value = draw_ID & info.draw_ID = draw_ID
widget_control, info.w_drawbase, map = 1
widget_control, info.tlb, tlb_set_title = info.title + info.add_title
widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id

wset, info.draw_id
IF frag_colors THEN guidos_image, * info.process, 0  ELSE $
 guidos_image, *info.process, info.autostretch_id

;; reset the fofrag statistics if required
widget_control, info.w_pa, /sensitive
widget_control, info.w_tools, /sensitive
widget_control, info.w_lp12, /sensitive
widget_control, info.w_label, sensitive = info.is_mspa or (info.is_fragm gt 0 and info.is_fragm lt 3) or info.is_dist or info.is_cost or $
  info.is_contort eq 1 or info.is_influ eq 1 or info.is_influ eq 3 ;;but not 2 (label)
widget_control, info.w_lp1222, sensitive = info.is_mspa
widget_control, info.w_pa_connectivity1, sensitive = info.is_mspa
widget_control, info.w_pa_connectivity2, sensitive = info.is_nw OR info.is_nwconnect
widget_control, info.w_pa_connectivity20, sensitive = info.is_nw
widget_control, info.w_pa_connectivity3, sensitive = info.is_nw OR info.is_nwconnect
widget_control, info.w_sgeotiff, sensitive = info.is_geotiff
widget_control, info.w_c2b, sensitive = info.datatype NE 'byte'
widget_control, info.w_c2i, sensitive = info.datatype NE 'integer'
widget_control, info.w_c2l, sensitive = info.datatype NE 'long integer'
widget_control, info.w_c2s, sensitive = info.datalayers EQ 3
condition = info.is_mspa EQ 0 OR info.is_contort EQ 0 OR info.is_nw EQ 0 OR info.is_cost eq 0 OR $
  info.is_dist EQ 0 OR info.is_influ EQ 0 AND (info.epsg NE '4326' AND info.is_geotiff EQ 1)
widget_control, info.w_c2ge, sensitive = condition EQ 1
widget_control, info.w_recode, sensitive = info.datatype EQ 'byte'

IF info.mspa_stats_show EQ 0b THEN $
 widget_control, info.w_mspa_stats, set_value = transpose(replicate('n/a', 14, 2))
widget_control, info.w_do_mspa_stats, set_value = info.do_mspa_stats_id

;; test for change analysis then disable Image Info
;condition = strmid(info.title,0,20) eq 'Simple change (A->B)' OR strmid(info.title,0,13) eq 'MCD (A->B) FG'
;widget_control, info.w_iminfo, sensitive = 1 - condition

;; check if colortable was restored
res = (size(colorreset))[1] 
if res eq 2 then res = dialog_message('Restored colortable:' +string(10b)+ ctbl_file,/information)


fin:
widget_control, info.w_file, / sensitive
widget_control, info.w_help, / sensitive

IF mev EQ 0 THEN BEGIN
   cmd = 'Please load an image via the menu: File -> Read Image.'
   WIDGET_CONTROL, info.w_rdpx, SET_VALUE = cmd
   v = strtrim(info.gtb_version, 2) & vbase = strmid(v, 0, 3)
   fv = fix(round(float(v)*1000)) & fvb = fix(round(float(vbase)*1000)) & strvrev = strtrim(fv - fvb,2)
   aa = ', Revision '  + strvrev + ' (' + strtrim(!version.memory_bits,2) + ' bit)'  
   info.title = 'GuidosToolbox ' + vbase + aa + ' - Default data directory: ' + info.dir_data
   widget_control, info.tlb, tlb_set_title = info.title
   widget_control, info.w_file_save, sensitive = 0
ENDIF

;; backup current colors
tvlct, r, g, b, /get & save, r,g,b, filename = info.dir_tmp2 + 'currcolors.sav'

;; return the info structure.
widget_control, event.top, set_uvalue = info, / no_copy
END  ;; of 'guidos_processing'

;;=======================================================================
;;=======================================================================
;;=======================================================================
;;=======================================================================



;;=======================================================================
;;=======================================================================
PRO guidos_undo, event

;; get the info structure and copy it here.
widget_control, event.top, get_uvalue = info, / no_copy

;; switch the process and undo images.
temp = * info.process  ;; temporary store the current info
* info.process = * info.undo ;; load the previous as current
* info.undo = temp  ;; set the undo to the current

temp = * info.fr_image
* info.fr_image = * info.fr_undo & * info.fr_undo = temp

temp = * info.data_min
* info.data_min = * info.undo_data_min & * info.undo_data_min = temp

temp = * info.data_max
* info.data_max = * info.undo_data_max & * info.undo_data_max = temp

temp = info.datatype
info.datatype = info.undo_datatype & info.undo_datatype = temp

;; switch the colortable, rotate, is_mspa
;; colors
temp = info.disp_colors_id
info.disp_colors_id = info.prev_disp_colors_id
widget_control, info.w_disp_colors, $
                set_combobox_select = info.disp_colors_id
info.prev_disp_colors_id = temp
tvlct, r, g, b, / get
tvlct, info.prev_r, info.prev_g, info.prev_b
info.prev_r = r & info.prev_g = g & info.prev_b = b

;; normalize
temp = info.disp_range_id
info.disp_range_id = info.prev_disp_range_id
widget_control, info.w_disp_range, set_value = info.disp_range_id
info.prev_disp_range_id = temp

;; autostretch
temp = info.autostretch_id
info.autostretch_id = info.prev_autostretch_id
widget_control, info.w_autostretch, set_value = info.autostretch_id
info.prev_autostretch_id = temp

;; mspa, cs22
temp = info.is_contort & info.is_contort = info.prev_is_contort
info.prev_is_contort = temp
temp = info.is_mspa & info.is_mspa = info.prev_is_mspa
info.prev_is_mspa = temp
temp = info.is_dist & info.is_dist = info.prev_is_dist
info.prev_is_dist = temp
temp = info.is_influ & info.is_influ = info.prev_is_influ
info.prev_is_influ = temp
temp = info.is_fragm & info.is_fragm = info.prev_is_fragm
info.prev_is_fragm = temp
temp = info.is_cs22 & info.is_cs22 = info.prev_is_cs22
info.prev_is_cs22 = temp
temp = info.is_cost & info.is_cost = info.prev_is_cost
info.prev_is_cost = temp
temp = info.is_nw & info.is_nw = info.prev_is_nw
info.prev_is_nw = temp
temp = info.is_nwconnect & info.is_nwconnect = info.prev_is_nwconnect
info.prev_is_nwconnect = temp

;; add_title
temp = info.add_title & info.add_title = info.prev_add_title
info.prev_add_title = temp

;; switch the undo/redo button values.
widget_control, event.id, get_value = thevalue, get_uvalue = theuvalue
widget_control, event.id, set_value = theuvalue, set_uvalue = thevalue

;; make the draw widget window the current graphics window
;; and draw the graphics
wset, info.pix_id
guidos_image, * info.process, info.autostretch_id
wset, info.draw_id
frag_colors = (info.disp_colors_id EQ 3 OR info.disp_colors_id EQ 4)
IF frag_colors THEN guidos_image, * info.process, 0  ELSE $
 guidos_image, * info.process, info.autostretch_id
widget_control, info.tlb, tlb_set_title = info.title + info.add_title
;; the datatype may change due to the selected processing option
info.datatype = info.dtypes(size(* info.fr_image, / type))

widget_control, info.w_lp12, sensitive = info.is_mspa
widget_control, info.w_label, sensitive = info.is_mspa or info.is_fragm or info.is_dist or info.is_cost or info.is_contort eq 1 or info.is_influ gt 0 ;;;eq 1???
widget_control, info.w_lp1222, sensitive = info.is_mspa
widget_control, info.w_pa_connectivity1, sensitive = info.is_mspa
widget_control, info.w_pa_connectivity2, sensitive = info.is_nw OR info.is_nwconnect
widget_control, info.w_pa_connectivity20, sensitive = info.is_nw
widget_control, info.w_pa_connectivity3, sensitive = info.is_nw OR info.is_nwconnect

;; return the info structure.
widget_control, event.top, set_uvalue = info, / no_copy
END ;; OF 'guidos_UNDO'


;;=======================================================================
;;=======================================================================
;;=======================================================================
;;=======================================================================



;;=======================================================================
;;=======================================================================
;;;;     E N D   O F    P R O C E S S I N G    E V E N T   H A N D L E R
;;=======================================================================
;;=======================================================================

;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################



;;=======================================================================
;;=======================================================================
PRO guidos_io, event
;; purpose: handle the reading of the input data

;; get the info structure and copy it here.
Widget_Control, event.top, Get_UValue = info, / No_Copy

;; Set the undo image to be the current process image.
* info.undo = * info.process
* info.fr_undo = * info.fr_image
* info.undo_data_min = * info.data_min
* info.undo_data_min = * info.data_max

;; get and store the color description before doing the next step
info.prev_disp_colors_id = info.disp_colors_id
info.prev_disp_range_id = info.disp_range_id  ;; correct??
info.prev_autostretch_id = info.autostretch_id
tvlct, r, g, b, / get
info.prev_r = r & info.prev_g = g & info.prev_b = b
info.prev_is_mspa = info.is_mspa
info.prev_is_fragm = info.is_fragm
info.prev_is_contort = info.is_contort
info.prev_is_cs22 = info.is_cs22
info.prev_is_cost = info.is_cost
info.prev_is_nw = info.is_nw
info.prev_is_nwconnect = info.is_nwconnect
info.prev_add_title = info.add_title

;; What kind of processing do you need?
Widget_Control, event.id, Get_Uvalue = eventValue
if strlen(eventValue) eq 16 and strmid(eventValue,0,12) eq 'save_generic' then begin
  eventValue2 = eventValue & eventValue = 'save_generic'
endif

;; default to not select zoomed image and to save statistics
szoom = 0b
savestats = 1

fileaction = StrlowCase(eventValue)
fnsaves = 'The following files were saved: ' + string(10b)

;; add generic software info
desc = 'GTB, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
desc0 = desc
;;=======================================================================
IF strmid(fileaction, 0, 4) EQ 'save' THEN BEGIN
  fname = info.title & pp = strpos(fname, '.', / reverse_search)
  IF pp GT 0 THEN fname = strmid(fname, 0, pp)
  
  ;; check if index value should be saved then we do not need all the image stuff
  IF strpos(info.add_title,'(Frag(Hypsometry_Index): ') GT 0 THEN BEGIN
    fname = info.fname_input & pp = strpos(fname, '.', / reverse_search)
    IF pp GT 0 THEN fname = strmid(fname, 0, pp)
    res = 'Fragmentation (Hypsometric curve) result using file: ' + info.fname_input
    fname1 = fname + '_FragHypsometry_Index.txt'
    fname2 = fname + '_FragHypsometry_HMCnorm.png'
    openw, 1, fname1 & printf, 1, res
    ;; extract values from info.add_title
    q = strpos(info.add_title, ': ',/reverse_search)
    res = strmid(info.add_title,2,strlen(info.add_title)-3)
    printf, 1, res & close, 1
    msg = 'Fragmentation index values have been saved to: ' + string(10b) + fname1
    IF (file_info(info.dir_tmp + 'barplot2.png')).exists EQ 1b THEN BEGIN
      file_copy, info.dir_tmp + 'barplot2.png', fname2,/overwrite
      msg = msg + string(10b) + fname2
    ENDIF  
    res = dialog_message(msg, / information)    
    goto,finall    
  ENDIF ELSE IF strpos(info.add_title,'(Frag(Entropy_Index): ') GT 0 THEN BEGIN
    fname = info.fname_input & pp = strpos(fname, '.', / reverse_search)
    IF pp GT 0 THEN fname = strmid(fname, 0, pp)
    res = 'Fragmentation (Entropy_Index) result using file: ' + info.fname_input
    fname = fname + '_FragEntropy_Index.txt'
    openw, 1, fname & printf, 1, res
    ;; extract values from info.add_title
    res = strmid(info.add_title,2,strlen(info.add_title)-3)
    printf, 1, res & close, 1
    msg = 'Fragmentation index values have been saved to: ' + string(10b) + fname
    res = dialog_message(msg, / information)
    goto,finall  
  ENDIF ELSE IF strpos(info.add_title,'/Classes/PARC:' ) GT 0 THEN BEGIN
    fname = info.fname_input & pp = strpos(fname, '.', / reverse_search)
    IF pp GT 0 THEN fname = strmid(fname, 0, pp)
    fname = fname + '_parc.csv'
    ;; test and warn if that file is currently open
    IF (file_info(fname)).exists EQ 1b THEN BEGIN
      close, 9 & openu, 9, fname, error = error & close,9
    ENDIF ELSE BEGIN ;; file does not exist
      error = 0
    ENDELSE
    if error eq 0 then begin
      ;; copy over     
      file_copy, info.dir_tmp2 + 'parc.csv', fname, /overwrite
      fx = strmid(fname,0,strlen(fname)-3) + 'txt'
      file_copy, info.dir_tmp2 + 'parc.txt', fx, /overwrite
      msg = 'Parcellation information has been saved to: ' + string(10b) + fname + '/txt'
      res = dialog_message(msg, / information)     
    endif else begin
      msg = 'The result can not be saved because your ' + string(10b) + $
        'spreadsheet application is showing the file:' + string(10b) + fname + string(10b) + string(10b) +$
        'Please close your spreadsheet application' + string(10b) + 'Then save the result again.'
      res = dialog_message(msg, / information)      
    endelse
    goto,finall
  ENDIF 
  
  ;; get the current MSPA-params (mspaext)
  tmp4conn = ['8', '4'] & c_FGconn = tmp4conn(1 - info.mspa_param1_id)
  c_size = info.mspa_size_current
  c_trans = strtrim(info.mspa_param3_id - 0, 2)
  c_intext = strtrim(info.mspa_param4_id - 0, 2)
  mspaext = '_' + c_FGconn + '_' + c_size + '_' + c_trans + '_' + c_intext
  prefix='' & is_lmms = 0 & is_lm = 0 & is_fos = 0 & is_fad = 0 & is_spa = 0 & is_eucldist = 0 & is_acc = 0 & is_restore=0
  rss_exists = (file_info(info.dir_tmp + 'rss.csv')).exists


  ;; check if MSPA, then add settings
  IF info.is_mspa EQ 1 THEN BEGIN
    fname = fname + mspaext
    desc = 'GTB_MSPA, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/ ' + strmid(mspaext, 1)
;;  ENDIF ELSE IF info.is_cost EQ 1 THEN BEGIN
;;    desc = 'GTB, https://forest.jrc.ec.europa.eu/download/software/guidos ' + strmid(mspaext, 1)
;;    desc = 'GTB, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/ ' + strmid(mspaext, 1)
  ENDIF ELSE IF info.is_cs22 EQ 1 THEN BEGIN
    qq = strpos(fname,mspaext) & if qq lt 0 then fname = fname + mspaext
    fnamex = fname
    fname = fname + '_cs'
    desc = 'GTB, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/ ' + strmid(mspaext, 1)
  ENDIF ELSE IF info.is_fragm EQ 1 THEN BEGIN
    IF strpos(info.add_title,'(Frag(Contagion): ') GT 0 THEN $
      fname = fname + '_FragContagion' ELSE fname = fname + '_FragEntropy'
  ENDIF ELSE IF info.is_fragm EQ 3 THEN BEGIN ;; fos or fad
    IF strpos(info.add_title,'(FOS 6-class: ') GT 0 THEN BEGIN
      is_fos=1 & fostypen = 'fos6'
    ENDIF ELSE IF strpos(info.add_title,'(FOS 5-class: ') GT 0 THEN BEGIN
        is_fos=2 & fostypen = 'fos5'
    ENDIF ELSE IF strpos(info.add_title,'(FOS-APP 2-class: ') GT 0 THEN BEGIN
      is_fos=4 & fostypen = 'fos-app2'
    ENDIF ELSE IF strpos(info.add_title,'(FOS-APP 5-class: ') GT 0 THEN BEGIN
      is_fos=5 & fostypen = 'fos-app5'
    ENDIF
    IF is_fos GT 0 THEN BEGIN
      restore,info.dir_tmp + 'fos.sav' ;; watch out there is a fostype variable in there with captal letters
      fdir = fname + '_' + fostypen + '_' + kdim_str
      fname = fname + '_' + fostypen + '_' + kdim_str
      desc = 'GTB_FOS, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/ '+ strmid(mspaext, 1)
    ENDIF ELSE BEGIN
      IF strpos(info.add_title,'(FAD 6-class: MultiScale summary)') GT 0 THEN BEGIN
        is_fad=1 & fadtypen = 'fad'
      ENDIF ELSE IF strpos(info.add_title,'(FAD-APP 2-class: MultiScale summary)') GT 0 THEN BEGIN
        is_fad=2 & fadtypen = 'fad-app2'
      ENDIF ELSE IF strpos(info.add_title,'(FAD-APP 5-class: MultiScale summary)') GT 0 THEN BEGIN
        is_fad=5 & fadtypen = 'fad-app5'
      ENDIF
      IF is_fad GT 0 THEN BEGIN
        restore,info.dir_tmp + 'fad.sav' ;; watch out there is a fadtype variable in there with captal letters
        fdir = fname + '_' + fadtypen 
        fname = fname + '_' + fadtypen
        desc = 'GTB_FAD, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/ '  ;;+ strmid(mspaext, 1)
      ENDIF
    ENDELSE
  ENDIF ELSE IF info.is_nw EQ 1 THEN BEGIN
    qq = strpos(fname,mspaext) & if qq lt 0 then fname = fname + mspaext
    fnamex = fname
    fname = fname + '_nw'
    desc = 'GTB, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/ ' + strmid(mspaext, 1)
  ENDIF ELSE IF info.is_dist EQ 1 THEN BEGIN
    fdir = fname + '_dist'
    fname = fname + '_dist' & is_eucldist = 1
    desc = 'GTB_EUCL, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
  ENDIF ELSE IF info.is_contort GT 0 THEN BEGIN
    fname = fname + '_contort_' + strtrim(fix(info.mspa_size_current),2)
  ENDIF ELSE IF info.is_nwconnect EQ 1 THEN BEGIN ;; component connectors
    qq = strpos(fname,mspaext) & if qq lt 0 then fname = fname + mspaext
    fnamex = fname
    fname = fname + '_nw_compconnect'    
  ENDIF ELSE IF info.is_influ EQ 1 THEN BEGIN ;; influence zones are always 8-conn
    fname = fname + '_influence_' + strtrim(fix(info.mspa_size_current),2) + $
      '_' + strtrim(info.label_t1,2) + '_' + strtrim(info.label_t2,2)
  ENDIF ELSE IF info.is_influ EQ 2 THEN BEGIN ;; label objects can be 4 or 8-conn
    fname = fname + '_acc'
    fdir = fname & is_acc = 1
    desc = 'GTB_ACC, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
  ENDIF ELSE IF info.is_influ EQ 3 THEN BEGIN ;; proximity is always 8-conn
    IF strpos(info.add_title,'(Reconnect: ') GT 0 THEN prefix = '_reconnect_' ELSE prefix = '_proximity_'  
    fname = fname + prefix + strtrim(fix(info.mspa_size_current),2)+ $
      '_' + strtrim(info.label_t1,2) + '_' + strtrim(info.label_t2,2)
   ENDIF ELSE IF strpos(info.add_title,'LM, kdim=') GT 0 THEN BEGIN
    q = strpos(info.add_title,'kdim=') & q = strmid(info.add_title, q+5)
    kdim_str = (strsplit(q,')',/extract))[0] & is_lm = 1
    fdir = fname + '_lm_' + kdim_str
    fname = fname + '_lm_' + kdim_str
    desc = 'GTB_LM, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
  ENDIF ELSE IF strpos(info.add_title,'SumD: overall') GT 0 THEN BEGIN
    fname = fname + '_sumd'
  ENDIF ELSE IF strpos(info.add_title,'ominance: MultiScale summary') GT 0 THEN BEGIN
    fn_lmms = fname + '_lm_'
    fname = fname + '_dominance_mscale' & is_lmms = 1
    desc = 'GTB_LM, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
  ENDIF ELSE IF strpos(info.add_title,'P22: FG contagion') GT 0 THEN BEGIN
    q = strpos(info.add_title,'kdim=') & q = strmid(info.add_title, q+5)
    kdim = (strsplit(q,';',/extract))[0]
    fname = fname + '_p22_' + kdim
    desc = 'GTB_P22, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
  ENDIF ELSE IF strpos(info.add_title,'P23: FG/interesting') GT 0 THEN BEGIN
    q = strpos(info.add_title,'kdim=') & q = strmid(info.add_title, q+5)
    kdim = (strsplit(q,';',/extract))[0]
    fname = fname + '_p23_' + kdim
    desc = 'GTB_P23, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
  ENDIF ELSE IF strpos(info.add_title,'P2: FG density') GT 0 THEN BEGIN
    q = strpos(info.add_title,'kdim=') & q = strmid(info.add_title, q+5)
    kdim = (strsplit(q,';',/extract))[0]
    fname = fname + '_p2_' + kdim
    desc = 'GTB_P2, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
  ENDIF ELSE IF strpos(info.add_title,'isochrone map A)') GT 0 THEN BEGIN
    fname = fname + '_isochroneA'
    desc = 'GTB_ISO, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
  ENDIF ELSE IF strpos(info.add_title,'isochrone map AB)') GT 0 THEN BEGIN
    fname = fname + '_isochroneAB'
    desc = 'GTB_ISO, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
  ENDIF ELSE IF info.add_title EQ ' (SPA2)' THEN BEGIN
    fname = fname + '_spa2' & is_spa = 2
    desc = 'GTB_SPA, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
  ENDIF ELSE IF info.add_title EQ ' (SPA3)' THEN BEGIN
    fname = fname + '_spa3' & is_spa = 3
    desc = 'GTB_SPA, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
  ENDIF ELSE IF info.add_title EQ ' (SPA5)' THEN BEGIN
    fname = fname + '_spa5' & is_spa = 5
    desc = 'GTB_SPA, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
  ENDIF ELSE IF info.add_title EQ ' (SPA6)' THEN BEGIN
    fname = fname + '_spa6' & is_spa = 6
    desc = 'GTB_SPA, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'   
  ENDIF ELSE IF strpos(info.add_title,'(restoration path between ') GT 0 THEN BEGIN ;; Restoration Planner
    p = strpos(info.add_title,'BGresist:')
    tt = strmid(info.add_title,p+10)
    p2 = strpos(tt, '%')
    bgresist = strmid(tt, 0, p2)
    fname = fname + '_restoration_' + bgresist & is_restore = 1
    desc = 'GTB_RES, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
  ENDIF ELSE IF strpos(info.add_title,'%; tick FGConn to reset)') GT 0 THEN BEGIN ;; custom Reconnect, path or optimum   
    IF info.is_cost EQ 3 THEN BEGIN ;; no restoration but image in definition phase
      fname = fname + '_result' & is_restore = 0
      desc = 'GTB, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
    ENDIF ELSE IF info.is_cost EQ 4 THEN BEGIN
      tmpfile = file_search(info.dir_tmp + '*.csv')
      tmpfile = file_basename(tmpfile[0],'.csv')
      fname = fname + '_' + tmpfile & is_restore = 1
      desc = 'GTB_RES, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
    ENDIF ELSE BEGIN ;; restoration cost image
      tmpfile = file_search(info.dir_tmp + 'restoration*AB.tif')
      tmpfile = file_basename(tmpfile[0],'.tif')
      fname = fname + '_' + tmpfile & is_restore = 1
      desc = 'GTB_RES, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
    ENDELSE       
  ENDIF ELSE IF strpos(info.add_title, 'dist2resistance)' ) GT 0 THEN BEGIN ;; dis2resistance image
     fname = fname + '_disres'
     desc = 'GTB_DRES, https://forest.jrc.ec.europa.eu/activities/lpa/gtb/'
  ENDIF ELSE IF info.is_cost eq 8 and rss_exists THEN BEGIN ;; restoration status summary
     fname = info.fname_input & pp = strpos(fname, '.', / reverse_search)
     IF pp GT 0 THEN fname = strmid(fname, 0, pp)
     z = fname + '_rss.csv'
     file_copy, info.dir_tmp + 'rss.csv', z, /overwrite
     fnsaves = fnsaves + z + string(10b)   
     fname = fname + '_rss'
   ENDIF ELSE BEGIN
    fname = fname + '_result'
  ENDELSE
endif

IF strmid(fileaction, 0, 4) EQ 'read' THEN BEGIN
  ;; reset label_groups to be not active
  info.do_label_groups_id = 0b
  widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id

  ;; if in zoom mode, quit zoom mode
  IF info.selsubregion_id EQ 1 THEN BEGIN ;; quit the zoom mode
    info.selsubregion_id = 0
    ;; deactivate zoomfactor selector
    widget_control, info.w_zoomfac, sensitive = 1
    widget_control, info.w_selsubregion, $
      set_value = 'Zoom Mode'
    ;; restore the prezoomed process image
    * info.process = * info.prezoomprocess
    ;; disable button and enable motion events in w_draw
    widget_control, info.w_draw, Draw_Motion_Events = 1
    widget_control, info.w_draw, Draw_Button_Events = 0
    info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
  ENDIF
ENDIF

CASE fileaction OF

   ;;  R E A D   O P T I O N S
   ;;============================================================

   'read_geotiff': BEGIN
      tit = 'Please select a GeoTiff-file'
      filters = [['*.tif;*.tiff;*.TIF;*.TIFF'], ['tiff']]
      im_file = $
        dialog_pickfile(Title = tit, get_path = path2file, $
        path = info.dir_data, default_extension = 'tiff', / fix_filter, $
        / must_exist, filter = filters)
      IF im_file EQ '' THEN GOTO, fin ;; 'cancel' selected    
      widget_control, / hourglass 

      gtiffread:
      ;; check that user is not cheating
      IF info.my_os EQ 'windows' THEN BEGIN
         cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalinfo -noct "' + im_file + '"'
      ENDIF ELSE BEGIN
         if strlen(info.sysgdal) gt 0 then $
          cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + im_file + '"' else cmd = info.dir_fwtools + 'gdalinfo -noct "' + im_file + '"'
      ENDELSE

      IF info.my_os EQ 'windows' THEN spawn, cmd, log, / hide ELSE spawn, cmd, log & q = log[0]
      ftype = strmid(q, strpos(q, ': ') + 2, 13)
      IF ftype NE 'GTiff/GeoTIFF' THEN BEGIN
         skgtno:
         msg = 'This image is not a (Geo)-Tiff file.' + string(10b) + $
               'Try "read generic" instead.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information) & GOTO, fin
      ENDIF
      ;; test for watermark
      ;; the old way up to 2.701
      q=where(strmid(log,0,27) eq "  TIFFTAG_SOFTWARE=JRC MSPA") & q=q[0]
      if q gt 0 then begin
        q=log(q) & res=strsplit(q,' ',/extract,count=nx)
        if nx eq 4 then newimis_mspa=res(nx-1)
      endif
      ;; the new way from 2.702
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_MSP") & q=q[0] 
      if q gt 0 then begin
        q=log(q) & res=strsplit(q,' ',/extract,count=nx)
        if nx eq 3 then newimis_mspa=res(nx-1)
      endif
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_FAD") & q=q[0] & if q gt 0 then newimis_fad = 1
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_FOS") & q=q[0] & if q gt 0 then newimis_fos = 1
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_SPA") & q=q[0] & if q gt 0 then newimis_spa = 1
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_ACC") & q=q[0] & if q gt 0 then newimis_acc = 1
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_LM,") & q=q[0] & if q gt 0 then newimis_lm = 1
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_EUC") & q=q[0] & if q gt 0 then newimis_dist = 1
      q=where(strmid(log,0,33) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_P2") & q=q[0] & if q gt 0 then newimis_P222 = 1
      q=where(strmid(log,0,35) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_DRES") & q=q[0] & if q gt 0 then newimis_disres = 1 
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_RES") & q=q[0] & if q gt 0 then newimis_res = 1
      q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_ISO") & q=q[0] & if q gt 0 then newimis_cos = 1
 
      ;; read and validate the input image
      res = query_tiff(im_file, tiffinfo, geotiff = geotiffinfo)
      
      IF res EQ 1 AND (size(geotiffinfo))[0] gt 0 THEN BEGIN
        image0 = read_tiff(im_file, r, g, b)
        info.fname_input = im_file
        info.is_geotiff = 1b & * info.geotiffinfo = geotiffinfo
        IF (size(r))[0] GT 0 THEN tvlct, r, g, b
      ENDIF ELSE BEGIN
        msg = 'This image is either: ' + string(10b) +$
          '- unknown GeoTiff: Try "Read IP Software" instead.' + string(10b) + $
          '- not a GeoTiff: Try "Read Generic" instead.' + string(10b) + string(10b) + 'Returning...'         
        res = dialog_message(msg, / information) & GOTO, fin
      ENDELSE
      
      ;; check for maximum allowed size
      q = float(tiffinfo.dimensions[0]) * tiffinfo.dimensions[1]
      IF q GT info.immaxsizeg THEN BEGIN
         msg = 'This image is larger than the maximum' + string(10b) + $
               'supported file-size in GuidosToolbox (31000 x 31000). ' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information) & GOTO, fin
      ENDIF
      
      ;; transfer image to 2-D if necessary
      s = size(image0)
      IF s[0] EQ 3 THEN BEGIN ;; 3-dim image
         IF s[1] EQ 3 THEN BEGIN ;; 3 band image
            s = size(image0) & dim_pos = where(s EQ 3) & dim_pos = dim_pos(1)
            ;;remap true color images
            image0 = color_quan(image0, dim_pos, r, g, b, / map_all)
            tvlct, r, g, b & info.disp_colors_id = 12 & info.ctbl = - 1
         ENDIF ELSE BEGIN
            msg = 'Please provide a single-band image.' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information)
            GOTO, fin
         ENDELSE
      ENDIF ELSE IF s[0] EQ 2 THEN BEGIN
         info.ctbl = 0 & info.disp_colors_id = 0
         
         ;; test for original (M)SPA or other ACC, FAD/FOS, LM, Restore image
         if (size(newimis_mspa))[2] eq 1 OR (size(newimis_acc))[2] eq 1 OR (size(newimis_spa))[2] eq 1 OR (size(newimis_res))[2] eq 1 then begin
           info.disp_colors_id = 3 & info.ctbl = - 1 & info.autostretch_id = 0 
         endif  
         if (size(newimis_dist))[2] eq 1 then begin
           info.disp_colors_id = 4 & info.ctbl = - 1
         endif
         if (size(newimis_disres))[2] eq 1 then begin
           info.disp_colors_id = 11 & info.ctbl = - 1
         endif
         if (size(newimis_p222))[2] eq 1 OR (size(newimis_cos))[2] eq 1 then begin
           info.disp_colors_id = 5 & info.ctbl = - 1 & info.autostretch_id = 0 
         endif
         if (size(newimis_fad))[2] eq 1 OR (size(newimis_fos))[2] eq 1 then begin
           info.disp_colors_id = 8 & info.ctbl = - 1 
         endif
         if (size(newimis_lm))[2] eq 1 then begin
           info.disp_colors_id = 7 & info.ctbl = - 1 
         endif
         
      ENDIF ELSE BEGIN
         msg = 'Please provide a single-band image.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDELSE
      
      ;; get projname and EPSG code (caution: the EPSG code is not always well defined)
      ;; search for presence of GEOGCS
      info.epsgname = 'Proj-name not defined'
      q = STREGEX(log, 'GEOGCS', /FOLD_CASE) & q2 = where(q ne -1, ct)
      if ct gt 0 then begin
        q2 = q2[0] & q = log[q2] & p = strsplit(q,'"') & epsgname = strmid(q, p[1],p[2]-p[1]-1)
        info.epsgname = epsgname       
      endif else begin
        ;; try for proj6.2
        q = STREGEX(log, 'GEOGCRS', /FOLD_CASE) & q2 = where(q ne -1, ct)
        if ct gt 0 then begin
          q2 = q2[0] & q = log[q2] & p = strsplit(q,'"') & epsgname = strmid(q, p[1],p[2]-p[1]-1)
          info.epsgname = epsgname 
        endif        
      endelse
      
      info.epsg = 'EPSG code not defined'
      q = STREGEX(log, 'EPSG', /FOLD_CASE) & q2 = where(q ne -1, ct) ;;where(q gt 0, ct)
      if ct gt 0 then begin
        ;; get last EPSG entry
        q3 = log(q2(n_elements(q2)-1))
        s2 = STRPOS(q3, '"', /reverse_search)
        s1 = STRPOS(strmid(q3,0,s2), '"', /reverse_search)
        EPSG = strmid(q3,s1+1,s2-s1-1)
        ppp = 'ID["EPSG"' ;; test for new proj 6.2 format
        p62 = strpos(q3, ppp)
        IF p62 gt 0 THEN BEGIN
          s1 = STRPOS(q3, ',')
          s2 = STRPOS(q3, ']')
          EPSG = strmid(q3,s1+1,s2-s1-1)
        ENDIF        
        info.epsg = epsg
        ;; test/fix for wrong CORINE header
        IF info.epsg EQ '9001' THEN BEGIN
          st = ' Geocoding information not available Projection Name = ETRS_1989_LAEA Units = meters GeoTIFF Units = ot'
          gtag = tag_names(geotiffinfo) & q = where(gtag eq 'GTCITATIONGEOKEY', ct)
          IF ct GT 0 THEN BEGIN
            IF geotiffinfo.GTCITATIONGEOKEY EQ st THEN info.epsg = '3035'
          ENDIF
        ENDIF
      endif

      image_title = strmid(im_file, strlen(path2file))
      image_title = strmid(image_title, 0, strpos(image_title, '.'))
      info.fname_input = im_file
      widget_control, info.w_iminfo, / sensitive
      widget_control, info.w_iminfo2, / sensitive
   END

   'read_generic':BEGIN
      res = dialog_read_image(file = im_file, get_path = path2file, $
        image = image0, path = info.dir_data, red = r, green = g, blue = b)
     IF res EQ 0 THEN GOTO, fin ;; 'cancel' was selected
     widget_control, / hourglass
          
     res = size(image0)     
     IF res[0] EQ 0 THEN BEGIN
        res = dialog_message('Invalid image format or directory' + $
        string(10b) + 'instead of file selected. ' + string(10b) + 'Returning...', / information)
        GOTO, fin
     ENDIF
     
     q = res[1] * res[2]
     IF q GT info.immaxsizeg THEN BEGIN
        msg = 'This image is larger than the maximum' + string(10b) + $
               'supported file-size in GuidosToolbox (31000 x 31000).' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information) & GOTO, fin
     ENDIF
     tvlct, r, g, b

     ;; transfer image to 2-D if necessary
     s = size(image0)
     IF s[0] EQ 3 THEN BEGIN ;; 3-dim image
        IF s[1] EQ 3 THEN BEGIN ;; 3 band image
           s = size(image0) & dim_pos = where(s EQ 3) & dim_pos = dim_pos(1)
           ;;remap true color images
           image0 = color_quan(image0, dim_pos, r, g, b, / map_all)
           tvlct, r, g, b & info.disp_colors_id = 12 & info.ctbl = - 1
        ENDIF ELSE BEGIN
           msg = 'Please provide a single-band image.' + string(10b) + 'Returning...'
           res = dialog_message(msg, / information)
           GOTO, fin
        ENDELSE
     ENDIF ELSE IF s[0] EQ 2 THEN BEGIN
        info.ctbl = 0 & info.disp_colors_id = 0
     ENDIF ELSE BEGIN
        msg = 'Please provide a single-band image.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information)
        GOTO, fin
     ENDELSE
     
     ;; test for original MSPA, FAD or FOS image
     IF info.my_os EQ 'windows' THEN BEGIN
       cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalinfo -noct "' + im_file + '"'
     ENDIF ELSE BEGIN
       if strlen(info.sysgdal) gt 0 then $
        cmd = 'unset LD_LIBRARY_PATH; gdalinfo -noct "' + im_file + '"' else $
        cmd = info.dir_fwtools + 'gdalinfo -noct "' + im_file + '"'
     ENDELSE
     IF info.my_os EQ 'windows' THEN spawn, cmd, log, / hide ELSE spawn, cmd, log & q = log[0]

     ;; test for watermark
     ;; the old way up to 2.701
     q=where(strmid(log,0,27) eq "  TIFFTAG_SOFTWARE=JRC MSPA") & q=q[0]
     if q gt 0 then begin
       q=log(q) & res=strsplit(q,' ',/extract,count=nx)
       if nx eq 4 then newimis_mspa=res(nx-1)
     endif
     ;; the new way from 2.702
     q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_MSP") & q=q[0]
     if q gt 0 then begin
       q=log(q) & res=strsplit(q,' ',/extract,count=nx)
       if nx eq 3 then newimis_mspa=res(nx-1)
     endif
     q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_FAD") & q=q[0] & if q gt 0 then newimis_fad = 1
     q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_FOS") & q=q[0] & if q gt 0 then newimis_fos = 1
     q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_SPA") & q=q[0] & if q gt 0 then newimis_spa = 1
     q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_ACC") & q=q[0] & if q gt 0 then newimis_acc = 1
     q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_LM,") & q=q[0] & if q gt 0 then newimis_lm = 1
     q=where(strmid(log,0,34) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_EUC") & q=q[0] & if q gt 0 then newimis_dist = 1
     q=where(strmid(log,0,35) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_DRES") & q=q[0] & if q gt 0 then newimis_disres = 1
     q=where(strmid(log,0,33) eq "  TIFFTAG_IMAGEDESCRIPTION=GTB_P2") & q=q[0] & if q gt 0 then newimis_P222 = 1
              
     ;; test for original (M)SPA or other ACC, FAD/FOS, LM image
     if (size(newimis_mspa))[2] eq 1 OR (size(newimis_acc))[2] eq 1 OR (size(newimis_spa))[2] eq 1 then begin
       info.disp_colors_id = 3 & info.ctbl = - 1 & info.autostretch_id = 0 
     endif
     if (size(newimis_dist))[2] eq 1 then begin
       info.disp_colors_id = 4 & info.ctbl = - 1
     endif
     if (size(newimis_p222))[2] eq 1 then begin
       info.disp_colors_id = 5 & info.ctbl = - 1 
     endif
     if (size(newimis_fad))[2] eq 1 OR (size(newimis_fos))[2] eq 1 then begin
       info.disp_colors_id = 8 & info.ctbl = - 1
     endif
     if (size(newimis_lm))[2] eq 1 then begin
       info.disp_colors_id = 7 & info.ctbl = - 1
     endif
     if (size(newimis_disres))[2] eq 1 then begin
       info.disp_colors_id = 11 & info.ctbl = - 1
     endif

     ;; flip image if it is png
     fext = strpos(im_file, '.', / reverse_search)
     fext = strmid(strlowcase(strmid(im_file, fext + 1)), 0, 3)
     if fext eq 'png' then image0 = rotate(image0,7)

     image_title = strmid(im_file, strlen(path2file))
     image_title = strmid(image_title, 0, strpos(image_title, '.'))
     info.is_geotiff = 0b & * info.geotiffinfo = 0b
     info.fname_input = im_file
     widget_control, info.w_iminfo, / sensitive
     widget_control, info.w_iminfo2, / sensitive
  END

   'read_ip_soft':BEGIN
      tit = 'Import file of type: img, bil, ...'
      filters = [['*.*', '*.img;*.IMG', '*.bil;*.BIL'], $
           ['Other IP-SW files', 'ERDAS Imagine', 'ARCView Raster']]

      ipsw = $
        dialog_pickfile(Title = tit, get_path = path2file, $
                        path = info.dir_data, / must_exist, filter = filters)
      IF ipsw EQ '' THEN GOTO, fin ;; 'cancel' selected ##default_extension = 'img',
      widget_control, / hourglass

      ;; build the full path & name of the converted geotiff
      tt1 = file_dirname(ipsw, / mark_directory)
      tt2 = file_basename(ipsw)
      ;; tiff is not allowed here and should be read otherwise
;      tt3 = strlowcase(strmid(tt2, strpos(tt2, '.', / reverse_search)+1))
;      IF tt3 EQ 'tif' OR tt3 EQ 'tiff' THEN BEGIN
;         msg = 'Tiff images are read via the option' + string(10b) + $
;               '"GeoTiff" or "Generic". ' + string(10b) + 'Returning...'
;         res = dialog_message(msg, / information) & GOTO, fin
;      ENDIF
      tt3 = strmid(tt2, 0, strpos(tt2, '.', / reverse_search)) + '_conv.tif'
      im_file = tt1 + tt3

      ;; try to convert to geotiff
      IF info.my_os EQ 'windows' THEN BEGIN
         cmd = info.windrive + ' & cd "' + info.dir_fwtools + '" & setfw.bat & '
         cmd = cmd + 'cd "' + tt1 + $
               '" & gdal_translate -of GTiff -co "COMPRESS=LZW" ' + $
               tt2 + ' ' + tt3 + '"'
      ENDIF ELSE BEGIN ;; linux
         if strlen(info.sysgdal) gt 0 then $
          cmd = 'unset LD_LIBRARY_PATH; gdal_translate -of GTiff -co "COMPRESS=LZW" ' + ipsw + ' ' + im_file else $
          cmd = info.dir_fwtools + 'gdal_translate -of GTiff -co "COMPRESS=LZW" ' + ipsw + ' ' + im_file
      ENDELSE
      IF info.my_os EQ 'windows' THEN $
       spawn, cmd, log, / hide ELSE spawn, cmd, log

      ;; test if conversion was possible, if not error message
      IF (file_info(im_file)).exists EQ 1b THEN BEGIN
         GOTO, gtiffread
      ENDIF ELSE BEGIN
         msg = 'Import NOT successful. Suggestion: ' + string(10b) + $
               '- ensure there are no spaces in the file name,' + $
               string(10b) + $
               '- use your native IP software and export your data' + $
               string(10b) + '   to the default (Geo)-Tiff format,' + $
               string(10b) + 'Then try again.'
         res = dialog_message(msg, / information) & GOTO, fin
      ENDELSE
      widget_control, info.w_iminfo, / sensitive
      widget_control, info.w_iminfo2, / sensitive
   END


   'read_envi':BEGIN
      tit = 'ENVI header file (*.hdr)'
      envi_hdr_fil = $
       dialog_pickfile(Title = tit, filter = '[*.hdr;*.HDR]', / fix_filter, $
                       / must_exist, get_path = path2file, $
                       path = info.dir_data)
      IF envi_hdr_fil EQ '' THEN GOTO, fin ;; 'cancel' was selected
      widget_control, / hourglass

      ;; data dimensions
      head = strarr(file_lines(envi_hdr_fil))
      openr, 1, envi_hdr_fil & readf, 1, head & close, 1
      q = where(strmid(head, 0, 7) EQ 'samples')
      xdim = uint(strmid(head(q(0)), 10))
      ydim = uint(strmid(head(q(0) + 1), 10))
      bands = uint(strmid(head(q(0) + 2), 10))

      ;; corresponding file name
      im_file = strmid(envi_hdr_fil, 0, strlen(envi_hdr_fil) - 4)
      image0 = reform(bytarr(bands, xdim, ydim))
      widget_control, / hourglass
      openr, 1, im_file & readu, 1, image0 & close, 1

      ;; transfer image to 2-D if necessary
      s = size(image0)
      IF s[0] EQ 3 THEN BEGIN ;; 3-dim image
         IF s[1] EQ 3 THEN BEGIN ;; 3 band image
            s = size(image0) & dim_pos = where(s EQ 3) & dim_pos = dim_pos(1)
            ;;remap true color images
            image0 = color_quan(image0, dim_pos, r, g, b, / map_all)
            tvlct, r, g, b & info.disp_colors_id = 12 & info.ctbl = - 1
         ENDIF ELSE BEGIN
            msg = 'Please provide a single-band image.' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information)
            GOTO, fin
         ENDELSE
      ENDIF ELSE IF s[0] EQ 2 THEN BEGIN
         info.ctbl = 0 & info.disp_colors_id = 0
      ENDIF ELSE BEGIN
         msg = 'Please provide a single-band image.' + string(10b) + 'Returning...'
         res = dialog_message(msg, / information)
         GOTO, fin
      ENDELSE
      image_title = strmid(im_file, strlen(path2file))
      info.fname_input = envi_hdr_fil
      info.is_geotiff = 0b & * info.geotiffinfo = 0b
      widget_control, info.w_iminfo, / sensitive
      widget_control, info.w_iminfo2, / sensitive
   END

   ;;  S A V E   O P T I O N S
   ;;============================================================
   'save_display':BEGIN
      wshow, !D.Window & tvlct, r, g, b, / get
      truecolor = fix((!D.Flags AND 256) NE 0)
      IF truecolor THEN BEGIN
         device, get_decomposed = theDecomposedState
         device, decomposed = 1
         image0 = tvrd(0, 0, !D.X_size, !D.Y_size, true = truecolor)
         image0 = color_quan(image0, 1, r, g, b, / map_all)
         ;;reset settings to get propper output on screen
         device, decomposed = theDecomposedState
      ENDIF ELSE image0 = tvrd(0, 0, !D.X_size, !D.Y_size)
      
      mcdchange = 0
      if strmid(info.title,0,20) eq 'Simple change (A->B)' then fname='simplechange' 
      if strmid(info.title,0,13) eq 'MCD (A->B) FG' then begin
        fname='morphdiff' & mcdchange = 1
      endif
      
      IF info.selsubregion_id EQ 1 THEN fname = fname + '_zoom'
      res = dialog_write_image(image0, r, g, b, file = fname + '.png', $
             / warn_exist, path = info.dir_data, type = '.png', / fix_type, options = useropt)
      if res eq 0 then goto,finall
      fnsaves = fnsaves + useropt.filename + string(10b)
      
      IF mcdchange EQ 1 then begin
        z = useropt.filename
        z = strmid(z,0,strlen(z)-4) + '.txt'
        openw, 1, z
        printf, 1, info.title
        ;; get change MCD stats
        gain = total(* info.fr_image eq 12b) & gain = strtrim(ulong64(gain),2)
        loss = total(* info.fr_image eq 21b) & loss = strtrim(ulong64(loss),2)
        printf, 1, 'Gain [pixels]: ' + gain
        printf, 1, 'Loss [pixels]: ' + loss
        close, 1
        fnsaves = fnsaves + z + string(10b)
      ENDIF 
           
      fname = info.dir_data + file_basename(fname) + '.png'
      GOTO, fin
   END


   'save_geotiff':BEGIN
      szoom = 0b
      ;;;if (info.is_fragm eq 3 and is_fos eq 0) or lmms eq 1 then goto, fadskipper  ;; skip saving zoomed image
      if (info.is_fragm eq 3) or (is_lmms eq 1) or (is_lm eq 1) or (is_acc eq 1) or (is_eucldist eq 1) then goto, fadskipper  ;; skip saving zoomed image
      
      ;; if in zoom mode offer to save the zoomed part of the image
      IF info.selsubregion_id EQ 1 THEN BEGIN
         msg = "Please select one of the two options:" + string(10b) + $
               'Yes: to save the current zoom region' + string(10b) + $
               ' No: to save the entire image' + string(10b) + $
               '(Note: potential statistics will be written' + string(10b) + $
               ' out only when saving the entire image)'
         szoom = dialog_message(msg, / question) EQ 'Yes'
      ENDIF
      
      ;; switch/loop to write out additional cost image as seen in the GUI
      savecost = 0
      costagain0:


      IF szoom EQ 1b THEN BEGIN ;; zoomed part
         fname = fname + '_zoom' 
         if info.is_dist eq 1 then begin
           if savecost eq 0 then image0 = * info.morphdist else image0 = * info.fr_image
         endif else if info.is_influ eq 3 then begin
           if prefix eq '_reconnect_' then begin
             image0 = * info.fr_image
           endif else begin           
             if savecost eq 0 then image0 = * info.cs22_nodes else image0 = * info.fr_image
           endelse
         endif else if info.is_contort gt 0 then begin
           image0 = * info.contort        
         endif else begin 
           image0 = * info.fr_image
         endelse
         if info.is_mspa eq 1 then savestats = 0                 
         x = info.x * info.resfac & y = info.y * info.resfac
         image0 = image0(x(0):x(1) + 1, y(0):y(1) + 1)
         image0 = rotate(image0, 7)
      ENDIF ELSE BEGIN  ;; full image
         if info.is_dist eq 1 then begin
          if savecost eq 0 then image0 = rotate( * info.morphdist, 7) else image0 = rotate( * info.fr_image, 7)
         endif else if info.is_influ eq 3 then begin
           if prefix eq '_reconnect_' then begin
            image0 = rotate( * info.fr_image, 7)
           endif else begin
             if savecost eq 0 then image0 = rotate( * info.cs22_nodes, 7) else image0 = rotate( * info.fr_image, 7)            
           endelse
         endif else if info.is_contort gt 0 then begin
          image0 = rotate( * info.contort, 7)        
         endif else begin 
          image0 = rotate( * info.fr_image, 7)
         endelse
      ENDELSE

      ;; get the current colors
      tvlct, r, g, b, / get
      dtype = info.dtypes(size(image0, / type))
      
      if savecost eq 1 then begin
        ;; write out the image as seen in the viewport
        z = strmid(im_file,0,strlen(im_file)-4) + '_viewport.tif' & fname_cost = z
        write_tiff, z, image0, red = r, green = g, blue = b, $
          geotiff = * info.geotiffinfo, description = desc, compression = 1
        ;write_png, z, image0, r, g, b, /order
        fnsaves = fnsaves + z + string(10b)
        goto,fin
      endif

      mcdchange = 0
      if strmid(info.title,0,20) eq 'Simple change (A->B)' then begin
        fname='simplechange' & mcdchange = 2
      endif
      if strmid(info.title,0,13) eq 'MCD (A->B) FG' then begin
        fname='morphdiff' & mcdchange = 1
      endif
      
      ;; ensure stuff is written out appropriately when saving in different formats
      if (info.is_fragm eq 3) or (is_lmms eq 1) or (is_lm eq 1) then begin  ;; write out FAD/FOS/LM/LMMS result
        fadskipper:        
        tit = 'Select the directory where your results will be saved'
        ;; pre-select the directory of the input file
        ss = file_dirname(info.fname_input)
        newfadname:
        dir_fad = $
          dialog_pickfile(get_path = path2file, / write, / directory,  $
          path = ss, title = tit )

        IF (strlen(dir_fad) - strlen(path2file) EQ 4) OR $
          (dir_fad EQ '') THEN GOTO, finall  ;; no name or 'cancel' selected

        ;; correct directory name if dominance_mscale
        if strmid(fname, 16,/rev) eq '_dominance_mscale' then fname = strmid(fname, 0, strlen(fname)-7)
        dir_test = dir_fad + fname + info.os_sep
        if is_fos ge 1 then dir_test = dir_fad + fdir + info.os_sep
        ;; check if the selected directory already exist
        tt = file_info(dir_test) & tt = tt.exists ;;; / overwrite_prompt,
        IF tt EQ 1b THEN BEGIN
          msg = 'A directory with the name "' + fname + '" already exists.' + $
            string(10b) + 'Please select: ' + $
            string(10b) + '(Yes) to overwrite the existing directory, or ' + $
            string(10b) + '(No) to make a new folder for your results.'
          res = dialog_message(msg, / question)
          IF res EQ 'No' THEN BEGIN
            tit = 'Click "Make New Folder" and give it a new name to define a directory where your results will be saved'
            GOTO, newfadname
          ENDIF
        ENDIF

        ;; ok, now save all FAD/FOS/LM/LMMS stuff
        ;;==================================================
        widget_control, / hourglass   
        file_mkdir, dir_test & pushd, dir_test
        
        ;; a) the fullres classified summary image
        ;; first save the visual summary result
          if (is_fos eq 0 and is_lm eq 0) then z = dir_test + fname + '_mscale.tif' else z = dir_test + fname + '.tif' 
          if is_lmms eq 1 then z = dir_test + fn_lmms + 'mscale.tif'
          if is_eucldist eq 1 then z = dir_test + fname + '_viewport.tif'
          if is_acc eq 1 then z = dir_test + fname + '.tif'
          image0 = rotate( * info.fr_image, 7)
        ;; get the current colors
        tvlct, r, g, b, / get
        
        if eventvalue eq 'save_generic' then begin ;; output tif
          if eventvalue2 eq 'save_generic_tif' then begin
            write_tiff, z, image0, red = r, green = g, blue = b, description = desc, compression = 1
          endif else begin
            if is_fos eq 0 then z = dir_test + fname + '_mscale.png' else z = dir_test + fname + '.png'
            if is_eucldist eq 1 then z = dir_test + fname + '_viewport.png'
            if is_acc eq 1 then z = dir_test + fname + '.png'
            write_png, z, image0, r, g, b, /order
          endelse        
        endif else begin ;; geotiff         
          write_tiff, z, image0, red = r, green = g, blue = b, description = desc, $
            geotiff = * info.geotiffinfo, compression = 1
        endelse                           
        fnsaves = fnsaves + z + string(10b)
        
        if is_acc eq 1 then begin
          ;; copy over the remaining accounting files into the resulting directory
          z = dir_test + fname + '.txt'
          file_copy, info.dir_tmp + 'acc.txt', z, /overwrite
          z = dir_test + fname + '.csv'
          file_copy, info.dir_tmp + 'acc.csv', z, /overwrite
          z = 'including respective statistic information'
          fnsaves = fnsaves + z + string(10b)
          ;; go back in stack
          popd
          res = dialog_message(fnsaves, / information)
          goto, finall         
        endif
              
                    
        ;;  b) the fullres classified and data images by scales
        ;; for LMMS
        ;;================
        if is_lmms eq 1 then begin
          has_miss=0
          res = file_info(info.dir_tmp + 'missing.sav')
          if res.exists eq 1 then begin
            restore,info.dir_tmp + 'missing.sav' & has_miss=1
          endif
          
          kstr = ['7', '13', '27', '81', '243']
          for isc = 0, 4 do begin
            ;; the actual data
            z = dir_test + fn_lmms + strtrim(kstr[isc],2)  + '.tif'
            openr, 1, info.dir_tmp + 'obs'+ strtrim(isc,2)+'_lm' & readu,1, image0 & close,1
            if has_miss eq 1 then image0[qmiss]=0b
            image0 = rotate(image0, 7)
            if eventvalue eq 'save_generic' then begin ;; output tif
              if eventvalue2 eq 'save_generic_tif' then begin
                write_tiff, z, image0, red = r, green = g, blue = b, description = desc, compression = 1
              endif else begin
                z = dir_test + fn_lmms + strtrim(kstr[isc],2)  + '.png'
                write_png, z, image0, r, g, b, /order
              endelse
            endif else begin ;; geotiff
              write_tiff, z, image0, red = r, green = g, blue = b, $
                geotiff = * info.geotiffinfo, description = desc, compression = 1
            endelse
            ;; the heatmap stuff
            z = dir_test + fn_lmms + strtrim(kstr[isc],2)  + '_heatmap.csv'
            file_copy, info.dir_tmp + 'obs'+ strtrim(isc,2)+'_heatmap.csv', z, /overwrite 
            z = dir_test + fn_lmms + strtrim(kstr[isc],2)  + '_heatmap.png'
            file_copy, info.dir_tmp + 'obs'+ strtrim(isc,2)+'_heatmap.png', z, /overwrite
            z = dir_test + fn_lmms + strtrim(kstr[isc],2)  + '_heatmap.sav'
            file_copy, info.dir_tmp + 'obs'+ strtrim(isc,2)+'_heatmap.sav', z, /overwrite
          endfor 
          
          if strmid(z,3,/reverse_offset) eq '.png' then $
            z = dir_test + fn_lmms + '[7,13,27,81,243].png' else z = dir_test + fn_lmms + '[7,13,27,81,243].tif'
          fnsaves = fnsaves + z + string(10b)
          z = 'including respective heatmap information'
          fnsaves = fnsaves + z + string(10b)
          
          ;; only now add the heatmap mscale stuff to not confuse the file extension above
          z = dir_test + fn_lmms + 'mscale_heatmap.csv' 
          file_copy, info.dir_tmp + 'heatmap.csv', z, /overwrite                      
          z = dir_test + fn_lmms + 'mscale_heatmap.png'
          file_copy, info.dir_tmp + 'heatmap.png', z, /overwrite
          z = dir_test + fn_lmms + 'mscale_heatmap.sav'
          file_copy, info.dir_tmp + 'heatmap.sav', z, /overwrite
          z = dir_test + 'heatmap_legend.png'
          file_copy, info.dir_guidossub + 'heatmap_legend.png', z, /overwrite
                   
          popd
          res = dialog_message(fnsaves, / information)
          goto, finall          
        endif      

        ;; for LM
        ;;================
        if is_lm eq 1 then begin
          ;; copy over the lm103class image
          z = dir_test + fname + '_103class.tif'
          ;; get the image from tmp and save it 
          close,1 & openr, 1, info.dir_tmp + 'lm103class'
          readu,1, image0 & close,1 & image0 = rotate(image0, 7)
                 
          if eventvalue eq 'save_generic' then begin ;; output tif
            if eventvalue2 eq 'save_generic_tif' then begin
              write_tiff, z, image0, description = desc, compression = 1
            endif else begin
              write_png, z, image0, /order
            endelse
          endif else begin ;; geotiff
            write_tiff, z, image0, description = desc, geotiff = * info.geotiffinfo, compression = 1
          endelse          
          fnsaves = fnsaves + z + string(10b)   
          
          ;; copy over stats and sav file 
          z = dir_test + fname + '_heatmap.sav'
          file_copy, info.dir_tmp + 'heatmap.sav', z, / overwrite
          fnsaves = fnsaves + z + string(10b)
          z = dir_test + fname + '_heatmap.csv'
          file_copy, info.dir_tmp + 'heatmap.csv', z, / overwrite
          fnsaves = fnsaves + z + string(10b)
          z = dir_test + fname + '_heatmap.png'
          file_copy, info.dir_tmp + 'heatmap.png', z, / overwrite
          fnsaves = fnsaves + z + string(10b)         
          z = dir_test + 'heatmap_legend.png'
          file_copy, info.dir_guidossub + 'heatmap_legend.png', z, /overwrite
          fnsaves = fnsaves + z + string(10b)
          
          ;; go back in stack
          popd
          res = dialog_message(fnsaves, / information)
          goto, finall
        endif

        
        ;; for FOS
        ;;================
        if is_fos ge 1 then begin
          ;; copy over the stats and sav file
          z = dir_test + fname + '.txt'
          file_copy, info.dir_tmp + 'fos.txt', z, / overwrite
          fnsaves = fnsaves + z + string(10b)
          z = dir_test + fname + '.csv'
          file_copy, info.dir_tmp + 'fos.csv', z, / overwrite
          fnsaves = fnsaves + z + string(10b)
          z = dir_test + fname + '.sav'
          file_copy, info.dir_tmp + 'fos.sav', z, / overwrite
          fnsaves = fnsaves + z + string(10b)
          ;; go back in stack
          popd
          res = dialog_message(fnsaves, / information)
          goto, finall                  
        endif 
 
        ;; for Eucldist
        ;;================
        if is_eucldist eq 1 then begin
          ;; add also the actual distance image
          image0 = rotate( * info.morphdist, 7)
          z = dir_test + fname + '.tif'
          if eventvalue eq 'save_generic' then begin ;; output tif or png always as tif because png can't do float
            write_tiff, z, image0, description = desc, compression = 1, /float
          endif else begin ;; geotiff
            write_tiff, z, image0, description = desc, geotiff = * info.geotiffinfo, compression = 1, /float
          endelse
          fnsaves = fnsaves + z + string(10b)
          
          ;; copy over the remaining dist files besides the viewport image
          z = dir_test + fname + '.txt'
          file_copy, info.dir_tmp + 'eucldist.txt', z, / overwrite
          fnsaves = fnsaves + z + string(10b)
          z = dir_test + fname + '_hist.png'
          file_copy, info.dir_tmp + 'barplot_dist.png', z, / overwrite
          fnsaves = fnsaves + z + string(10b)                   
          z = dir_test + fname + '_hmc.png'
          file_copy, info.dir_tmp + 'barplot_hmc.png', z, / overwrite
          fnsaves = fnsaves + z + string(10b)
          z = dir_test + fname + '_hmc.csv'
          file_copy, info.dir_tmp + 'dist_hmc.csv', z, / overwrite
          fnsaves = fnsaves + z + string(10b)
          z = dir_test + fname + '_hmc.txt'
          file_copy, info.dir_tmp + 'dist_hmc.txt', z, / overwrite
          fnsaves = fnsaves + z + string(10b)
          ;; go back in stack
          popd
          res = dialog_message(fnsaves, / information)
          goto, finall
        endif
               
        ;; for FAD
        ;;================
        scales = *info.mscale & kdim_str = ['7','13','27','81','243']   
        for isc = 0, 4 do begin
          ;; the actual data        
          z = dir_test + fname + '_' + strtrim(kdim_str[isc],2)  + '.tif'
          image0 = rotate(reform(scales[isc,*,*]), 7)
          if eventvalue eq 'save_generic' then begin ;; output tif
            if eventvalue2 eq 'save_generic_tif' then begin
              write_tiff, z, image0, red = r, green = g, blue = b, description = desc, compression = 1
            endif else begin
              z = dir_test + fname + '_' + strtrim(kdim_str[isc],2)  + '.png'
              write_png, z, image0, r, g, b, /order
            endelse
          endif else begin ;; geotiff
            write_tiff, z, image0, red = r, green = g, blue = b, $
              geotiff = * info.geotiffinfo, description = desc, compression = 1
          endelse         
        endfor
        scales = 0 & image0 = 0             
        if strmid(z,3,/reverse_offset) eq '.png' then $
          z = dir_test + fname + '_[7,13,27,81,243].png' else z = dir_test + fname + '_[7,13,27,81,243].tif'     
        fnsaves = fnsaves + z + string(10b)        

        ;; c) the statistics and the barplot
        z = dir_test + fname + '_mscale.txt'
        file_copy, info.dir_tmp + 'fadtable.txt', z, / overwrite
        fnsaves = fnsaves + z + string(10b)
        z = dir_test + fname + '_mscale.csv'
        IF (file_info(z)).exists EQ 1b THEN BEGIN
          close, 9 & openu, 9, z, error = error & close,9
        ENDIF ELSE BEGIN ;; file does not exist
          error = 0
        ENDELSE
        IF (error NE 0) then begin
          msg = 'Please close your spreadsheet application, then try again.' + $
            string(10b) + 'Returning...'
          res = dialog_message(msg, /information)
          goto, finall
        ENDIF        
        file_copy, info.dir_tmp + 'fadtable.csv', z, / overwrite                
        fnsaves = fnsaves + z + string(10b)
        z = dir_test + fname + '_mscale.sav'
        file_copy, info.dir_tmp + 'fad.sav', z, / overwrite
        fnsaves = fnsaves + z + string(10b)
        z = dir_test + fname + '_barplot.png'
        file_copy, info.dir_tmp + 'barplot.png', z, / overwrite
        fnsaves = fnsaves + z + string(10b)               

        ;; go back in stack
        popd
        res = dialog_message(fnsaves, / information)
        goto, finall
        
      endif else begin  ;; normal case: write out resulting files

        im_file = $
          dialog_pickfile(file = fname + '.tif', default_extension = 'tif', $
          filter = ['*.tif', '*.tiff'], / fix_filter, $
          / write, $
          get_path = path2file, / overwrite_prompt, $
          title = 'Select a GeoTiff-file to write', $
          path = info.dir_data)
        IF im_file EQ '' THEN GOTO, finall ;; 'cancel' selected

      endelse
     
      IF mcdchange EQ 1 then begin ;; MCD
        z = strmid(im_file,0,strlen(im_file)-4) + '.txt'
        file_copy, info.dir_tmp + 'mcd.txt', z , / overwrite
        fnsaves = fnsaves + z + string(10b)
      ENDIF

      IF mcdchange EQ 2 then begin ;; simple difference
        z = strmid(im_file,0,strlen(im_file)-4) + '.txt'
        file_copy, info.dir_tmp + 'sd.txt', z , / overwrite
        fnsaves = fnsaves + z + string(10b)
      ENDIF
      
      if info.is_influ eq 3 then begin
        z = strmid(im_file,0,strlen(im_file)-4) + '_CI.tif'
        if prefix eq '_reconnect_' then z = strmid(im_file,0,strlen(im_file)-4) + '_viewport.tif'
      endif else begin
        z = strmid(im_file,0,strlen(im_file)-4) + '.tif'        
      endelse
      

      IF szoom EQ 0b THEN BEGIN ;; fullres
        IF dtype EQ 'byte' then begin
            if info.ctbl ne 0 then $
              write_tiff, z, image0, red = r, green = g, blue = b, $
              geotiff = * info.geotiffinfo, description = desc, compression = 1 else $
              write_tiff, z, image0, geotiff = * info.geotiffinfo, description = desc, compression = 1
              if prefix eq '_reconnect_' then begin ;; add the reconnected path as binary image for MSPA-analysis
                lcp = where(image0 eq 80b,ct_lcp, /l64)
                imt = *info.orig_image & imt = rotate(imt, 7)
                if ct_lcp gt 0 then imt[lcp] = 2b
                ztmp = strmid(z,0,strlen(z)-4) + '4MSPA+NW.tif'
                write_tiff, ztmp, imt, geotiff = * info.geotiffinfo, description = desc, compression = 1                
                fnsaves = fnsaves + ztmp + string(10b)
              endif
              
        endif else begin
          if dtype EQ 'integer' or dtype EQ 'float' or dtype EQ 'long integer' or dtype EQ '64-bit integer' then begin 
            sig = 1 & descx = desc0
          endif else begin
            sig = 0 & descx = desc
          endelse                    
          write_tiff, z, image0, geotiff = * info.geotiffinfo, description = descx, compression = 1, signed=sig, $
                     float = dtype EQ 'float', $
                     short = dtype EQ 'integer', $
                     long = dtype EQ 'long integer', $
                     l64 = dtype EQ '64-bit integer'
        endelse
      ENDIF ELSE BEGIN ;; zoom and geotiff
         ;; 1) get the geotiff for the zoomed region with gdal
         ;; define gdal_translate
         IF info.my_os EQ 'windows' THEN BEGIN
            gtrans = info.windrive + ' & cd "' + info.dir_fwtools + '" & setfw.bat & '
            gtrans = gtrans + 'cd "' + info.dir_tmp + $
                     '" & gdal_translate -co ' + $
                     '"COMPRESS=LZW" -srcwin '
         ENDIF ELSE BEGIN ;; linux/apple
            if strlen(info.sysgdal) gt 0 then $
              gtrans = 'unset LD_LIBRARY_PATH; gdal_translate -co ' + '"COMPRESS=LZW" -srcwin ' else $
              gtrans = info.dir_fwtools + 'gdal_translate -co ' + '"COMPRESS=LZW" -srcwin '
         ENDELSE
         dx = x(1) - x(0) + 1 & dy = y(1) - y(0) + 1 & xoff = x(0)
         sy = (size( * info.fr_image, / dim))[1] & yoff = sy - y(1) - 2
         gtrans = gtrans + strtrim(xoff, 2) + ' ' + strtrim(yoff, 2) + $
                  ' ' + strtrim(dx, 2) + ' ' + strtrim(dy, 2) + ' ' + $
                  info.fname_input + ' ' + info.dir_tmp + 'tmpdat.tif'
         IF info.my_os EQ 'windows' THEN $
          spawn, gtrans, log, / hide ELSE spawn, gtrans, log

         ;; 2) final: copy the geoheader to the data:
         ;; final name: im_file
         imtmp = read_tiff(info.dir_tmp + 'tmpdat.tif', geotiff = geotiffz)
         file_delete, info.dir_tmp + 'tmpdat.tif', / quiet & imtmp = 0
         IF dtype EQ 'byte' then begin
           if info.ctbl ne 0 then $
            write_tiff, z, image0, red = r, green = g, blue = b, $
            geotiff = geotiffz, description = desc, compression = 1  else $
            write_tiff, z, image0, geotiff = geotiffz, description = desc, compression = 1
         endif else begin
         if dtype EQ 'integer' or dtype EQ 'float' or dtype EQ 'long integer' or dtype EQ '64-bit integer' then begin
           sig = 1 & descx = desc0
         endif else begin
           sig = 0 & descx = desc
         endelse                    
         write_tiff, z, image0, description = descx, compression = 1, geotiff = geotiffz, signed=sig,$
                   float = dtype EQ 'float', $
                   short = dtype EQ 'integer', $
                   long = dtype EQ 'long integer', $
                   l64 = dtype EQ '64-bit integer'
         endelse
      ENDELSE
      fnsaves = fnsaves + z + string(10b)
      fname = im_file
      
      savecost = 1
      if prefix eq '_reconnect_' then GOTO, fin
      ;;if (info.is_cost) or (info.is_dist) or (info.is_influ eq 3) then goto, costagain0
      if (info.is_dist) or (info.is_influ eq 3) then goto, costagain0

      GOTO, fin
   END

   'save_generic':BEGIN
      szoom = 0b
      ;; skip saving zoomed image for FAD, LMMS, FOS, dist
      if (info.is_fragm eq 3 and is_fos eq 0) or (is_lmms eq 1) or (is_lm eq 1) or (is_eucldist eq 1) then goto, fadskipper  
      if is_fos ge 1 then begin
        savecost = 0
        image0 = rotate( * info.fr_image, 7)
        goto, fosskipper
      endif

      ;; if in zoom mode offer to save the zoomed part of the image
      IF info.selsubregion_id EQ 1 THEN BEGIN
         msg = "Please select one of the two options:" + string(10b) + $
               'Yes: to save the current zoom region' + string(10b) + $
               ' No: to save the entire image' + string(10b) + $
               '(Note: potential statistics will be written' + string(10b) + $
               ' out only when saving the entire image)'
         szoom = dialog_message(msg, / question) EQ 'Yes'
      ENDIF
      
      ;; switch/loop to write out additional cost image as seen in the GUI 
      savecost = 0
      costagain:

      IF szoom EQ 1b THEN BEGIN ;; zoomed part
        fname = fname + '_zoom'
        if info.is_dist eq 1 then begin
          image0 = * info.morphdist
        endif else if info.is_influ eq 3 then begin
          if prefix eq '_reconnect_' then begin
            image0 = * info.fr_image
          endif else begin
            if savecost eq 0 then image0 = * info.cs22_nodes else image0 = * info.fr_image
          endelse
        endif else if info.is_contort gt 0 then begin
          image0 = * info.contort
        endif else begin
          image0 = * info.fr_image
        endelse
        if info.is_mspa eq 1 then savestats = 0 
        x = info.x * info.resfac & y = info.y * info.resfac
        image0 = image0(x(0):x(1) + 1, y(0):y(1) + 1)
        image0 = rotate(image0, 7)
      ENDIF ELSE BEGIN  ;; full image
        if info.is_dist eq 1 then begin
          image0 = rotate( * info.morphdist, 7)
        endif else if info.is_influ eq 3 then begin
          if prefix eq '_reconnect_' then begin
            image0 = rotate( * info.fr_image, 7)
          endif else begin
            if savecost eq 0 then image0 = rotate( * info.cs22_nodes, 7) else image0 = rotate( * info.fr_image, 7)
          endelse
        endif else if info.is_contort gt 0 then begin
          image0 = rotate( * info.contort, 7)
        endif else begin
          image0 = rotate( * info.fr_image, 7)
        endelse
      ENDELSE

      fosskipper:
      ;; get the current colors
      tvlct, r, g, b, / get 
      dtype = info.dtypes(size(image0, / type))
      
      if savecost eq 1 then begin
        ;; write out the iamge as seen in the viewport
        z = strmid(im_file,0,strlen(im_file)-4) + '.png'
        write_png, z, image0, r, g, b, /order      
        fnsaves = fnsaves + z + string(10b)
        goto,fin
      endif      
      
      mcdchange = 0
      if strmid(info.title,0,20) eq 'Simple change (A->B)' then fname='simplechange'
      if strmid(info.title,0,13) eq 'MCD (A->B) FG' then begin
        fname='morphdiff' & mcdchange = 1
      endif


      if eventvalue2 eq 'save_generic_tif' then begin ;; output tif
        im_file = $
          dialog_pickfile(file = fname + '.tif', default_extension = 'tif', $
          filter = ['*.tif', '*.tiff'], / fix_filter, / write, $
          get_path = path2file, / overwrite_prompt, $
          title = 'Select a tif-file to write', $
          path = info.dir_data)
          IF im_file EQ '' THEN GOTO, finall ;; 'cancel' selected
          fname_cost = im_file
      endif else begin  ;; output png
        image0 = rotate(image0,7)
        IF dtype EQ 'byte' THEN BEGIN
          res = dialog_write_image(image0, r, g, b, file = fname + '.png', $
            / warn_exist, type='png', /fix_type, path = info.dir_data, options = useropt)
          fnsaves = fnsaves + useropt.filename + string(10b)
        ENDIF ELSE BEGIN
          res = dialog_write_image(image0, file = fname + '.png', $
            / warn_exist, type='png', /fix_type, path = info.dir_data, options = useropt)
          fnsaves = fnsaves + useropt.filename + string(10b)
        ENDELSE
        IF res EQ 0 THEN GOTO, finall ;; 'cancel' selected
        IF mcdchange EQ 1 then begin
          z = useropt.filename
          z = strmid(z,0,strlen(z)-4) + '.txt'
          openw, 1, z
          printf, 1, info.title
          ;; get change MCD stats
          gain = total(image0 eq 12b) & gain = strtrim(ulong64(gain),2)
          loss = total(image0 eq 21b) & loss = strtrim(ulong64(loss),2)
          printf, 1, 'Gain [pixels]: ' + gain
          printf, 1, 'Loss [pixels]: ' + loss
          close, 1
          fnsaves = fnsaves + z + string(10b)
        ENDIF
        fname = useropt.filename     
        GOTO, fin 
      endelse


      IF szoom EQ 0b THEN BEGIN ;; fullres
        IF dtype EQ 'byte' THEN BEGIN
          if info.ctbl ne 0 then $
            write_tiff, im_file, image0, red = r, green = g, blue = b, description = desc, compression = 1 else $
            write_tiff, im_file, image0, description = desc, compression = 1      
        ENDIF ELSE BEGIN
          if dtype EQ 'integer' or dtype EQ 'long integer' or dtype EQ '64-bit integer' then sig=1 else sig=0
          write_tiff, im_file, image0, description = desc, compression = 1, signed=sig, $
            float = dtype EQ 'float', $
            short = dtype EQ 'integer', $
            long = dtype EQ 'long integer', $
            l64 = dtype EQ '64-bit integer'
        ENDELSE
      ENDIF ELSE BEGIN ;; zoom
        IF dtype EQ 'byte' then begin
          if info.ctbl ne 0 then $
            write_tiff, im_file, image0, red = r, green = g, blue = b, description = desc, compression = 1  else $
            write_tiff, im_file, image0, description = desc, compression = 1
        endif else begin
          if dtype EQ 'integer' or dtype EQ 'long integer' or dtype EQ '64-bit integer' then sig=1 else sig=0
          write_tiff, im_file, image0, description = desc, compression = 1, signed=sig,$
            float = dtype EQ 'float', $
            short = dtype EQ 'integer',  $
            long = dtype EQ 'long integer', $
            l64 = dtype EQ '64-bit integer'
        endelse
      ENDELSE
      fnsaves = fnsaves + im_file + string(10b)
      fname = im_file

      savecost = 1
      ;; if info.is_cost then goto, costagain

      IF mcdchange EQ 1 then begin
        z = strmid(im_file,0,strlen(im_file)-4) + '.txt'
        openw, 1, z
        printf, 1, info.title
        ;; get change MCD stats
        gain = total(image0 eq 12b) & gain = strtrim(ulong64(gain),2)
        loss = total(image0 eq 21b) & loss = strtrim(ulong64(loss),2)
        printf, 1, 'Gain [pixels]: ' + gain 
        printf, 1, 'Loss [pixels]: ' + loss         
        close, 1
        fnsaves = fnsaves + z + string(10b)
      ENDIF
      
      GOTO, fin  ;; go there to check if additional info should be written out
   END


   'save_kml':BEGIN
      ;; image must be geotiff and we need gdal2tiles
      IF info.is_geotiff NE 1b OR info.epsg ne '4326' THEN BEGIN
         msg = 'The export to kml (Google Earth image overlay) requires' + string(10b) + $
               'a GeoTiff-file in the projection EPSG 4326 (WGS84).' + string(10b) + $
               'The current file does not comply with these conditions.' + string(10b) + $
               string(10b) + $
               'To reproject your geotiff image you can use: ' + string(10b) + $
               "- General Tools -> Preprocessing -> Reproject for GoogleEarth" + string(10b) + $
               "- 'gdalwarp' in the GDAL terminal"  + string(10b) + 'Returning...'
         res = dialog_message(msg, / information) & GOTO, finall
      ENDIF
            
      if strmid(info.title,0,20) eq 'Simple change (A->B)' then fname='simplechange'
      if strmid(info.title,0,13) eq 'MCD (A->B) FG' then fname='morphdiff'
      fname = fname + '_kml'

      newkmlname:
      dir_kml = $
        dialog_pickfile(file = fname, get_path = path2file, $
        / write, / directory, path = info.dir_data, $
        title = 'kml output directory')
      IF (strlen(dir_kml) - strlen(path2file) EQ 4) OR $
        (dir_kml EQ '') THEN GOTO, finall  ;; no name or 'cancel' selected
        
      ;; fix a M$ bug
      IF info.my_os EQ 'windows' THEN dir_kml = dir_kml + fname + '\'
      ;; name of the archive
      showbg = 1 ;; default
      IF info.is_mspa EQ 1b OR info.is_fragm EQ 1b OR info.is_fragm EQ 3b THEN BEGIN
        msg = 'Display background in Google Earth overlay?' + string(10b) + $
          'Please select: Yes (default) or No'
        res = dialog_message(msg, / question)
        IF res EQ 'No' THEN BEGIN
          showbg = 0
          dir_kml = strmid(dir_kml,0,strlen(dir_kml)-4)+ 'noBG_kml' + info.os_sep
        ENDIF
      ENDIF

      ;; check if the zip of that directory already exist
      tt = strmid(dir_kml,0,strlen(dir_kml)-1) + '.zip'
      tt = file_info(tt) & tt = tt.exists ;;; / overwrite_prompt,
      IF tt EQ 1b THEN BEGIN
        msg = 'A zip archive with this name already exist.' + $
          string(10b) + 'Overwrite (Yes) or select new name (No)?'
        res = dialog_message(msg, / question)
        IF res EQ 'No' THEN GOTO, newkmlname
      ENDIF

      ;; ok, now save in kml
      image0 = * info.fr_image & image0 = rotate(temporary(image0), 7)
      mxx = max(image0)
      ;; get the current colors
      tvlct, r, g, b, / get

      ;; scale 0,1,2b images to make them show in GE
      IF ((mxx LT 6b) AND (info.autostretch_id EQ 1b)) THEN $
        image0 = bytscl(image0)
      widget_control, / hourglass
      
      IF showbg EQ 1 THEN BEGIN
        write_tiff, info.dir_tmp + 'GTB.tif', temporary(image0), $
          red = r, green = g, blue = b, description = desc, compression = 1, geotiff = * info.geotiffinfo
          GOTO, do_kml
      ENDIF
           
      ;; 1.) to NOT show the background:
      ;; save the file temporarily as aaa.tif in dir_tmp
      ;; without colors to NOT create an alpha channel!
      write_tiff, info.dir_tmp + 'a0.tif', temporary(image0), description = desc, compression = 1, geotiff = * info.geotiffinfo
               
      ;; 2) setup and then add appropriate color table
      openw, 1, info.dir_tmp + 'palette.txt'
      for i = 0, 255 do printf,1,i,r[i],g[i],b[i]
      close,1
      bgcol = '175' ;; for all map and fad fragmentation routines
      IF info.is_mspa EQ 1 THEN bgcol = '220'
        
      IF info.my_os EQ 'windows' THEN BEGIN
          cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdaldem color-relief "'
          cmd = cmd + info.dir_tmp + 'a0.tif"  "' + info.dir_tmp + 'palette.txt" "'
          cmd = cmd + info.dir_tmp + 'a1.tif"
          spawn, cmd, / hide        
          cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdalwarp -srcnodata ' + bgcol + ' -dstalpha "'
          cmd = cmd + info.dir_tmp + 'a1.tif" "' + info.dir_tmp + 'a2.tif"'
          spawn, cmd, / hide           
          cmd = 'cd "' + info.dir_fwtools + '" & setfw.bat & gdal_translate -co "COMPRESS=LZW" "'
          cmd = cmd + info.dir_tmp + 'a2.tif" "' + info.dir_tmp + 'GTB.tif"'
          spawn, cmd, / hide        
      ENDIF ELSE BEGIN
          IF info.my_os EQ 'linux' THEN prefix = file_dirname(info.sysgdal,/mark_directory) ELSE $
            prefix = info.dir_fwtools          
          prefix22 = '' & IF info.my_os EQ 'linux' THEN prefix22 = 'unset LD_LIBRARY_PATH; ' 
          cmd = prefix + prefix22 + 'gdaldem color-relief "'
          cmd = cmd + info.dir_tmp + 'a0.tif"  "' + info.dir_tmp + 'palette.txt" "'
          cmd = cmd + info.dir_tmp + 'a1.tif" 
          spawn, cmd, res
          cmd = prefix + prefix22 + 'gdalwarp -srcnodata ' + bgcol + ' -dstalpha "'
          cmd = cmd + info.dir_tmp + 'a1.tif" "' + info.dir_tmp + 'a2.tif"'
          spawn, cmd, res
          cmd = prefix + prefix22 + 'gdal_translate -co "COMPRESS=LZW" "'
          cmd = cmd + info.dir_tmp + 'a2.tif" "' + info.dir_tmp + 'GTB.tif"'
          spawn, cmd, res
      ENDELSE

      ;; 3) do the tiling
      do_kml:
        resfile = info.dir_tmp + 'GTB.tif'
        out = QUERY_TIFF(resfile,reskml,GEOTIFF=geo)
        tp = geo.ModelTiePointTag[3:4]
        xOrigin = tp[0] & yOrigin = tp[1]
        xscale  = geo.ModelPixelScaleTag[0]
        yscale  = geo.ModelPixelScaleTag[1]
        xEnd = xOrigin + (xscale * reskml.dimensions[0])
        yEnd = yOrigin - (yscale * reskml.dimensions[1])
        ULx = xOrigin & LRx = xEnd
        ULy = yOrigin & LRy = yEnd
        Cx = xOrigin + (xscale * reskml.dimensions[0])*0.5
        Cy = yOrigin - (yscale * reskml.dimensions[1])*0.5

        GE_load = info.dir_tmp + 'GTB.kml'
        openw, 1, GE_load
        printf,1,'<?xml version="1.0" encoding="UTF-8"?>'
        printf,1,'<kml xmlns="http://earth.google.com/kml/2.2">'
        printf,1,'<GroundOverlay>'
        printf,1,' <name>',file_basename(resfile,'.tif'),'</name>'
        printf,1,'  <description>Overlay produced by GuidosToolbox</description>'
        printf,1,'  <LookAt>'
        printf,1,'    <longitude>',Cx,'</longitude>'
        printf,1,'    <latitude>',Cy,'</latitude>'
        printf,1,'    <range>300000</range>'
        printf,1,'    <tilt>0.0</tilt>'
        printf,1,'    <heading>0.0</heading>'
        printf,1,'  </LookAt>'
        printf,1,'  <color>fcffffff</color>'
        printf,1,'  <Icon>'
        printf,1,'   <href>','./'+file_basename(resfile,'.tif')+'.tif','</href>'
        printf,1,'  </Icon>'
        printf,1,'  <LatLonBox id="JRC-GuidosToolbox">'
        printf,1,'    <north>',ULy,'</north>'
        printf,1,'    <south>',LRy,'</south>'
        printf,1,'    <east>',LRx,'</east>'
        printf,1,'    <west>',ULx,'</west>'
        printf,1,'  </LatLonBox>'
        printf,1,'</GroundOverlay>'
        printf,1,'</kml>'
        close,1

      ;; add mspa stuff if mspa image
      IF info.is_mspa EQ 1 THEN BEGIN
        file_mkdir, info.dir_tmp + file_basename(dir_kml)        
        file_copy, info.dir_guidossub + 'legend.png', $
          info.dir_tmp + file_basename(dir_kml) + $
          info.os_sep + 'legend.png', / overwrite

        ;; write the customized GE-header
        fn_kml = info.dir_tmp + file_basename(dir_kml) + info.os_sep + 'MSPA_GTB.kml'
        file_copy, info.dir_guidossub + 'GEheader.txt', fn_kml, / overwrite

        ;; add the rest from the GTB.kml
        fn_doc = GE_load
        ll_nr = file_lines(fn_doc) & ll = strarr(ll_nr)
        openr, 1, fn_doc & readf, 1, ll & close, 1
        openw, 1, fn_kml, / append
        FOR i = 2, ll_nr - 2 DO printf, 1, ll(i)
        printf,1,'</Document>'
        printf,1,'</kml>'
        close, 1
      ENDIF

      ;; add FAD stuff if FAD image
      IF info.is_fragm eq 3 THEN BEGIN
        file_mkdir, info.dir_tmp + file_basename(dir_kml)
        ;; determine FAD-legend to be used
        st = 'FAD1legend.png'
        IF mxx EQ 105b THEN st = 'FAD2legend.png'
        IF mxx EQ 106b THEN st = 'FAD3legend.png'         
        if is_fos eq 4 or is_fad eq 2 then st = 'fadapp2legend.png'       
        if is_fos eq 5 or is_fad eq 5  then st = 'fadapp5legend.png'
        
        file_copy, info.dir_guidossub + st, $
          info.dir_tmp + file_basename(dir_kml) + $
          info.os_sep + 'legend.png', / overwrite

        ;; write the customized GE-header
        if is_fos eq 0 then begin
          fn_kml = info.dir_tmp + file_basename(dir_kml) + info.os_sep + 'FAD_GTB.kml'
          file_copy, info.dir_guidossub + 'FADheader.txt', fn_kml, / overwrite
        endif else begin
          fn_kml = info.dir_tmp + file_basename(dir_kml) + info.os_sep + 'FOS_GTB.kml'
          file_copy, info.dir_guidossub + 'FOSheader.txt', fn_kml, / overwrite         
        endelse

        ;; add the rest from the GTB.kml
        fn_doc = GE_load
        ll_nr = file_lines(fn_doc) & ll = strarr(ll_nr)
        openr, 1, fn_doc & readf, 1, ll & close, 1
        openw, 1, fn_kml, / append
        FOR i = 2, ll_nr - 2 DO printf, 1, ll(i)
        printf,1,'</Document>'
        printf,1,'</kml>'
        close, 1
      ENDIF


      ;; 4) pack the output & clean up
      pushd, info.dir_tmp
      zdir = file_basename(dir_kml)
      file_mkdir, zdir
      file_move, resfile, zdir,/overwrite
      file_move, GE_load, zdir,/overwrite
      ;; info.is_mspa: 1 (MSPA), 3 (FOS/FAD) they have their custom kml-file with legend
      ;; because of this we can delete the generic kml-file
      IF info.is_mspa EQ 1 OR info.is_fragm EQ 3 THEN $ ;;; OR info.is_fragm EQ 1 (entropy) was there but why?
        file_delete, zdir + info.os_sep + file_basename(GE_load)
      
      file_zip, zdir
      ;; move it to the selected location  
      resdir = file_dirname(dir_kml, / mark_directory) + zdir
      reszip = resdir + '.zip'
      resload = file_basename(GE_load)
      IF info.is_mspa EQ 1 OR info.is_fragm eq 3 THEN resload = file_basename(fn_kml)   
      
      file_move, zdir + '.zip', reszip, / overwrite
      file_delete, info.dir_tmp + zdir, /recursive, / quiet
      
      ;; do not empty the temdir as there maybe sav-files which are needed to restore stuff
      ;;list = file_search() & nl = n_elements(list)
      ;;if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
      popd

      ;; echo instructions
      msg = 'KML export successful.' + string(10b) + $
        'To visualize the GoogleEarth overlay: '+ string(10b) + $
        '1) EXTRACT the archive: ' + reszip + string(10b) + $
        '2) Open the directory: ' + resdir + string(10b) + $
        '3) Double-click the file: ' + resload 
      res = dialog_message(msg, / information)
      GOTO, finall
    END

ENDCASE


;; flip image vertically
image0 = rotate(temporary(image0), 7)

;; the datatype and number of layers
info.datatype = info.dtypes(size(image0, / type))
CASE size(image0, / n_dim) OF
   2:info.datalayers = 1
   3:info.datalayers = 3
   ELSE: info.datalayers = 0
ENDCASE

;;

;; data range
mi = min(image0, max = mx, / nan)
* info.data_min = mi & * info.data_max = mx
info.disp_range_id = 0b
info.prev_disp_range_id = info.disp_range_id

;; original image
* info.orig_image = image0
;; test for empty spaces in filename
IF strpos(image_title,' ') GT 0 THEN BEGIN
  msg = 'Please do NOT use empty spaces in directory path or input filename.' + string(10b) + 'Exiting.'
  res = dialog_message(msg, / information)
  GOTO, finall
ENDIF 
info.orig_image_title = image_title

s = size(image0)
;; max-display on screen, keep the rescale factor as integer
xf = fix((float(s(1)) / info.screen_size(0) * 1.4) * 10) / 10.0
yf = fix((float(s(2)) / info.screen_size(1) * 1.4) * 10) / 10.0
info.resfac = ceil(xf > yf) > 1
info.bigim = info.resfac GT 1

;; create a draw widget sized to the (resized) image
widget_control, info.w_drawbase, map = 0
widget_control, info.w_draw, / destroy
* info.fr_image = image0
IF info.bigim THEN BEGIN
   image0 = $
    congrid(temporary(image0), s(1) / info.resfac, s(2) / info.resfac)
   s = size(image0)
ENDIF

;; update the info structure
;; set autostretch only for fomask else 0b
info.autostretch_id = (max(image0) LE 100b)
;; no autostretch in these cases: 
if (size(newimis_fad))[2] eq 1 OR (size(newimis_fos))[2] eq 1 OR (size(newimis_lm))[2] eq 1 $
  OR (size(newimis_p222))[2] eq 1 OR (size(newimis_disres))[2] eq 1 OR (size(newimis_res))[2] $
  then info.autostretch_id = 0


info.prev_autostretch_id = info.autostretch_id
* info.image0 = image0
* info.process = * info.image0
* info.prezoomprocess = * info.image0
* info.subimage = * info.image0
info.title = image_title
info.xsize = s(1)
info.ysize = s(2)

;; update the draw widget and enable button and motion events now
;; after having an input image
info.w_draw = $
 widget_draw(info.w_drawbase, xsize = info.xsize, ysize = info.ysize, $
             retain = 2, / motion_events)
widget_control, info.w_draw, / realize
widget_control, info.w_draw, get_value = draw_ID & info.draw_ID = draw_ID
widget_control, info.w_drawbase, map = 1
widget_control, info.w_rdpx, set_value = 'Move cursor in display to read out location and value.'

;; resize the draw widget if necessay and update the titlebar
;widget_control, info.w_draw, draw_xsize = info.xsize, draw_ysize =
;info.ysize
widget_control, info.TLB, tlb_set_title = info.orig_image_title

;; display the single image or the first(or current) image from the
;; list in the draw AND zoomwindow!! and make the draw widget window
;; the current graphics window
widget_control, info.w_disp_colors, set_combobox_select = info.disp_colors_id, sensitive=1

IF info.ctbl GE 0 THEN loadct, info.ctbl, / silent

;;IF info.fullres EQ 1 THEN info.zoomfactor = 1 ELSE info.zoomfactor = 2

;; when reading a new image
IF strmid(fileaction,0,4) EQ 'read' THEN BEGIN
   info.is_mspa = 0 & info.is_fragm = 0 & info.is_contort = 0 & info.is_dist = 0 & info.is_cs22 = 0 
   info.is_nw = 0 & info.is_nwconnect = 0 & info.is_cost = 0 & info.is_influ = 0 & info.add_title = '' & *info.extra = 0
   info.mspa_stats_show = 0b & info.do_mspa_stats_id = 0  & info.disp_range_id = 0 
   ;; test for original MSPA image
   if (size(newimis_mspa))[2] eq 1 then begin
     ;; extract and set MSPA settings
     z=strsplit(newimis_mspa, '_', /extract, count=zn)
     if zn eq 4 then begin 
       m4=fix(z[zn-1]) & m3=fix(z[zn-2]) & m2=z[zn-3] & m1=fix(z[zn-4])  
       info.mspa_param1_id = (m1 eq 8) & info.mspa_param3_id = m3 & info.mspa_param4_id = m4 
       widget_control, info.w_mspa_param1, set_value = info.mspa_param1_id
       widget_control, info.w_mspa_param3, set_value = info.mspa_param3_id
       widget_control, info.w_mspa_param4, set_value = info.mspa_param4_id
       widget_control, info.w_mspa_param2, set_combobox_select = 0, sensitive = 1
       widget_control, info.w_mspa_param2, set_value = [m2,'1','2','3','4','5','6','7','8','9','10']
       info.mspa_stats_show = 0b & info.is_mspa = 1 & info.mspa_size_current = m2   
       info.disp_colors_id = 3 & info.ctbl = - 1 & info.autostretch_id = 0 
       IF info.mspa_param3_id EQ 1b THEN $
         restore, info.dir_guidossub + 'mspacolorston.sav' ELSE $
         restore, info.dir_guidossub + 'mspacolorstoff.sav'
       tvlct, r, g, b      
     endif
   endif
   
   widget_control, info.w_zoomfac, / sensitive
   ;; clean up potential tmp sav-files
   ;; empty dir_tmp
   pushd,info.dir_tmp
   list = file_search() & nl = n_elements(list)
   if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
   popd   
   file_delete, info.dir_guidossub + 'contorttmp.sav', / allow_nonexistent, / quiet
   file_delete, info.dir_guidossub + 'fragmtmp.sav', / allow_nonexistent, / quiet
   file_delete, info.dir_guidossub + 'influ.sav', / allow_nonexistent, / quiet
   ;; backup original colortable
   origstretch = info.autostretch_id
   save, r,g,b,origstretch, filename = info.dir_tmp2 + 'origcolors.sav'
ENDIF

wset, info.pix_ID & guidos_image, * info.process, info.autostretch_id
wset, info.draw_ID & guidos_image, * info.process, info.autostretch_id

;; enable processing etc buttons
widget_control, info.w_lp11, / sensitive
widget_control, info.w_lp12, / sensitive
widget_control, info.w_label, sensitive = info.is_mspa OR info.is_fragm or info.is_dist or info.is_cost or info.is_contort eq 1 or info.is_influ gt 0
widget_control, info.w_lp1222, sensitive = info.is_mspa
widget_control, info.w_pa_connectivity1, sensitive = info.is_mspa
widget_control, info.w_pa_connectivity2, sensitive = info.is_nw
widget_control, info.w_pa_connectivity20, sensitive = info.is_nw
widget_control, info.w_pa_connectivity3, sensitive = info.is_nw
widget_control, info.w_sgeotiff, sensitive = info.is_geotiff
IF info.mspa_stats_show EQ 0b THEN widget_control, info.w_mspa_stats, set_value = transpose(replicate('n/a', 14, 2))
widget_control, info.w_do_mspa_stats, set_value = info.do_mspa_stats_id
widget_control, info.w_tools, / sensitive
widget_control, info.w_pa, / sensitive
widget_control, info.w_autostretch, / sensitive, set_value = info.autostretch_id
widget_control, info.w_file_save, / sensitive
widget_control, info.w_pa_morph, / sensitive
widget_control, info.w_batch, / sensitive
widget_control, info.w_disp_range, set_value = info.disp_range_id
widget_control, info.w_c2b, sensitive = info.datatype NE 'byte'
widget_control, info.w_c2i, sensitive = info.datatype NE 'integer'
widget_control, info.w_c2l, sensitive = info.datatype NE 'long integer'
widget_control, info.w_c2s, sensitive = info.datalayers EQ 3
condition = info.is_mspa EQ 0 OR info.is_contort EQ 0 OR info.is_nw EQ 0 OR info.is_cost eq 0 OR $
  info.is_dist EQ 0 OR info.is_influ EQ 0 AND (info.epsg NE '4326' AND info.is_geotiff EQ 1)
widget_control, info.w_c2ge, sensitive = condition EQ 1
widget_control, info.w_recode, sensitive = info.datatype EQ 'byte'

;; center the tlb
;;centertlb, info.tlb


fin:
;; when saving check if addional output should be written out
IF strmid(fileaction, 0, 4) EQ 'save' THEN BEGIN
   fname0 = fname
   
   IF is_spa gt 0 THEN begin
     pp = strpos(fname0, '.', / reverse_search) & fnbase = fname0
     IF pp GT 0 THEN fnbase = strmid(fname0, 0, pp)
     fname = fnbase + '.txt' & path = info.dir_data
     IF n_elements(path2file) GT 0 THEN path = path2file
     fx = info.dir_tmp + 'spa' + strtrim(is_spa,2) + '.txt'
     res = file_info(fx) & res = res.exists
     IF res EQ 1b THEN file_copy, fx, fname, /overwrite
     fnsaves = fnsaves + fname + string(10b)
     res = dialog_message(fnsaves, / information)
     goto,finall
   endif 
   
   IF is_fos ge 1 THEN begin
     pp = strpos(fname0, '.', / reverse_search) & fnbase = fname0
     IF pp GT 0 THEN fnbase = strmid(fname0, 0, pp)
     fname = fnbase + '.txt' & path = info.dir_data
     IF n_elements(path2file) GT 0 THEN path = path2file
     fx = info.dir_tmp + 'fos.txt'
     res = file_info(fx) & res = res.exists
     IF res EQ 1b THEN file_copy, fx, fname, /overwrite
     fnsaves = fnsaves + fname + string(10b)
     fname = fnbase + '.csv'
     fx = info.dir_tmp + 'fos.csv'
     res = file_info(fx) & res = res.exists
     IF res EQ 1b THEN file_copy, fx, fname, /overwrite
     fnsaves = fnsaves + fname + string(10b)
     res = dialog_message(fnsaves, / information)
     goto,finall
   endif
      
   IF info.is_dist GT 0 AND info.selsubregion_id  ne 1 THEN begin  ;; only go here when NOT in zoom mode
     pp = strpos(fname0, '.', / reverse_search) & fnbase = fname0
     IF pp GT 0 THEN fnbase = strmid(fname0, 0, pp)
     fname = fnbase + '.txt' & path = info.dir_data
     IF n_elements(path2file) GT 0 THEN path = path2file   
     res = file_info(info.dir_tmp + 'eucldist.txt') & res = res.exists
     IF res EQ 1b THEN file_copy, info.dir_tmp + 'eucldist.txt', fname, /overwrite
     fnsaves = fnsaves + fname + string(10b)
     res = file_info(info.dir_tmp + 'barplot_dist.png') & res = res.exists
     IF res EQ 1b THEN BEGIN
       fx = fnbase + '_hist.png'
       file_copy, info.dir_tmp + 'barplot_dist.png', fx,/overwrite
       fnsaves = fnsaves + fx + string(10b)
       fx = fnbase + '_hmc.png'
       file_copy, info.dir_tmp + 'barplot_hmc.png', fx,/overwrite
       fnsaves = fnsaves + fx + string(10b)     
     ENDIF     
   ENDIF
   
   IF prefix eq '_reconnect_' THEN BEGIN
     pp = strpos(fname0, '.', / reverse_search) & fnbase = fname0
     IF pp GT 0 THEN fnbase = strmid(fname0, 0, pp)
     z = fnbase + '.txt'
     tt = strmid(info.add_title,14) & q = strpos(tt,';')     
     openw,1, z
     printf, 1, 'Reconnect statistics: ' 
     printf, 1, 'CoreZone: ' + strtrim(info.label_t1,2) + ', ' + strmid(tt,0,q)  ;; info on # of FG or Core objects
     printf, 1, 'FG-resistance: 1, BG-resistance: ' + strtrim(info.label_t2,2)
     q = strpos(tt, 'RestorePixels: ') 
     if q gt 0 then begin ;; A reconnect path was defined
       q = strmid(tt,q) & q = strmid(q,0,strlen(q)-1)
       printf, 1, q    
       ll = file_lines(info.dir_tmp+'recondetails.txt') 
       tt=strarr(ll)
       close,5 & openr, 5, info.dir_tmp+'recondetails.txt'
       readf, 5, tt & close, 5
       for id = 0, ll-1 do printf, 1, tt[id]
     endif
     close, 1
     fnsaves = fnsaves + z + string(10b)   
   ENDIF
   
   IF info.is_influ GT 0 THEN begin      
       ;; accounting: write out stats
       if info.is_influ eq 2 then begin
         if strmid(fname0,8,6,/reverse) ne '_zoom.' then begin
           ;; a) write out stats only if full image is saved
           z = strmid(fname0,0,strlen(fname0)-4) + '.txt'
           file_copy, info.dir_tmp + 'acc.txt', z, /overwrite
           fnsaves = fnsaves + z + string(10b)
           z = strmid(fname0,0,strlen(fname0)-4) + '.csv'
           file_copy, info.dir_tmp + 'acc.csv', z, /overwrite
           fnsaves = fnsaves + z + string(10b)
         endif
         ;; ask if additional images are wanted
         msg = 'Save: Stats + viewport image only (Yes), or ' + string(10b) + $
          'add images showing IDs and area per IDs? (No)' 
         res = dialog_message(msg, / question)
         if res eq 'Yes' then begin
           res = dialog_message(fnsaves, / information)
           GOTO, finall
         endif
       endif
          
       pp = strpos(fname0, '.', / reverse_search) & fnbase = fname0
       IF pp GT 0 THEN fnbase = strmid(fname0, 0, pp)
       imfilebase = fnbase + '_ids'      
       imfilebase3 = fnbase + '_ws'  ;; additional output of watershed distances
       path = info.dir_data
       IF n_elements(path2file) GT 0 THEN path = path2file
       image0 = * info.nw_ids
       IF info.is_influ eq 3 and prefix eq '_proximity_' then begin
        image3 = * info.nw_conns * (image0 eq -3)
        
        fx = info.title & pp = strpos(fx, '.', / reverse_search)
        IF pp GT 0 THEN fx = strmid(fx, 0, pp)
        fx = fx + prefix + strtrim(fix(info.mspa_size_current),2)+ $
          '_' + strtrim(info.label_t1,2) + '_' + strtrim(info.label_t2,2)+'.csv'        
        fx = info.dir_tmp + fx ;; fx is in mspatmp, which should be unknown to the user so he can not open this file            
        fname = fnbase + '.csv' & res = file_info(fname)
        IF res.exists EQ 1 THEN BEGIN ;; does exist, check if it is open
          close,9 & openu, 9, fname, error=error & close,9
          IF (error NE 0) then begin
            msg = 'Please close your spreadsheet application, then try again.' + $
              string(10b) + 'Returning...'
            res = dialog_message(msg, /information)
            goto, fin
          ENDIF          
        ENDIF
        file_copy, fx, fname,/overwrite
        fnsaves = fnsaves + fname + string(10b)
       ENDIF
       zstep=0
       doitagain0:
       
       IF szoom EQ 1b THEN BEGIN ;; zoomed image
         x = info.x * info.resfac & y = info.y * info.resfac
         image0 = image0(x(0):x(1) + 1, y(0):y(1) + 1)
         image0 = rotate(image0, 7)
         IF info.is_influ eq 3 and prefix eq '_proximity_' then begin
           image3 = image3(x(0):x(1) + 1, y(0):y(1) + 1)
           image3 = rotate(image3, 7)
         ENDIF
       ENDIF ELSE BEGIN  ;; fullres image
         image0 = rotate(image0, 7)
         IF info.is_influ eq 3 and prefix eq '_proximity_' then image3 = rotate(image3, 7)
       ENDELSE

       ;; no geotiff
       IF info.is_geotiff EQ 0b THEN BEGIN
         write_tiff, imfilebase + '.tif', image0, /long, /signed, description = desc, compression = 1
         fnsaves = fnsaves + imfilebase + '.tif' + string(10b)
         IF info.is_influ eq 3 then begin
          write_tiff, imfilebase3 + '.tif', image3, /long, description = desc, compression = 1
          fnsaves = fnsaves + imfilebase3 + '.tif' + string(10b)
         endif
       ENDIF ELSE BEGIN ;; we have geotiff info
         IF szoom EQ 0b THEN BEGIN
           write_tiff, imfilebase + '.tif', image0, $
             geotiff = * info.geotiffinfo, /long, /signed, description = desc, compression = 1
             fnsaves = fnsaves + imfilebase + '.tif' + string(10b)
           IF info.is_influ eq 3 and prefix eq '_proximity_' then begin
            write_tiff, imfilebase3 + '.tif', image3, $
             geotiff = * info.geotiffinfo, /long, description = desc, compression = 1
             fnsaves = fnsaves + imfilebase3 + '.tif' + string(10b)
           endif
         ENDIF ELSE BEGIN ;; zoom and geotiff
           ;; 1) get the geotiff for the zoomed region with gdal
           ;; define gdal_translate
           IF info.my_os EQ 'windows' THEN BEGIN
             gtrans = info.windrive + ' & cd "' + info.dir_fwtools + '" & setfw.bat & '
             gtrans = gtrans + 'cd "' + info.dir_tmp + $
               '" & gdal_translate -co ' + $
               '"COMPRESS=LZW" -srcwin '
           ENDIF ELSE BEGIN ;; linux/apple
             if strlen(info.sysgdal) gt 0 then $
              gtrans = 'unset LD_LIBRARY_PATH; gdal_translate -co ' + '"COMPRESS=LZW" -srcwin ' else $
              gtrans = info.dir_fwtools + 'gdal_translate -co ' + '"COMPRESS=LZW" -srcwin '
           ENDELSE
           dx = x(1) - x(0) + 1 & dy = y(1) - y(0) + 1 & xoff = x(0)
           sy = (size( * info.nw_ids, / dim))[1] & yoff = sy - y(1) - 2
           gtrans = gtrans + strtrim(xoff, 2) + ' ' + strtrim(yoff, 2) + $
             ' ' + strtrim(dx, 2) + ' ' + strtrim(dy, 2) + ' ' + $
             info.fname_input + ' ' + info.dir_tmp + 'tmpdat.tif'
           IF info.my_os EQ 'windows' THEN $
             spawn, gtrans, log, / hide ELSE spawn, gtrans, log

           ;; 2) final: copy the geoheader to the data:
           ;; final name: im_file
           imtmp = read_tiff(info.dir_tmp + 'tmpdat.tif', geotiff = geotiffz)
           file_delete, info.dir_tmp + 'tmpdat.tif', / quiet & imtmp = 0
           write_tiff, imfilebase + '.tif', image0, description = desc, $
             compression = 1, geotiff = geotiffz, /long, /signed
             fnsaves = fnsaves + imfilebase + '.tif' + string(10b)
           IF info.is_influ eq 3 and prefix eq '_proximity_' then begin
            write_tiff, imfilebase3 + '.tif', image3, description = desc, $
             compression = 1, geotiff = geotiffz, /long
             fnsaves = fnsaves + imfilebase3 + '.tif' + string(10b)
           endif            
         ENDELSE
       ENDELSE
       if info.is_influ eq 2 and zstep eq 0 then begin       
        ;; b) 
        zstep=1 & image0 = * info.nw_conns & imfilebase = fnbase + '_pixels' & goto, doitagain0
       endif   
   ENDIF
   
   ;;  add fragm info file
   IF (info.is_fragm eq 1) then begin
     pp = strpos(fname0, '.', / reverse_search) & fnbase = fname0
     IF pp GT 0 THEN fnbase = strmid(fname0, 0, pp)
     fname = fnbase + '.txt' & path = info.dir_data
     IF n_elements(path2file) GT 0 THEN path = path2file
     IF info.is_fragm then a = 'Fragmentation '
     IF info.is_cost then a = 'Cost '
      
     openw, 1, fname
     printf, 1, a + 'summary: '
     printf, 1, info.title + info.add_title
     if info.do_label_groups_id eq 1b then begin
      ;; add info on current threshold settings for s,m,l
      printf, 1, a + 'range divided into: '
      printf, 1, 'small < ',strtrim(info.label_t1,2),' medium ',strtrim(info.label_t2,2),' > large'      
     endif
     close, 1
     fnsaves = fnsaves + fname + string(10b)
   endif
    
   ;; if mspa_stats is displayed then save the results to a txt-file
   IF info.mspa_stats_show EQ 1 AND savestats eq 1 THEN BEGIN
      pp = strpos(fname0, '.', / reverse_search) & fnbase = fname0
      IF pp GT 0 THEN fnbase = strmid(fname0, 0, pp)
      fname = fnbase + '.txt' & path = info.dir_data
      IF n_elements(path2file) GT 0 THEN path = path2file
      row_lab = $
        ['CORE(s) [green]', 'CORE(m) [green]', 'CORE(l) [green]', 'ISLET [brown]', 'PERFORATION [blue]', $
        'EDGE [black]', 'LOOP [yellow]', 'BRIDGE [red]', 'BRANCH [orange]', 'Background [grey]', $
        'Missing [white]', 'Opening [grey]', 'Core-Opening [darkgrey]', 'Border-Opening [grey]']
      openw, 1, fname
      printf, 1, 'MSPA results using: '
      printf, 1, info.title + info.add_title
      printf, 1, ' '
      ;; add info on thresholds if those are active      
      IF info.do_label_groups_id EQ 1 THEN BEGIN
        printf, 1, 'CORE(s)  <  ' + strtrim(info.label_t1,2) + ' CORE(m)  <  ' + strtrim(info.label_t2,2) + ' CORE(l)'
      ENDIF
      ;; write a tile line
      printf, 1, '   MSPA-class [color]:  FG/data pixels [%]  #/BGarea'
      printf, 1, '============================================================'
      ;; get the statistics & write them out
      widget_control, info.w_mspa_stats, get_value = st
      FOR idx = 0, n_elements(row_lab) - 1 DO $
                printf, 1, format = '(a24,a15,a5,a)', row_lab(idx) + ':  ', st(0, idx), '', st(1, idx)
      close, 1
      fnsaves = fnsaves + fname + string(10b)
   ENDIF

   ;; write out the nwconnect stats
   ;;=====================================================
   IF (info.is_nwconnect EQ 1) AND (szoom EQ 0b) THEN BEGIN
     ;; copy the statistics from tmp
     pp = strpos(fname0, '.', / reverse_search) & fnbase = fname0
     IF pp GT 0 THEN fnbase = strmid(fname0, 0, pp)
     fname = fnbase + '.csv' & path = info.dir_data
     IF n_elements(path2file) GT 0 THEN path = path2file
     file_copy, info.dir_tmp + 'compconnect_tmp.csv', fname, / overwrite
     fnsaves = fnsaves + fname + string(10b)
   ENDIF
   
   ;; write out the Restoration Planner stats
   ;;=====================================================
   IF (is_restore EQ 1) AND (szoom EQ 0b) THEN BEGIN
     ;; copy the statistics and individual files from tmp to a new directory in dir_data
     path = info.dir_data & IF n_elements(path2file) GT 0 THEN path = path2file
     ;; change setup to write all out into a new directory
     tt = file_basename(fname0)
     pp = strpos(tt, '.', / reverse_search) & IF pp GT 0 THEN tt = strmid(tt, 0, pp)
     newdir = path + tt + info.os_sep & file_mkdir, newdir
      
     ;; move the summary file
     file_move, fname0, newdir + file_basename(fname0),/overwrite
     fname0 = newdir + file_basename(fname0)
     pp = strpos(fname0, '.', / reverse_search) & fnbase = fname0
     IF pp GT 0 THEN fnbase = strmid(fname0, 0, pp)
     fname = fnbase + '.csv'
      
     pushd, info.dir_tmp
     tmpfile = file_search('*restoration*.csv') & tmpfile = tmpfile[0]
     tmpfile2 = file_search('*restoration*.tif')
     popd

     ;; save the restoration stats: check if the csv-file exists, then remove it first
     res = (file_info(fname)).exists EQ 1b
     IF res THEN BEGIN
       close, 9 & openu, 9, fname, error = error & close,9
     ENDIF ELSE BEGIN ;; file does not exist
       error = 0
     ENDELSE
     if error ne 0 then begin  ;; file is blocked
       msg = 'The result can not be saved because your ' + string(10b) + $
         'spreadsheet application is showing the file:' + string(10b) + fname + string(10b) + string(10b) +$
         'Please close your spreadsheet application' + string(10b) + 'Then try to save again.'
       res = dialog_message(msg, / error)
       GOTO, fin
     endif else begin
       if res then file_delete, fname, /quiet
       file_copy, info.dir_tmp + tmpfile, fname, / overwrite, /force
     endelse
        
     ;; if line draw, convert the restoration image to a binary FG image     
     IF strpos(info.add_title,'%; tick FGConn to reset)') GT 0 THEN BEGIN 
     ;; IF info.is_cost EQ 4 THEN BEGIN ;; custom or optimum path
       fname = strmid(fname,0,strlen(fname)-4) + '_4status.tif'
       image0 = *info.fr_image
       ;; reassign classes to MSPA-compliant setup
       qm = where(image0 eq 129b, ctqm, /l64)
       image0 = (image0 EQ 0b) + (image0 GT 0b)*2b
       IF ctqm GT 0 THEN image0[qm] = 0b
       if info.is_geotiff eq 1 then begin
         write_tiff,fname, rotate(image0,7), description = desc, geotiff = * info.geotiffinfo, red = r, green = g, blue = b, compression = 1
       endif else begin
         write_tiff,fname, rotate(image0,7), description = desc, red = r, green = g, blue = b, compression=1
       endelse        
     ENDIF
     IF info.is_cost EQ 2 THEN BEGIN ;; check if we save a optimum (5) path, then add the actual cost image too
       p = strpos(tmpfile2[0],'_AB.tif')
       for i = 0, n_elements(tmpfile2)-1 do begin
         if strlen(tmpfile2[i]) gt 0 then begin
           if p gt 0 then fname = fnbase + strmid(tmpfile2[i],p+3) else $
             fname = fnbase + strmid(tmpfile2[i],15)
           file_copy, info.dir_tmp + tmpfile2[i], fname, / overwrite
         endif
       endfor      
     ENDIF
       
     ;; fnsaves info
     fnsaves = 'All Restoration files were saved in the directory:' + string(10b) + newdir  
   ENDIF


   ;; write out the nw image
   ;;=====================================================
   IF info.is_nw EQ 1 THEN BEGIN
      pp = strpos(fname0, '.', / reverse_search) & fnbase = fname0
      IF pp GT 0 THEN fnbase = strmid(fname0, 0, pp)
      imfilebase = fnbase + '_nwdata'
      path = info.dir_data
      IF n_elements(path2file) GT 0 THEN path = path2file
      IF info.is_nw EQ 1 THEN image0 = * info.nw_ids ELSE image0 = * info.fr_image
      IF szoom EQ 1b THEN BEGIN ;; zoomed image
         x = info.x * info.resfac & y = info.y * info.resfac
         image0 = image0(x(0):x(1) + 1, y(0):y(1) + 1)
         image0 = rotate(image0, 7)
      ENDIF ELSE BEGIN  ;; fullres image
         image0 = rotate(image0, 7)
      ENDELSE

      ;; no geotiff
      IF info.is_geotiff EQ 0b THEN BEGIN
         write_tiff, imfilebase + '.tif', image0, /long, description = desc, compression = 1
         fnsaves = fnsaves + imfilebase + '.tif' + string(10b)
      ENDIF ELSE BEGIN ;; we have geotiff info
         IF szoom EQ 0b THEN BEGIN
            write_tiff, imfilebase + '.tif', image0, description = desc, $
                        geotiff = * info.geotiffinfo, /long, compression = 1
         ENDIF ELSE BEGIN ;; zoom and geotiff
            ;; 1) get the geotiff for the zoomed region with gdal
            ;; define gdal_translate
            IF info.my_os EQ 'windows' THEN BEGIN
               gtrans = info.windrive + ' & cd "' + info.dir_fwtools + '" & setfw.bat & '
               gtrans = gtrans + 'cd "' + info.dir_tmp + $
                        '" & gdal_translate -co ' + $
                        '"COMPRESS=LZW" -srcwin '
            ENDIF ELSE BEGIN ;; linux/apple
               if strlen(info.sysgdal) gt 0 then $
                gtrans = 'unset LD_LIBRARY_PATH; gdal_translate -co ' + '"COMPRESS=LZW" -srcwin ' else $
                gtrans = info.dir_fwtools + 'gdal_translate -co ' + '"COMPRESS=LZW" -srcwin '
            ENDELSE
            dx = x(1) - x(0) + 1 & dy = y(1) - y(0) + 1 & xoff = x(0)
            sy = (size( * info.nw_ids, / dim))[1] & yoff = sy - y(1) - 2
            gtrans = gtrans + strtrim(xoff, 2) + ' ' + strtrim(yoff, 2) + $
                     ' ' + strtrim(dx, 2) + ' ' + strtrim(dy, 2) + ' ' + $
                     info.fname_input + ' ' + info.dir_tmp + 'tmpdat.tif'
            IF info.my_os EQ 'windows' THEN $
             spawn, gtrans, log, / hide ELSE spawn, gtrans, log

            ;; 2) final: copy the geoheader to the data:
            ;; final name: im_file
            imtmp = read_tiff(info.dir_tmp + 'tmpdat.tif', geotiff = geotiffz)
            file_delete, info.dir_tmp + 'tmpdat.tif', / quiet & imtmp = 0
            write_tiff, imfilebase + '.tif', image0, description = desc, $
                        compression = 1, geotiff = geotiffz, /long
         ENDELSE
         fnsaves = fnsaves + imfilebase + '.tif' + string(10b)
      ENDELSE

      ;; save the fullres network stats to a txt file
      IF szoom EQ 0b THEN BEGIN
         pp = strpos(fname0, '.', / reverse_search) & fnbase = fname0
         IF pp GT 0 THEN fnbase = strmid(fname0, 0, pp)
         fname = fnbase + '.txt' & path = info.dir_data
         IF n_elements(path2file) GT 0 THEN path = path2file                
         openw, 1, fname
         printf, 1, 'Network analysis results using: ' + fnamex
         printf, 1, info.add_title
         printf, 1, '============================================================================'
         printf, 1, '  Component           Size: total                links'
         printf, 1, '============================================================================'
         FOR idx = 1, info.nw_mxinw DO $
                   printf, 1, idx, ( * info.nw_hnw)[idx], ( * info.nw_hnwb)[idx]
         printf, 1, ' '
         close, 1
         fnsaves = fnsaves + fname + string(10b)
      ENDIF
   ENDIF
   ;;=====================================================

   ;; write out the cs22 images as well
   ;;=====================================================
   IF info.is_cs22 EQ 1 THEN BEGIN
      pp = strpos(fname0, '.', / reverse_search) & fnbase = fname0
      IF pp GT 0 THEN fnbase = strmid(fname0, 0, pp)
      imfilebase = fnbase & path = info.dir_data
      IF n_elements(path2file) GT 0 THEN path = path2file
      suffix = ['_ids.tif', '_conn.tif']

      FOR isuf = 0, 1 DO BEGIN
         IF isuf EQ 0 THEN image0 = * info.cs22_nodes ELSE $
          image0 = * info.cs22_conn
         IF szoom EQ 1b THEN BEGIN ;; zoomed image
            ;imfilebase = imfilebase + '_zoom'
            x = info.x * info.resfac & y = info.y * info.resfac
            image0 = image0(x(0):x(1) + 1, y(0):y(1) + 1)
            image0 = rotate(image0, 7)
         ENDIF ELSE BEGIN  ;; fullres image
            image0 = rotate(image0, 7)
         ENDELSE

         ;; no geotiff
         IF info.is_geotiff EQ 0b THEN BEGIN
            IF isuf EQ 0 THEN BEGIN
                write_tiff, imfilebase + suffix(isuf), image0, /long, / signed, description = desc, compression = 1
            ENDIF ELSE BEGIN
               write_tiff, imfilebase + suffix(isuf), image0, / float, description = desc, compression = 1
            ENDELSE
         ENDIF ELSE BEGIN ;; we do have geotiff info
            IF szoom EQ 0b THEN BEGIN
               IF isuf EQ 0 THEN BEGIN
                   write_tiff, imfilebase + suffix(isuf), image0, /long, / signed, $
                               geotiff = * info.geotiffinfo, description = desc, compression = 1
               ENDIF ELSE BEGIN
                  write_tiff, imfilebase + suffix(isuf), image0, /float, $
                              geotiff = * info.geotiffinfo, description = desc, compression = 1
               ENDELSE
            ENDIF ELSE BEGIN ;; zoom and geotiff
               ;; 1) get the geotiff for the zoomed region with gdal
               ;; define gdal_translate
               IF info.my_os EQ 'windows' THEN BEGIN
                  gtrans = info.windrive + ' & cd "' + info.dir_fwtools + '" & setfw.bat & '
                  gtrans = gtrans + 'cd "' + info.dir_tmp + $
                           '" & gdal_translate -co ' + $
                           '"COMPRESS=LZW" -srcwin '
               ENDIF ELSE BEGIN ;; linux/apple
                  if strlen(info.sysgdal) gt 0 then $
                    gtrans = 'unset LD_LIBRARY_PATH; gdal_translate -co ' + '"COMPRESS=LZW" -srcwin ' else $
                    gtrans = info.dir_fwtools + 'gdal_translate -co ' + '"COMPRESS=LZW" -srcwin '
               ENDELSE
               dx = x(1) - x(0) + 1 & dy = y(1) - y(0) + 1 & xoff = x(0)
               sy = (size( * info.nw_ids, / dim))[1] & yoff = sy - y(1) - 2
               gtrans = gtrans + strtrim(xoff, 2) + ' ' + strtrim(yoff, 2) + $
                        ' ' + strtrim(dx, 2) + ' ' + strtrim(dy, 2) + ' ' + $
                        info.fname_input + ' ' + info.dir_tmp + 'tmpdat.tif'
               IF info.my_os EQ 'windows' THEN $
                spawn, gtrans, log, / hide ELSE spawn, gtrans, log

               ;; 2) final: copy the geoheader to the data:
               ;; final name: im_file
               imtmp = read_tiff(info.dir_tmp + 'tmpdat.tif', $
                                 geotiff = geotiffz)
               file_delete, info.dir_tmp + 'tmpdat.tif', /quiet & imtmp = 0
               IF isuf EQ 0 THEN BEGIN
                   write_tiff, imfilebase + suffix(isuf), image0, description = desc, $
                               compression = 1, geotiff = geotiffz, /long, /signed
               ENDIF ELSE BEGIN
                  write_tiff, imfilebase + suffix(isuf), image0, description = desc, $
                              compression = 1, geotiff = geotiffz, /float
               ENDELSE
            ENDELSE
         ENDELSE
         fnsaves = fnsaves + imfilebase + suffix(isuf) + string(10b)
      ENDFOR

      ;; save the fullres importance stats to a txt file if in fullres
      IF szoom EQ 0b THEN BEGIN
         fn = info.dir_tmp + 'nwtmp.sav' & res = file_info(fn)
         IF res.exists NE 1b THEN BEGIN
            msg = 'Please start with a MSPA image. ' + string(10b) + $
                  'Then run: Image Analysis -> Connectivity -> Components.' + $
                  string(10b) + 'Followed by: Image Analysis -> Connectivity' + $
                  ' -> Node/Link Importance.' + string(10b) + 'Returning...'
            res = dialog_message(msg, / information)
            GOTO, finall
         ENDIF
         widget_control, / hourglass
         restore, fn
         ;; links = MSPA bridges
         lbl_links = label_region(image0 EQ 2b, / all, / ulong)
         nr_links = max(lbl_links)
         lbl_links = lbl_links[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1]

         ;; nodes = MSPA cores
         lbl_nodes = label_region(image0 EQ 1b, / all, / ulong)
         nr_nodes = max(lbl_nodes)
         lbl_nodes = lbl_nodes[eew:eew + sz(0) - 1, eew:eew + sz(1) - 1]

         ;; connectivity importance for nodes and links
         conn = * info.cs22_conn

         pp = strpos(fname0, '.', / reverse_search) & fnbase = fname0
         IF pp GT 0 THEN fnbase = strmid(fname0, 0, pp)
         fname = fnbase + '.txt' & path = info.dir_data
         IF n_elements(path2file) GT 0 THEN path = path2file

         openw, 1, fname
         printf, 1, info.title + info.add_title
         printf, 1, '(NOTE: node ID & importance in the actual image data are'
         printf, 1, 'NEGATIVE to distinguish them from link ID & importance)'
         printf, 1, '===================================================================='
         xx = strcompress(info.nw_mxinw) + ' /' + strcompress(nr_links) + $
               ' /' + strcompress(nr_nodes)
         printf, 1, 'Total number of components/links/nodes: ' + xx
         printf, 1, '===================================================================='

         FOR idc = 1l, info.nw_mxinw DO BEGIN ;; loop over components
            qnw = where( * info.nw_ids EQ idc) ;; component pixels
            lids = lbl_links(qnw) & hlids = histogram(lids)
            lids_ids = where(hlids GT 0) & lx = n_elements(lids_ids)
            nids = lbl_nodes(qnw) & hnids = histogram(nids)
            nids_ids = where(hnids GT 0) & nx = n_elements(nids_ids)
            IF lx EQ 1 THEN nr_lids = 1 ELSE nr_lids = lx - 1
            IF total(lids) EQ 0.0 THEN nr_lids = 0  ;; reset for no links
            IF nx EQ 1 THEN nr_nids = 1 ELSE nr_nids = nx - 1
            IF total(nids) EQ 0.0 THEN nr_nids = 0
            q = where(lids GT 0, alids) & q = where(nids GT 0, anids)
            ;connids = conn[qnw]
            printf, 1, '                   Component: ' + strcompress(idc)
            printf, 1, '================================================================'
            printf, 1, '# of links/nodes: ' + strcompress(nr_lids) + $
                    ' /' + strcompress(nr_nids)
            printf, 1, 'Pixels of component/links/nodes: ', + $
                    strcompress(n_elements(qnw)) + ' /' + $
                    strcompress(alids) + ' /' + strcompress(anids)

            IF nr_lids GT 0 THEN BEGIN
               printf, 1, '================================================================'
               printf, 1, '     Link ID        pixels          dPC      normalized.importance'
               printf, 1, '----------------------------------------------------------------'
               FOR i = 1l, nr_lids DO BEGIN
                  IF nr_lids EQ 1 THEN BEGIN
                     idx = max(lids) & q = where(lids EQ idx, aa)
                  ENDIF ELSE BEGIN
                     idx = lids_ids[i] & aa = hlids(idx)
                  ENDELSE
                  imp = (conn(where(lbl_links EQ idx)))[0]
                  impp =  imp / info.cs22_mx_bridge * 100.0
                  printf, 1, idx, aa,'    ', imp,'      ', impp
               ENDFOR
            ENDIF
            IF nr_nids GT 0 THEN BEGIN
               printf, 1, '================================================================'
               printf, 1, '     Node ID        pixels          dPC      normalized.importance'
               printf, 1, '----------------------------------------------------------------'
               FOR i = 1l, nr_nids DO BEGIN
                  IF nr_nids EQ 1 THEN BEGIN
                     idx = max(nids) & q = where(nids EQ idx, aa)
                  ENDIF ELSE BEGIN
                     idx = nids_ids[i] & aa = hnids(idx)
                  ENDELSE
                  imp = abs((conn(where(lbl_nodes EQ idx)))[0])
                  impp = imp / abs(info.cs22_mx_core) * 100.0
                  idx=long(idx)
                  printf, 1, -idx, aa,'    ', imp,'      ', impp
               ENDFOR
            ENDIF
            printf, 1, '================================================================'
         ENDFOR ;; component loop
         close, 1
         fnsaves = fnsaves + fname + string(10b)
      ENDIF ;; only for fullres
   ENDIF  ;; end of CS22
   ;;=====================================================
   ;; echo info what was saved
   ;;=====================================================
   res = dialog_message(fnsaves, / information)
  
ENDIF
finall:

;; backup current colors
tvlct, r, g, b, /get & save, r,g,b, filename = info.dir_tmp2 + 'currcolors.sav'

;; return the info structure.
widget_control, event.top, set_uvalue = info, / no_copy

END ;; of 'guidos_io'
;;=======================================================================
;;=======================================================================
;;=======================================================================

;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################

;;=======================================================================
;;=======================================================================
;;;;              T L B    E V E N T   H A N D L E R
;;=======================================================================
;;=======================================================================
;;=======================================================================
;;=======================================================================
PRO CenterTLB, tlb

;; This utility routine centers the TLB.
Device, Get_Screen_Size = screenSize
xCenter = screenSize(0) / 2
yCenter = screenSize(1) / 2

geom = Widget_Info(tlb, / Geometry)
xHalfSize = geom.Scr_XSize / 2
yHalfSize = geom.Scr_YSize / 2

Widget_Control, tlb, XOffset = xCenter - xHalfSize, $
 YOffset = yCenter - yHalfSize

END
; of centerTLB   *********************************************
;;=======================================================================



;;=======================================================================
;;======================================================================= 
PRO Guidos_tlb_events, event
;; this is the event handler for the draw widget graphics window.
;; it continuously draws and erases the zoom box until it
;; receives an up event from the draw widget. then it turns draw widget
;; motion events off.

;; get the info structure out of the top-level base.
widget_control, event.top, get_uvalue = info, / no_copy

;; What type of an event in the display area is this?
;;=================================================================
;;=================================================================
;; {WIDGET_DRAW, ID:0L, TOP:0L, HANDLER:0L, TYPE: 0, X:0L, Y:0L,
;;   PRESS:0B, RELEASE:0B, CLICKS:0L, MODIFIERS:0L, CH:0B, KEY:0L }
;;
;; event.type:
;;=============
;;0 -  Button press
;;1 -  Button release
;;2 -  Motion
;;3 -  Viewport moved (scrollbars)
;;4 -  Visibility changed (exposed)
;;5 -  Key press (ASCII character value reported in CH field)
;;6 -  Key press (non-ASCII key value reported in KEY field)
;;7 -  Wheel scroll
;;
;; event.x and event.y
;;====================
;; - coordinates from bottom left, starting from 0/0
;;
;; event.PRESS and event. RELEASE = > mouse button
;;===============================
;; 1 - left
;; 2 - middle
;; 3 - right
;; PRESS and RELEASE are both zero for motion events
;;

;;================================================
;; Case A) mouse MOVE event without mouse click
;; and NOT in the phase of defining a sub-region
;;===============================================
;; Note: do NOT search for a string starting with an empty space, it won't work properly!
IF (strpos(info.add_title,'LM, kdim=') GT 0) OR (strpos(info.add_title,'Dominance') GT 0) THEN is_lm=1 else is_lm=0
IF strpos(info.add_title,'(FOS 5-class: ') GT 0 THEN is_fos=2 ELSE is_fos=0
IF strpos(info.add_title,'(FOS 6-class: ') GT 0 THEN is_fos=1 
IF strpos(info.add_title,'(FOS-APP 2-class: ') GT 0 THEN is_fos=4
IF strpos(info.add_title,'(FOS-APP 5-class: ') GT 0 THEN is_fos=5 
IF strpos(info.add_title,'(FAD 6-class: ') GT 0 THEN is_fad=1 ELSE is_fad=0
IF strpos(info.add_title,'(FAD-APP 2-class: ') GT 0 THEN is_fad=2
IF strpos(info.add_title,'(FAD-APP 5-class: ') GT 0 THEN is_fad=5
IF strpos(info.add_title,'(restoration path between 5 largest objects') GT 0 THEN is_restore=1 ELSE is_restore=0
is_mcd=0
IF strmid(info.title,0,15) EQ 'MCD (A->B) FG: ' THEN is_mcd=1
IF strmid(info.title,0,20) EQ 'Simple change (A->B)' THEN is_mcd=2

case info.add_title of
  ' (SPA2)': is_spa = 2
  ' (SPA3)': is_spa = 3
  ' (SPA5)': is_spa = 5
  ' (SPA6)': is_spa = 6
  else: is_spa = 0
endcase
ss = size( * info.fr_image, / dim) & sx1 = ss[0]-1 & sy1 = ss[1]-1 
rsf = info.resfac 

;; set temporary custom path switch to allow moving in enlarged zoom window when doing restoration paths 
IF info.is_cost EQ 3 AND event.type EQ 3 THEN info.is_cost = 7
IF info.is_cost EQ 9 AND event.type EQ 3 THEN info.is_cost = 79

IF event.type EQ 2 AND info.set_zoom EQ 0 THEN BEGIN
    
   IF info.selsubregion_id EQ 0 THEN BEGIN
      ;;=============================================================
      ;; mouse move in ORIGINAL display:
      ;; show image position, value, class
      ;;=============================================================
      ;; event positions need to be multiplied by resfac
      ;; to account for images larger than the display

      xm = 0 > (event.x * rsf) < sx1 & ym = 0 > (event.y * rsf) < sy1 
      ymi = sy1 - ym
;;      print, ym, sy1

      IF info.def_marker gt 0 then goto, normdat0
      IF info.is_cs22 EQ 1 THEN BEGIN
         ;; cs22 data
         ;;===============
         zm = ( * info.cs22_nodes)[xm, ym] + 0
         IF zm EQ 0 THEN BEGIN ;; we are in the background
            cmd2 = '   background'
         ENDIF ELSE BEGIN ;; show: output node, class, connectivity
            ;; the node connectivity at this location
            conn = abs(( * info.cs22_conn)[xm, ym])
            ;; now zm corresponds to the node ID, test its type
            IF zm LT 0 THEN BEGIN ;; it's a node
               cmd2 =  '   NodeID: ' & connstr = strtrim(conn, 2)
               ;; relative importance
               xx = round((conn / abs(info.cs22_mx_core)) * 100.0)
            ENDIF ELSE BEGIN ;; it's a bridge
               cmd2 =  '   LinkID: ' & connstr = strtrim(conn, 2)
               xx = round((conn / info.cs22_mx_bridge) * 100.0)
            ENDELSE
            topx = ' (' + strtrim(xx, 2) + '%)'
            ;; build the output string
            cmd2 = cmd2 + strtrim(zm, 2) + ', ConnImportance: ' + $
                    connstr + topx
         ENDELSE
      ENDIF ELSE IF info.is_nwconnect EQ 1 THEN BEGIN
         ;; nwconnect: 10 paths between 5 largest components
         zm = ( * info.nw_ids)[xm, ym] + 0
         zm1 = ( * info.fr_image)[xm, ym] + 0
         zm2 = ( * info.nw_conns)[xm, ym]  
         IF zm EQ 0 THEN BEGIN ;; we are in the background
           cmd2 = '  background'
         ENDIF ELSE BEGIN ;; show component ID and size
           hzm = ( * info.nw_hnw)[zm]
           cmd2 =  '  Component ID, size: ' + strtrim(zm, 2) + ', ' + strtrim(hzm, 2) 
         ENDELSE
         IF zm1 EQ 129 THEN cmd2 = '  missing'
         ;; Increase by Component Connector
         IF zm2 GT 0 THEN cmd2 =  '   NW Connectivity Gain: ' + strtrim(zm2, 2) + '%'      

       ENDIF ELSE IF is_restore EQ 1 THEN BEGIN
         ;; restoration: 10 paths between 5 largest objects
         zm = ( * info.nw_ids)[xm, ym] + 0
         zm1 = ( * info.fr_image)[xm, ym] + 0
         IF zm EQ 0 THEN BEGIN ;; we are in the background
           cmd2 = '  background'
         ENDIF ELSE BEGIN ;; show object ID and size
           hzm = ( * info.nw_hnw)[zm]
           cmd2 =  '  object ID, size: ' + strtrim(zm, 2) + ', ' + strtrim(hzm, 2)
         ENDELSE
         IF zm1 EQ 129 THEN cmd2 = '  missing'
         IF zm1 EQ 103 THEN cmd2 = '  Restore Path'
         IF zm1 EQ 33 THEN cmd2 = '  Restore Pixel'

      ENDIF ELSE IF info.is_nw EQ 1 THEN BEGIN
         ;; network data
         ;;================
         zm = ( * info.nw_ids)[xm, ym] + 0
         zm1 = ( * info.fr_image)[xm, ym] + 0
         cmd2 =  '   nw: '
         IF zm EQ 0 THEN BEGIN ;; we are in the background
            cmd2 = '  background'
         ENDIF ELSE BEGIN ;; show: componentID, size: total/links
            hzm = ( * info.nw_hnw)[zm] & hzmb = ( * info.nw_hnwb)[zm]
            cmd2 =  cmd2 + '(ID, size: total/links]: ' + strtrim(zm, 2) + $
                    ', ' + strtrim(hzm, 2) + '/' +  strtrim(hzmb, 2)
         ENDELSE
         IF zm1 EQ 129 THEN cmd2 = '  missing'

       ENDIF ELSE IF info.is_cost EQ 1 THEN BEGIN
         ;; show cost data
         ;;================
         zm = ( * info.fr_image)[xm, ym] + 0 
         cmd2 =  '   isochrone map: '
         IF info.do_label_groups_id eq 1 THEN BEGIN
           IF zm EQ 40 THEN BEGIN
             cmd2 = cmd2 + 'small'
           ENDIF ELSE IF zm EQ 60 THEN BEGIN
             cmd2 = cmd2 + 'medium'
           ENDIF ELSE IF zm EQ 70 THEN BEGIN
             cmd2 = cmd2 + 'large'
           ENDIF ELSE IF zm EQ 103 THEN BEGIN
             cmd2 = cmd2 + 'optimum path'
           ENDIF ELSE IF zm EQ 101 THEN BEGIN
             cmd2 = cmd2 + 'start/target object'
           ENDIF ELSE IF zm EQ 102 THEN BEGIN
             cmd2 = cmd2 + 'missing'
           ENDIF ELSE IF zm EQ 104 THEN BEGIN
             cmd2 = cmd2 + 'unreachable'            
           ENDIF ELSE BEGIN
             cmd2 = cmd2 + strtrim(zm, 2)       
           ENDELSE         
         ENDIF ELSE BEGIN
           IF zm EQ 103 THEN BEGIN
             cmd2 = cmd2 + 'optimum path'
           ENDIF ELSE IF zm EQ 101 THEN BEGIN
             cmd2 = cmd2 + 'start/target object'
           ENDIF ELSE IF zm EQ 102 THEN BEGIN
             cmd2 = cmd2 + 'missing'
           ENDIF ELSE IF zm EQ 104 THEN BEGIN
             cmd2 = cmd2 + 'unreachable'
           ENDIF ELSE BEGIN ;; show value
             cmd2 =  cmd2 + strtrim(zm, 2)
           ENDELSE
         ENDELSE
         
       ENDIF ELSE IF info.is_cost EQ 2 THEN BEGIN
         ;; show reconnect data
         ;;================
         zm = ( * info.fr_image)[xm, ym] + 0
         IF zm EQ 0 THEN BEGIN ;; we are in the background
           cmd2 = '   background'
         ENDIF ELSE IF zm EQ 33 THEN BEGIN ;; 
           cmd2 = '   Restore Pixel'
         ENDIF ELSE IF zm EQ 103 THEN BEGIN ;; missing
           cmd2 = '   Restore Path'
         ENDIF ELSE IF zm EQ 129 THEN BEGIN ;; missing
           cmd2 = '   missing'
         ENDIF ELSE BEGIN ;; show: componentID
           zm2 = ( * info.nw_ids)[xm, ym] + 0 ;; object ID
           zm3 = ( * info.nw_hnw)[zm2] ;; object area
           cmd2 = '   object ID: ' + strtrim(zm2, 2) + ', area: ' + strtrim(zm3, 2)
         ENDELSE
         

       ENDIF ELSE IF info.is_influ EQ 1 THEN BEGIN
         ;; show influence zones data
         ;;================
         zm = ( * info.nw_ids)[xm, ym] + 0
         IF zm EQ 0 THEN BEGIN ;; we are in the background
           cmd2 = '   background'
         ENDIF ELSE IF zm EQ -1 THEN BEGIN ;; hole inside FG
           cmd2 = '   FG hole'
         ENDIF ELSE IF zm EQ -2 THEN BEGIN ;; neglected FG
           cmd2 = '   neglected FG'
         ENDIF ELSE IF zm EQ -3 THEN BEGIN ;; watershed
           cmd2 = '   watershed'
         ENDIF ELSE IF zm EQ -4 THEN BEGIN ;; missing
           cmd2 = '   missing'
         ENDIF ELSE IF zm EQ -5 THEN BEGIN ;; buffer boundary
           cmd2 = '   buffer boundary'
         ENDIF ELSE IF zm EQ -6 THEN BEGIN ;; buffer
           cmd2 = '   buffer'
         ENDIF ELSE BEGIN ;; show: componentID
           zma = ( * info.nw_hnw)[zm]
           cmd2 = '   influence zone ID: ' + strtrim(zm, 2) + ', area: ' + strtrim(zma, 2) 
         ENDELSE

       ENDIF ELSE IF info.is_influ EQ 2 THEN BEGIN
         ;; show accounting data
         ;;================
         zm = ( * info.nw_ids)[xm, ym] + 0
         IF zm EQ 0 THEN BEGIN ;; we are in the background
           cmd2 = '   background'
         ENDIF ELSE IF zm EQ -1 THEN BEGIN ;; missing
           cmd2 = '   missing'
         ENDIF ELSE IF zm EQ -3 THEN BEGIN ;; water
           cmd2 = '   specialBG1'
         ENDIF ELSE IF zm EQ -4 THEN BEGIN ;; specialBG
           cmd2 = '   specialBG2'
         ENDIF ELSE BEGIN ;; show: componentID
           pix = ( * info.nw_conns)[xm, ym] + 0
           q = ( * info.fr_image)[xm, ym] + 0
           if q eq 80b then qstr = ' (1 of the 3 largest objects)' else qstr = ''
           cmd2 = '   object ID: ' + strtrim(zm, 2) + ', area: ' + strtrim(pix, 2) + qstr
         ENDELSE
      
       ENDIF ELSE IF info.is_influ EQ 3 THEN BEGIN
         ;; show proximity data
         ;;================
         zm = ( * info.nw_ids)[xm, ym] + 0        
         IF zm EQ 0 THEN BEGIN ;; we are in the background
           cmd2 = '   background'
         ENDIF ELSE IF zm EQ -1 THEN BEGIN ;; hole inside FG
           cmd2 = '   FG hole'
         ENDIF ELSE IF zm EQ -2 THEN BEGIN ;; neglected FG
           cmd2 = '   neglected FG'
         ENDIF ELSE IF zm EQ -3 THEN BEGIN ;; watershed
           zmd = ( * info.nw_conns)[xm, ym] + 0 ;ws-distance
           zmd2 = ( * info.cs22_nodes)[xm, ym] + 0 ; cag
           cagrel = round(zmd2*100.0/info.allcomp)
           cmd2 = '   watershed, proximity: ' + strtrim(zmd, 2) + ', CAG: ' + $
            strtrim(zmd2, 2) + ' (' + strtrim(cagrel,2) + '%)'
         ENDIF ELSE IF zm EQ -4 THEN BEGIN ;; missing
           cmd2 = '   missing'
         ENDIF ELSE IF zm EQ -5 THEN BEGIN ;; buffer boundary
           cmd2 = '   buffer boundary'
         ENDIF ELSE IF zm EQ -6 THEN BEGIN ;; buffer
           cmd2 = '   buffer'
         ENDIF ELSE BEGIN ;; show: componentID
           zma = ( * info.nw_hnw)[zm]
           cmd2 =  '   component ID: ' + strtrim(zm, 2) + ', area: ' + strtrim(zma, 2) 
         ENDELSE

      ENDIF ELSE IF info.is_dist EQ 1 THEN BEGIN
         ;; morphdist data
         ;;================
         zm = ( * info.morphdist)[xm, ym] + 0
           cmd2 = '   missing'
         IF zm LT 0.0 THEN BEGIN ;; we are in the background
            cmd2 = '   background: ' + strtrim(zm, 2)
         ENDIF 
         IF zm GT 0.0 THEN BEGIN ;; foreground
            cmd2 =  '    foreground: ' + strtrim(zm, 2)
         ENDIF

       ENDIF ELSE IF (info.is_fragm GT 0) THEN BEGIN
         ;; fragmentation 
         ;;=========================
         IF info.is_fragm EQ 3 THEN BEGIN 
           if is_fos ge 1 then begin ;; frag_FOS
             zm1 = ( * info.fr_image)[xm, ym] + 0
             z1 = strtrim(zm1, 2)
             if is_fos eq 4 then begin
               case 1 of
                 (zm1 LT 40b): zm = '   Separated: ' + z1
                 else: zm = '   Continuous: ' + z1
               endcase
             endif else begin
               case 1 of
                 (zm1 LT 10b): zm = '   Rare: ' + z1
                 (zm1 LT 40b): zm = '   Patchy: ' + z1
                 (zm1 LT 60b): zm = '   Transitional: ' + z1
                 (zm1 LT 90b): zm = '   Dominant: ' + z1
                 (zm1 LT 100b): zm = '   Interior: ' + z1
                 else: zm = '   Intact: ' + z1
               endcase
               if is_fos eq 2 and zm1 eq 100b then zm = '   Interior: ' + z1
             endelse

             cmd2 = '   missing' ;; missing data pixels
             IF zm1 EQ 105 THEN BEGIN ;; we have type 3b, water
               cmd2 = '   specific background 1'
             ENDIF ELSE IF zm1 EQ 106 THEN BEGIN ;; we have type 4b, water
               cmd2 = '   specific background 2'
             ENDIF ELSE IF zm1 EQ 101 THEN BEGIN ;; we are in the background
               cmd2 = '   background'
             ENDIF ELSE IF zm1 LT 101 THEN BEGIN ;; we are in the foreground
               cmd2 = zm
             ENDIF
            
           endif else begin ;; frag_fad; zm2=5scales, zm1=average over scales                             
             zm1 = ( * info.fr_image)[xm, ym] + 0 
             zm2 = (*info.mscale)[*, xm, ym] + 0
             z2 = ' [' + strtrim(zm2[0],2) + '-' + strtrim(zm2[1],2) + '-' + strtrim(zm2[2],2) + '-' + strtrim(zm2[3],2) + '-' + strtrim(zm2[4],2) + ']' 
             z1 = strtrim(zm1, 2)
             if is_fad eq 2 then begin
               case 1 of
                 (zm1 LT 40b): zm = '   Separated: ' + z1 + z2
                 else: zm = '   Continuous: ' + z1 + z2
               endcase
             endif else begin
               case 1 of
                 (zm1 LT 10b): zm = '   Rare: ' + z1 + z2
                 (zm1 LT 40b): zm = '   Patchy: ' + z1 + z2
                 (zm1 LT 60b): zm = '   Transitional: ' + z1 + z2
                 (zm1 LT 90b): zm = '   Dominant: ' + z1 + z2
                 (zm1 LT 100b): zm = '   Interior: ' + z1 + z2
                 else: zm = '   Intact: ' + z1 + z2
               endcase
             endelse

             cmd2 = '   missing' ;; missing data pixels
             IF zm1 EQ 105 THEN BEGIN ;; we have type 3b, water
               cmd2 = '   specific background 1'
             ENDIF ELSE IF zm1 EQ 106 THEN BEGIN ;; we have type 4b, water
               cmd2 = '   specific background 2'
             ENDIF ELSE IF zm1 EQ 101 THEN BEGIN ;; we are in the background
               cmd2 = '   background'
             ENDIF ELSE IF zm1 LT 101 THEN BEGIN ;; we are in the foreground
               cmd2 = zm
             ENDIF
           endelse ;; FOS=0
                   
         ENDIF ELSE BEGIN ;; fragmentation or spatcon
           zm = ( * info.nw_ids)[xm, ym] + 0
           cmd2 = '   missing'
           IF zm EQ 101b THEN BEGIN ;; we are in the background
             cmd2 = '   background'
           ENDIF ELSE IF zm LT 101b THEN BEGIN ;; foreground
             cmd2 =  '    foreground: ' + strtrim(zm, 2) + '%'
           ENDIF
         ENDELSE

       ENDIF ELSE IF info.is_contort GT 0 THEN BEGIN
         ;; contortion data [-1 missing, 0 BG, 1 neglected object, 2 -> whatever in FG]
         ;;================
         zm = ( * info.contort)[xm, ym] + 0 
         IF zm GT 1 THEN BEGIN ;; foreground
           cmd2 = '   foreground: ' + strtrim(zm, 2)
         ENDIF else if zm EQ 0 THEN BEGIN ;; background
           cmd2 =  '    background'
         ENDIF else if zm EQ 1 THEN BEGIN ;; neglected object
           cmd2 =  '    neglected object'
         ENDIF else begin ;; missing pixels
           cmd2 = '   missing'
         Endelse

       ENDIF ELSE IF is_lm EQ 1 THEN BEGIN
         ;; LM data [0 missing, 1-19 LM-classes]
         ;;================
         zm = ( * info.fr_image)[xm, ym] + 0
         case zm of
          0: cmd2 = '   missing'
          1: cmd2 = '   A: ' + strtrim(zm, 2)
          2: cmd2 = '   D: ' + strtrim(zm, 2)
          3: cmd2 = '   N: ' + strtrim(zm, 2)
          4: cmd2 = '   Ad: ' + strtrim(zm, 2)
          5: cmd2 = '   An: ' + strtrim(zm, 2)
          6: cmd2 = '   Dn: ' + strtrim(zm, 2)
          7: cmd2 = '   Da: ' + strtrim(zm, 2)
          8: cmd2 = '   Na: ' + strtrim(zm, 2)
          9: cmd2 = '   Nd: ' + strtrim(zm, 2)
          10: cmd2 = '   Adn: ' + strtrim(zm, 2)
          11: cmd2 = '   Dan: ' + strtrim(zm, 2)
          12: cmd2 = '   Nad: ' + strtrim(zm, 2)
          13: cmd2 = '   ad: ' + strtrim(zm, 2)
          14: cmd2 = '   an: ' + strtrim(zm, 2)
          15: cmd2 = '   dn: ' + strtrim(zm, 2)
          16: cmd2 = '   adn: ' + strtrim(zm, 2)
          17: cmd2 = '   NN: ' + strtrim(zm, 2)
          18: cmd2 = '   AA: ' + strtrim(zm, 2)
          19: cmd2 = '   DD: ' + strtrim(zm, 2)
          else: cmd2 = '   invalid setting: ' + strtrim(zm, 2)
         endcase

      ENDIF ELSE IF is_spa EQ 2 THEN BEGIN
         ;; SPA2 data [0-BG, 1-SLF, 17-contiguous, 129-missing]
         ;;================
         zm = ( * info.fr_image)[xm, ym] + 0
         case zm of
           0: cmd2 = '   background: ' + strtrim(zm, 2)
           1: cmd2 = '   SLF: ' + strtrim(zm, 2)
           17: cmd2 = '   Contiguous: ' + strtrim(zm, 2)
           129: cmd2 = '   missing: ' + strtrim(zm, 2)
           else: cmd2 = '   invalid setting: ' + strtrim(zm, 2)
         endcase

       ENDIF ELSE IF is_spa EQ 3 THEN BEGIN
         ;; SPA3 data [0-BG, 1-transition, 17-core, 100-holes, 129-missing]
         ;;================
         zm = ( * info.fr_image)[xm, ym] + 0
         case zm of
           0: cmd2 = '   background: ' + strtrim(zm, 2)
           1: cmd2 = '   Margin: ' + strtrim(zm, 2)
           17: cmd2 = '   Core: ' + strtrim(zm, 2)
           100: cmd2 = '   Core-Opening: ' + strtrim(zm, 2)
           129: cmd2 = '   missing: ' + strtrim(zm, 2)
           else: cmd2 = '   invalid setting: ' + strtrim(zm, 2)
         endcase

       ENDIF ELSE IF is_spa GT 3 THEN BEGIN
         ;; SPA5/6 data [0-BG, 1-margin, 3-edge, 9-islet, 17-core, 65-perf, 100-holes, 129-missing]
         ;;================
         zm = ( * info.fr_image)[xm, ym] + 0
         case zm of
           0: cmd2 = '   background: ' + strtrim(zm, 2)
           1: cmd2 = '   Margin: ' + strtrim(zm, 2)
           3: cmd2 = '   Edge: ' + strtrim(zm, 2)
           9: cmd2 = '   Islet: ' + strtrim(zm, 2)
           17: cmd2 = '   Core: ' + strtrim(zm, 2)
           5: cmd2 = '   Perforation: ' + strtrim(zm, 2)
           100: cmd2 = '   Core-Opening: ' + strtrim(zm, 2)
           129: cmd2 = '   missing: ' + strtrim(zm, 2)
           else: cmd2 = '   invalid setting: ' + strtrim(zm, 2)
         endcase

       ENDIF ELSE IF is_mcd EQ 1 THEN BEGIN
         ;; morph change      
         zm = ( * info.fr_image)[xm, ym] + 0
         case zm of
           11: cmd2 = '   BG-stable: ' + strtrim(zm, 2)
           22: cmd2 = '   FG-stable: ' + strtrim(zm, 2)
           21: cmd2 = '   Loss: ' + strtrim(zm, 2)
           12: cmd2 = '   Gain: ' + strtrim(zm, 2)
          176: cmd2 = '   spurious: ' + strtrim(zm, 2)
          255: cmd2 = '   missing: ' + strtrim(zm, 2)
          else: cmd2 = '   invalid setting: ' + strtrim(zm, 2)
         endcase

       ENDIF ELSE IF is_mcd EQ 2 THEN BEGIN
         ;; simple change
         zm = ( * info.fr_image)[xm, ym] + 0
         case zm of
           11: cmd2 = '   BG-stable: ' + strtrim(zm, 2)
           22: cmd2 = '   FG-stable: ' + strtrim(zm, 2)
           21: cmd2 = '   Loss: ' + strtrim(zm, 2)
           12: cmd2 = '   Gain: ' + strtrim(zm, 2)
           255: cmd2 = '   missing: ' + strtrim(zm, 2)
           else: cmd2 = '   invalid setting: ' + strtrim(zm, 2)
         endcase

      ENDIF ELSE BEGIN
         ;; normal data
         ;;================
         normdat0:
         
         zm = ( * info.fr_image)[xm, ym] + 0
         cmd2 =  '   Value: ' + strtrim(zm, 2) + ' (' + info.datatype +')'
         IF (strpos(info.add_title,'FGConn for Path setup') GT 0) AND (info.is_cost EQ 7) then begin
           zm2 = ( * info.nw_ids)[xm, ym] + 0 ;; object ID
           zm3 = ( * info.nw_hnw)[zm2] ;; object area
           if zm2 eq 0 then cmd2 = '   background' else $
            cmd2 = '   object ID: ' + strtrim(zm2, 2) + ', area: ' + strtrim(zm3, 2) +'; '
           if zm eq 129 then cmd2 = '   missing'
         ENDIF 

      ENDELSE

   ENDIF ELSE BEGIN
      ;;=============================================================
      ;; mouse move in ENLARGED SUBREGION display:
      ;; show image position, value, class
      ;;=============================================================
      ;; coordinates of zoombox in original fr_image
      ;;----------------------------------------------
      ;; print, 'x-coord of zoombox: ', info.x & help,info.x
      ;; print, 'y-coord of zoombox: ', info.y
      x = 0 > (info.x * rsf) < sx1 & y = 0 > (info.y * rsf) < sy1
      ;; current x/y coordinate of the mouse pointer in the enlarged
      ;; image and the value at this location
      xm = (x[0] + (event.x + info.scroll_x) / info.zoomfactor) < sx1
      ym = (y[0] + (event.y + info.scroll_y) / info.zoomfactor) < sy1 
      ymi = sy1 - ym
      ;help,xm,ym,rsf
      
      IF info.def_marker gt 0 then goto, normdat1

      IF info.is_cs22 EQ 1 THEN BEGIN
         ;; cs22 data
         ;;================
         zm = ( * info.cs22_nodes)[xm, ym] + 0
         IF zm EQ 0 THEN BEGIN ;; we are in the background
            cmd2 = '   background'
         ENDIF ELSE BEGIN ;; show: output node, class, connectivity
            ;; the node connectivity at this location
            conn = abs(( * info.cs22_conn)[xm, ym])
            ;; now zm corresponds to the node ID, test its type
            IF zm LT 0 THEN BEGIN ;; it's a node
               cmd2 =  '   NodeID: ' & connstr = strtrim(conn, 2)
               ;; relative importance
               xx = round((conn / abs(info.cs22_mx_core)) * 100.0)
            ENDIF ELSE BEGIN ;; it's a bridge
               cmd2 =  '   LinkID: ' & connstr = strtrim(conn, 2)
               xx = round((conn / info.cs22_mx_bridge) * 100.0)
            ENDELSE
            topx = ' (' + strtrim(xx, 2) + '%)'
            ;; build the output string
            cmd2 = cmd2 + strtrim(zm, 2) + ', ConnImportance: ' + $
                    connstr + topx
         ENDELSE
       ENDIF ELSE IF info.is_nwconnect EQ 1 THEN BEGIN
         ;; nwconnect: 10 paths between 5 largest components
         zm = ( * info.nw_ids)[xm, ym] + 0
         zm1 = ( * info.fr_image)[xm, ym] + 0
         zm2 = ( * info.nw_conns)[xm, ym] + 0
         IF zm EQ 0 THEN BEGIN ;; we are in the background
           cmd2 = '  background'
         ENDIF ELSE BEGIN ;; show component ID and size
           hzm = ( * info.nw_hnw)[zm]
           cmd2 =  '  Component ID, size: ' + strtrim(zm, 2) + ', ' + strtrim(hzm, 2)
         ENDELSE
         IF zm1 EQ 129 THEN cmd2 = '  missing'
         ;; Increase by Component Connector
         IF zm2 GT 0 THEN cmd2 =  '   NW Connectivity Gain: ' + strtrim(zm2, 2) + '%'

       ENDIF ELSE IF is_restore EQ 1 THEN BEGIN
         ;; restoration: 10 paths between 5 largest patches
         zm = ( * info.nw_ids)[xm, ym] + 0
         zm1 = ( * info.fr_image)[xm, ym] + 0
         IF zm EQ 0 THEN BEGIN ;; we are in the background
           cmd2 = '  background'
         ENDIF ELSE BEGIN ;; show object ID and size
           hzm = ( * info.nw_hnw)[zm]
           cmd2 =  '  object ID, size: ' + strtrim(zm, 2) + ', ' + strtrim(hzm, 2)
         ENDELSE
         IF zm1 EQ 129 THEN cmd2 = '  missing'
         IF zm1 EQ 103 THEN cmd2 = '  Restore Path'
         IF zm1 EQ 33 THEN cmd2 = '  Restore Pixel'

      ENDIF ELSE IF info.is_nw EQ 1 THEN BEGIN
         ;; network data
         ;;================
         zm = ( * info.nw_ids)[xm, ym] + 0
         zm1 = ( * info.fr_image)[xm, ym] + 0
         cmd2 =  '   nw: '
         IF zm EQ 0 THEN BEGIN ;; we are in the background
            cmd2 = 'background'
         ENDIF ELSE BEGIN ;; show: componentID, size: total/links
            hzm = ( * info.nw_hnw)[zm] & hzmb = ( * info.nw_hnwb)[zm]
            cmd2 =  cmd2 + '(ID, size: total/links]: ' + strtrim(zm, 2) + $
                    ', ' + strtrim(hzm, 2) + '/' +  strtrim(hzmb, 2)
         ENDELSE
         IF zm1 EQ 129 THEN cmd2 = '  missing'

       ENDIF ELSE IF info.is_cost EQ 1 THEN BEGIN
         ;; show cost data
         ;;================
         zm = ( * info.fr_image)[xm, ym] + 0 
         cmd2 =  '   isochrone map: '
         IF info.do_label_groups_id eq 1 THEN BEGIN
           IF zm EQ 40 THEN BEGIN
             cmd2 = cmd2 + 'small'
           ENDIF ELSE IF zm EQ 60 THEN BEGIN
             cmd2 = cmd2 + 'medium'
           ENDIF ELSE IF zm EQ 70 THEN BEGIN
             cmd2 = cmd2 + 'large'
           ENDIF ELSE IF zm EQ 103 THEN BEGIN
             cmd2 = cmd2 + 'optimum path'
           ENDIF ELSE IF zm EQ 101 THEN BEGIN
             cmd2 = cmd2 + 'start/target object'
           ENDIF ELSE IF zm EQ 102 THEN BEGIN
             cmd2 = cmd2 + 'missing'
           ENDIF ELSE IF zm EQ 104 THEN BEGIN
             cmd2 = cmd2 + 'unreachable'            
           ENDIF ELSE BEGIN
             cmd2 = cmd2 + strtrim(zm, 2)       
           ENDELSE         
         ENDIF ELSE BEGIN
           IF zm EQ 103 THEN BEGIN
             cmd2 = cmd2 + 'optimum path'
           ENDIF ELSE IF zm EQ 101 THEN BEGIN
             cmd2 = cmd2 + 'start/target object'
           ENDIF ELSE IF zm EQ 102 THEN BEGIN
             cmd2 = cmd2 + 'missing'
           ENDIF ELSE IF zm EQ 104 THEN BEGIN
             cmd2 = cmd2 + 'unreachable'
           ENDIF ELSE BEGIN ;; show value
             cmd2 =  cmd2 + strtrim(zm, 2)
           ENDELSE
         ENDELSE


       ENDIF ELSE IF info.is_cost EQ 2 THEN BEGIN
         ;; show reconnect data
         ;;================
         zm = ( * info.fr_image)[xm, ym] + 0
         IF zm EQ 0 THEN BEGIN ;; we are in the background
           cmd2 = '   background'
         ENDIF ELSE IF zm EQ 33 THEN BEGIN ;;
           cmd2 = '   Restore Pixel'
         ENDIF ELSE IF zm EQ 103 THEN BEGIN ;; missing
           cmd2 = '   Restore Path'
         ENDIF ELSE IF zm EQ 129 THEN BEGIN ;; missing
           cmd2 = '   missing'
         ENDIF ELSE BEGIN ;; show: componentID
           zm2 = ( * info.nw_ids)[xm, ym] + 0 ;; object ID
           zm3 = ( * info.nw_hnw)[zm2] ;; component area
           cmd2 = '   object ID: ' + strtrim(zm2, 2) + ', area: ' + strtrim(zm3, 2)
         ENDELSE


       ENDIF ELSE IF info.is_influ EQ 1 THEN BEGIN
         ;; show influence zones data
         ;;================
         zm = ( * info.nw_ids)[xm, ym] + 0
         IF zm EQ 0 THEN BEGIN ;; we are in the background
           cmd2 = '   background'
         ENDIF ELSE IF zm EQ -1 THEN BEGIN ;; hole inside FG
           cmd2 = '   FG hole'
         ENDIF ELSE IF zm EQ -2 THEN BEGIN ;; neglected FG
           cmd2 = '   neglected FG'
         ENDIF ELSE IF zm EQ -3 THEN BEGIN ;; watershed
           cmd2 = '   watershed'
         ENDIF ELSE IF zm EQ -4 THEN BEGIN ;; missing
           cmd2 = '   missing'
         ENDIF ELSE IF zm EQ -5 THEN BEGIN ;; buffer boundary
           cmd2 = '   buffer boundary'
         ENDIF ELSE IF zm EQ -6 THEN BEGIN ;; buffer
           cmd2 = '   buffer'
         ENDIF ELSE BEGIN ;; show: componentID
           zma = ( * info.nw_hnw)[zm]
           cmd2 = '   influence zone ID: ' + strtrim(zm, 2) + ', area: ' + strtrim(zma, 2) 
         ENDELSE

       ENDIF ELSE IF info.is_influ EQ 2 THEN BEGIN
         ;; show accounting data
         ;;================
         zm = ( * info.nw_ids)[xm, ym] + 0
         IF zm EQ 0 THEN BEGIN ;; we are in the background
           cmd2 = '   background'
         ENDIF ELSE IF zm EQ -1 THEN BEGIN ;; missing
           cmd2 = '   missing'
         ENDIF ELSE IF zm EQ -3 THEN BEGIN ;; water
           cmd2 = '   specialBG1'           
         ENDIF ELSE IF zm EQ -4 THEN BEGIN ;; specialBG
           cmd2 = '   specialBG2'
         ENDIF ELSE BEGIN ;; show: componentID
           pix = ( * info.nw_conns)[xm, ym] + 0
           q = ( * info.fr_image)[xm, ym] + 0
           if q eq 80b then qstr = ' (1 of the 3 largest objects)' else qstr = ''
           cmd2 = '   object ID: ' + strtrim(zm, 2) + ', area: ' + strtrim(pix, 2) + qstr
         ENDELSE

       ENDIF ELSE IF info.is_influ EQ 3 THEN BEGIN
         ;; show proximity data
         ;;================
         zm = ( * info.nw_ids)[xm, ym] + 0
         IF zm EQ 0 THEN BEGIN ;; we are in the background
           cmd2 = '   background'
         ENDIF ELSE IF zm EQ -1 THEN BEGIN ;; hole inside FG
           cmd2 = '   FG hole'
         ENDIF ELSE IF zm EQ -2 THEN BEGIN ;; neglected FG
           cmd2 = '   neglected FG'
         ENDIF ELSE IF zm EQ -3 THEN BEGIN ;; watershed
           zmd = ( * info.nw_conns)[xm, ym] + 0 ;ws-distance
           zmd2 = ( * info.cs22_nodes)[xm, ym] + 0 ; cag          
           cagrel = round(zmd2*100.0/info.allcomp)
           cmd2 = '   watershed, proximity: ' + strtrim(zmd, 2) + ', CAG: ' + $
             strtrim(zmd2, 2) + ' (' + strtrim(cagrel,2) + '%)'
         ENDIF ELSE IF zm EQ -4 THEN BEGIN ;; missing
           cmd2 = '   missing'
         ENDIF ELSE IF zm EQ -5 THEN BEGIN ;; buffer boundary
           cmd2 = '   buffer boundary'
         ENDIF ELSE IF zm EQ -6 THEN BEGIN ;; buffer
           cmd2 = '   buffer'
         ENDIF ELSE BEGIN ;; show: componentID
           zma = ( * info.nw_hnw)[zm]
           cmd2 = '   component ID: ' + strtrim(zm, 2) + ', area: ' + strtrim(zma, 2)
         ENDELSE

      ENDIF ELSE IF info.is_dist EQ 1 THEN BEGIN
         ;; morphdist data
         ;;================
         zm = ( * info.morphdist)[xm, ym] + 0
           cmd2 = '   missing'
         IF zm LT 0.0 THEN BEGIN ;; we are in the background
            cmd2 = '   background: ' + strtrim(zm, 2)
         ENDIF 
         IF zm GT 0.0 THEN BEGIN ;; foreground
            cmd2 =  '    foreground: ' + strtrim(zm, 2)
         ENDIF

       ENDIF ELSE IF (info.is_fragm GT 0) THEN BEGIN
         ;; fragmentation data
         ;;================
         IF info.is_fragm EQ 3 THEN BEGIN 
           if is_fos ge 1 then begin ;; frag_FOS
             zm1 = ( * info.fr_image)[xm, ym] + 0
             z1 = strtrim(zm1, 2)
             
             if is_fos eq 4 then begin
               case 1 of
                 (zm1 LT 40b): zm = '   Separated: ' + z1
                 else: zm = '   Continuous: ' + z1
               endcase
             endif else begin
               case 1 of
                 (zm1 LT 10b): zm = '   Rare: ' + z1
                 (zm1 LT 40b): zm = '   Patchy: ' + z1
                 (zm1 LT 60b): zm = '   Transitional: ' + z1
                 (zm1 LT 90b): zm = '   Dominant: ' + z1
                 (zm1 LT 100b): zm = '   Interior: ' + z1
                 else: zm = '   Intact: ' + z1
               endcase
               if is_fos eq 2 and zm1 eq 100b then zm = '   Interior: ' + z1
             endelse
             cmd2 = '   missing' ;; missing data pixels
             IF zm1 EQ 105 THEN BEGIN ;; we have type 3b, water
               cmd2 = '   specific background 1'
             ENDIF ELSE IF zm1 EQ 106 THEN BEGIN ;; we have type 4b, water
               cmd2 = '   specific background 2'
             ENDIF ELSE IF zm1 EQ 101 THEN BEGIN ;; we are in the background
               cmd2 = '   background'
             ENDIF ELSE IF zm1 LT 101 THEN BEGIN ;; we are in the foreground
               cmd2 = zm
             ENDIF
           endif else begin ;; frag_fad; zm2=5scales, zm1=average over scales                        
             zm1 = ( * info.fr_image)[xm, ym] + 0
             zm2 = (*info.mscale)[*, xm, ym] + 0
             z2 = ' [' + strtrim(zm2[0],2) + '-' + strtrim(zm2[1],2) + '-' + strtrim(zm2[2],2) + '-' + strtrim(zm2[3],2) + '-' + strtrim(zm2[4],2) + ']'
             z1 = strtrim(zm1, 2)
             if is_fad eq 2 then begin
               case 1 of
                 (zm1 LT 40b): zm = '   Separated: ' + z1 + z2
                 else: zm = '   Continuous: ' + z1 + z2
               endcase
             endif else begin
               case 1 of
                 (zm1 LT 10b): zm = '   Rare: ' + z1 + z2
                 (zm1 LT 40b): zm = '   Patchy: ' + z1 + z2
                 (zm1 LT 60b): zm = '   Transitional: ' + z1 + z2
                 (zm1 LT 90b): zm = '   Dominant: ' + z1 + z2
                 (zm1 LT 100b): zm = '   Interior: ' + z1 + z2
                 else: zm = '   Intact: ' + z1 + z2
               endcase
             endelse

             cmd2 = '   missing' ;; missing data pixels
             IF zm1 EQ 105 THEN BEGIN ;; we have type 3b, water
               cmd2 = '   specific background 1'
             ENDIF ELSE IF zm1 EQ 106 THEN BEGIN ;; we have type 4b, water
               cmd2 = '   specific background 2'
             ENDIF ELSE IF zm1 EQ 101 THEN BEGIN ;; we are in the background
               cmd2 = '   background'
             ENDIF ELSE IF zm1 LT 101 THEN BEGIN ;; we are in the foreground
               cmd2 = zm
             ENDIF
           endelse
         ENDIF ELSE BEGIN ;; fragmentation or spatcon
           zm = ( * info.nw_ids)[xm, ym] + 0
           cmd2 = '   missing'
           IF zm EQ 101b THEN BEGIN ;; we are in the background
             cmd2 = '   background'
           ENDIF ELSE IF zm LT 101b THEN BEGIN ;; foreground
             cmd2 =  '    foreground: ' + strtrim(zm, 2) + '%'
           ENDIF
         ENDELSE

       ENDIF ELSE IF info.is_contort GT 0 THEN BEGIN
         ;; contortion data  [-1 missing, 0 BG, 2 -> whatever in FG]
         ;;================
         zm = ( * info.contort)[xm, ym] + 0
         cmd2 = '   boundary'
         IF zm GT 1 THEN BEGIN ;; foreground
           cmd2 = '   foreground: ' + strtrim(zm, 2)
         ENDIF else if zm EQ 0 THEN BEGIN ;; background
           cmd2 =  '    background'
         ENDIF else if zm EQ 1 THEN BEGIN ;; neglected object
           cmd2 =  '    neglected object: ' + strtrim(zm, 2)
         ENDIF else begin ;; missing pixels
           cmd2 = '   missing'
         Endelse

       ENDIF ELSE IF is_lm EQ 1 THEN BEGIN
         ;; LM data [0 missing, 1-19 LM-classes]
         ;;================
         zm = ( * info.fr_image)[xm, ym] + 0
         case zm of
           0: cmd2 = '   missing'
           1: cmd2 = '   A: ' + strtrim(zm, 2)
           2: cmd2 = '   D: ' + strtrim(zm, 2)
           3: cmd2 = '   N: ' + strtrim(zm, 2)
           4: cmd2 = '   Ad: ' + strtrim(zm, 2)
           5: cmd2 = '   An: ' + strtrim(zm, 2)
           6: cmd2 = '   Dn: ' + strtrim(zm, 2)
           7: cmd2 = '   Da: ' + strtrim(zm, 2)
           8: cmd2 = '   Na: ' + strtrim(zm, 2)
           9: cmd2 = '   Nd: ' + strtrim(zm, 2)
           10: cmd2 = '   Adn: ' + strtrim(zm, 2)
           11: cmd2 = '   Dan: ' + strtrim(zm, 2)
           12: cmd2 = '   Nad: ' + strtrim(zm, 2)
           13: cmd2 = '   ad: ' + strtrim(zm, 2)
           14: cmd2 = '   an: ' + strtrim(zm, 2)
           15: cmd2 = '   dn: ' + strtrim(zm, 2)
           16: cmd2 = '   adn: ' + strtrim(zm, 2)
           17: cmd2 = '   NN: ' + strtrim(zm, 2)
           18: cmd2 = '   AA: ' + strtrim(zm, 2)
           19: cmd2 = '   DD: ' + strtrim(zm, 2)
           else: cmd2 = '   invalid setting: ' + strtrim(zm, 2)
         endcase

       ENDIF ELSE IF is_spa EQ 2 THEN BEGIN
         ;; SPA2 data [0-BG, 1-SLF, 17-contiguous, 129-missing]
         ;;================
         zm = ( * info.fr_image)[xm, ym] + 0
         case zm of
           0: cmd2 = '   background: ' + strtrim(zm, 2)
           1: cmd2 = '   SLF: ' + strtrim(zm, 2)
           17: cmd2 = '   Contiguous: ' + strtrim(zm, 2)
           129: cmd2 = '   missing: ' + strtrim(zm, 2)
           else: cmd2 = '   invalid setting: ' + strtrim(zm, 2)
         endcase

      ENDIF ELSE IF is_spa EQ 3 THEN BEGIN
         ;; SPA3 data [0-BG, 1-margin, 17-core, 100-holes, 129-missing]
         ;;================
         zm = ( * info.fr_image)[xm, ym] + 0
         case zm of
           0: cmd2 = '   background: ' + strtrim(zm, 2)
           1: cmd2 = '   Margin: ' + strtrim(zm, 2)
           17: cmd2 = '   Core: ' + strtrim(zm, 2)
           100: cmd2 = '   Core-Opening: ' + strtrim(zm, 2)
           129: cmd2 = '   missing: ' + strtrim(zm, 2)
           else: cmd2 = '   invalid setting: ' + strtrim(zm, 2)
         endcase

       ENDIF ELSE IF is_spa GT 3 THEN BEGIN
         ;; SPA5/6 data [0-BG, 1-margin, 3-edge, 9-islet, 17-core, 65-perf, 100-holes, 129-missing]
         ;;================
         zm = ( * info.fr_image)[xm, ym] + 0
         case zm of
           0: cmd2 = '   background: ' + strtrim(zm, 2)
           1: cmd2 = '   Margin: ' + strtrim(zm, 2)
           3: cmd2 = '   Edge: ' + strtrim(zm, 2)
           9: cmd2 = '   Islet: ' + strtrim(zm, 2)
           17: cmd2 = '   Core: ' + strtrim(zm, 2)
           5: cmd2 = '   Perforation: ' + strtrim(zm, 2)
           100: cmd2 = '   Core-Opening: ' + strtrim(zm, 2)
           129: cmd2 = '   missing: ' + strtrim(zm, 2)
           else: cmd2 = '   invalid setting: ' + strtrim(zm, 2)
         endcase

       ENDIF ELSE IF is_mcd EQ 1 THEN BEGIN
         ;; morph change
         zm = ( * info.fr_image)[xm, ym] + 0
         case zm of
           11: cmd2 = '   BG-stable: ' + strtrim(zm, 2)
           22: cmd2 = '   FG-stable: ' + strtrim(zm, 2)
           21: cmd2 = '   Loss: ' + strtrim(zm, 2)
           12: cmd2 = '   Gain: ' + strtrim(zm, 2)
          176: cmd2 = '   spurious: ' + strtrim(zm, 2)
          255: cmd2 = '   missing: ' + strtrim(zm, 2)
          else: cmd2 = '   invalid setting: ' + strtrim(zm, 2)
         endcase

       ENDIF ELSE IF is_mcd EQ 2 THEN BEGIN
         ;; morph change
         zm = ( * info.fr_image)[xm, ym] + 0
         case zm of
           11: cmd2 = '   BG-stable: ' + strtrim(zm, 2)
           22: cmd2 = '   FG-stable: ' + strtrim(zm, 2)
           21: cmd2 = '   Loss: ' + strtrim(zm, 2)
           12: cmd2 = '   Gain: ' + strtrim(zm, 2)
           255: cmd2 = '   missing: ' + strtrim(zm, 2)
           else: cmd2 = '   invalid setting: ' + strtrim(zm, 2)
         endcase

      ENDIF ELSE BEGIN
      ;; normal data
      ;;===============
         normdat1:
         zm = ( * info.fr_image)[xm, ym] + 0
         cmd2 =  '   Value: ' + strtrim(zm, 2) + ' (' + info.datatype +')'
         IF (strpos(info.add_title,'FGConn for Path setup') GT 0) AND (info.is_cost EQ 7) then begin
           zm2 = ( * info.nw_ids)[xm, ym] + 0 ;; object ID
           zm3 = ( * info.nw_hnw)[zm2] ;; object area
           if zm2 eq 0 then cmd2 = '   background' else $
             cmd2 = '   object ID: ' + strtrim(zm2, 2) + ', area: ' + strtrim(zm3, 2) +'; '
           if zm eq 129 then cmd2 = '   missing'
         ENDIF 
         
      ENDELSE
   ENDELSE
   
   cmd3=''
   IF info.def_marker gt 0 then begin
     ;; show marker information
     ;;========================
     case info.def_marker of
       1: cmd3 = ' Object A: click & press Enter key'
       2: cmd3 = ' Object B: click & press Enter key'
       3: cmd3 = ' Missing data: click & press Enter key'
     endcase
   ENDIF

   cmd = 'X: ' + strtrim(xm + 1, 2) + '   Y: ' + strtrim(ymi + 1, 2) + cmd2 + cmd3
  ; if strmid(cmd2,3,6) eq 'object' then cmd = cmd + cmd3
   IF info.def_marker gt 0 then goto, normdat3
   
   ;; add the MSPA class name acc. to the selected parameter 4 intext
   IF info.is_mspa EQ 1 THEN BEGIN
      if info.do_label_groups_id eq 0 then begin
        info.mspa_class_ext(17) = 'CORE'
        info.mspa_class_int(17) = 'CORE (external)'
        info.mspa_class_int(117) = 'CORE (internal)'
      endif else begin
        info.mspa_class_ext(17) = 'CORE (medium)'
        info.mspa_class_int(17) = 'CORE (medium, external)'
        info.mspa_class_int(117) = 'CORE (medium, internal)'        
      endelse
   
      IF info.mspa_param4_id EQ 1b THEN $
       class = info.mspa_class_int(zm) ELSE $
       class = info.mspa_class_ext(zm)
      cmd = cmd + '     MSPA class: ' + class
   ENDIF
   normdat3:
   WIDGET_CONTROL, info.w_rdpx, SET_VALUE = cmd
ENDIF

condi = (info.is_cost EQ 3) OR (info.is_cost EQ 9)

IF NOT condi THEN BEGIN
  ;IF info.is_cost NE 3 THEN BEGIN
  ;; setup of the zooming window 
  IF event.type EQ 0 AND event.press EQ 1 THEN BEGIN
    ;;==========================================================
    ;;
    ;print, 'left button pressed and no movement'
    ;;
    ;; Set the static corners of the box to current cursor location.
    info.xs = event.x
    info.ys = event.y
    info.set_zoom = 1  ;; set zoom-switch to on
    ;; Turn draw MOTION events ON.
    Widget_Control, event.id, Draw_Motion_Events = 1

  ENDIF ELSE IF event.type EQ 2 AND info.set_zoom EQ 1 THEN BEGIN ;;AND event.press EQ 1
    ;;==========================================================
    ;;
    ;print, 'left button pressed and movement'
    ;;
    ;; left mouse button is kept pressed down
    ;; Most of the action in this event handler occurs here while we
    ;; are waiting for an UP event to occur. As long as we don't get
    ;; it, keep erasing the old zoom box and drawing a new one.

    ;; Erase the old zoom box.
    Widget_Control, info.w_draw, Get_Value = draw_ID
    info.draw_ID = draw_ID
    WSet, info.draw_ID
    Device, Copy = [0, 0, info.xsize, info.ysize, 0, 0, info.pix_ID]

    ;; Update the dynamic corner of the zoom box to the current
    ;; cursor location.
    info.xd = event.x
    info.yd = event.y

    ;; Load a green color in color index 1 to draw the zoom box with.
    TVLCT, 0B, 255B, 0B, info.colorId

    ;; Draw the zoom box.
    PlotS, [info.xs, info.xs, info.xd, info.xd, info.xs], $
      [info.ys, info.yd, info.yd, info.ys, info.ys], $
      / Device, Color = info.colorId

    ;; put the color back to not interfere with the image color
    TVLCT, 0B, 0B, 0B, info.colorId

  ENDIF ELSE IF event.type EQ 1 AND info.set_zoom EQ 1 THEN BEGIN ;; AND event.press EQ 1
    ;;==========================================================
    ;;
    ;print, 'left button is released and no movement'
    ;;
    ;; If this is an UP event, you need to erase the zoombox, restore
    ;; the user's color table, turn motion events OFF, and
    ;; draw the "zoomed" plot in both the draw widget and the pixmap.
    restore, info.dir_tmp2 + 'currcolors.sav' & tvlct, r, g, b

    ;; Erase the zoombox one final time by copying the plot from the
    ;; pixmap.
    WSet, info.draw_ID
    widget_control, / hourglass

    Device, Copy = [0, 0, info.xsize, info.ysize, 0, 0, info.pix_ID]

    ;; Turn motion events off.
    ;Widget_Control, event.id, Draw_Motion_Events = 0

    ;; Draw the "zoomed" image. Start by getting the LAST zoom
    ;; box outline. These are indices into image array.
    event.x = 0 > event.x < (info.xsize - 1)
    event.y = 0 > event.y < (info.ysize - 1)
    x = [info.xs, event.x]
    y = [info.ys, event.y]

    ;; Make sure the selected sub-region is big enough for
    ;; processing or the user didn't just click in the window.
    IF abs(info.xs - event.x) LT 10 OR abs(info.ys - event.y) LT 10 $
      THEN BEGIN
      Widget_Control, event.top, Set_UValue = info, / No_Copy
      RETURN
    ENDIF


    ;; Make sure the x and y values are ordered as [min, max].
    IF info.xs GT event.x THEN x = [event.x, info.xs]
    IF info.ys GT event.y THEN y = [event.y, info.ys]
    info.x = x
    info.y = y

    ;; when in fullres mode, reset the image to the original fullres
    ;; one and adapt the rescaling factor to transfer the selected ROI
    ;; from the downscaled image to the fullres one

;;; PV    IF info.bigim THEN z = * info.fr_image ELSE z = * info.process
    z = * info.fr_image
    x = x * info.resfac & y = y * info.resfac & zdim = size(z,/dim)

    ;; apply the zoom factor and determine the new X and Y
    ;; sizes of the Zoom Window.
    zoomXSize = (x(1) - x(0) + 1) * info.zoomFactor
    zoomYSize = (y(1) - y(0) + 1) * info.zoomFactor

    ;; Subset the image, and apply the zoom factor to it.
    ;; constrain to be within the image dimensions
    x01 = (x(1) + 1) < zdim[0] - 1 & y01 = (y(1) + 1) < zdim[1] - 1
    imageSubset = z(x(0):x01, y(0):y01)
    ;;testing
    ;; tofix: of a 1000 x 1000 image the zommed area shows
    ;; x: 1 - 999
    ;; y: 2 - 1000
    ;; how to have it show the missing x=1000 and y=1 (top line and right column)?

    zoomedImage = rebin(imageSubset, zoomXSize, zoomYSize, / sample)

    ;; Get offset positions for the non-existing zoom window.
    Widget_Control, event.top, TLB_Get_Size = sizes, $
      TLB_Get_Offset = offsets
    xpos = sizes[0] + offsets[0] + 20
    ypos = offsets[1] + 40

    info.xpos = xpos
    info.ypos = ypos


    ;; update the subimage in the info structure
    * info.subimage = zoomedImage

    ;; store the full process image
    * info.prezoomprocess = * info.process

    ;; set the zoomed image to the process image
    * info.process = * info.subimage
    ;   drawcont:
    s_ROI = size( * info.process)

    ;; turn off ROI select and disable zoom select, enable ROI define
    ;;info.selsubregion_id = 0  ;;why this ?? pv2do
    widget_control, info.w_selsubregion, sensitive = 1
    frag_colors = (info.disp_colors_id EQ 3 AND (size( * info.process))[3] EQ 1)
    widget_control, info.w_autostretch, set_value = info.autostretch_id

    ;; display the updated image in the pixmap window from where the
    ;; zoomed subset is copied
    ;; restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b
    wset, info.pix_id
    IF frag_colors THEN guidos_image, * info.process, 0 ELSE $
      guidos_image, * info.process, info.autostretch_id

    ;; make the draw widget window the current graphics window +
    ;; show image
    widget_control, info.w_drawbase, map = 0
    widget_control, info.w_draw, / destroy
    IF s_ROI(1) GT info.xsize OR s_ROI(2) GT info.ysize THEN BEGIN
      info.w_draw = $
        widget_draw(info.w_drawbase, $ ;; no more button_events required!!
        xsize = s_ROI(1), ysize = s_ROI(2), $
        x_scroll_size = s_ROI(1) < info.xsize, $
        y_scroll_size = s_ROI(2) < info.ysize, $
        / app_scroll, retain = 2, / motion_events)
    ENDIF ELSE BEGIN
      info.w_draw = $
        widget_draw(info.w_drawbase, xsize = s_ROI(1), $
        ysize = s_ROI(2), retain = 2, / motion_events)
    ENDELSE
    widget_control, info.w_draw, / realize
    widget_control, info.w_draw, get_value = draw_ID
    info.draw_ID = draw_ID
    widget_control, info.w_drawbase, map = 1

    wset, info.draw_id
    widget_control, info.tlb, tlb_set_title = info.title + info.add_title
    IF frag_colors THEN guidos_image, * info.process, 0 ELSE $
      guidos_image, * info.process, info.autostretch_id
    widget_control, info.w_draw, set_draw_view = [0, 0]

    ;; switch off selsubregion and deactivate zoomfactor selector
    ;;info.selsubregion_id = 0 ;; why switch off? pv2do
    widget_control, info.w_zoomfac, sensitive = 1
    ;widget_control, info.w_selsubregion, / sensitive
    info.set_zoom = 0 ;; subregion is now defined so switch setzoombox indicator off
    ;; set back to zero to allow for reading of images values

    ;; set sroll x/y to zero
    info.scroll_x = 0 & info.scroll_y = 0
    
    ;; reset temporary custom path switch
    if info.is_cost eq 7 then info.is_cost = 3
    if info.is_cost eq 79 then info.is_cost = 9


  ENDIF ELSE IF event.type EQ 3 THEN BEGIN
    ;;==========================================================
    ;;print, ' scroll event'
    ;; display the updated image in the pixmap window from where the
    ;; zoomed subset is copied
    ;;  restore, info.dir_guidossub + 'mspacolorston.sav' & tvlct, r, g, b

    frag_colors = (info.disp_colors_id EQ 3 AND (size( * info.process))[3] EQ 1)

    wset, info.pix_id
    IF frag_colors THEN guidos_image, * info.process, $
      0, 0 - event.x, 0 - event.y ELSE $
      guidos_image, * info.process, info.autostretch_id, $
      0 - event.x, 0 - event.y

    ;; make the draw widget window the current graphics window +
    ;; show image
    wset, info.draw_id
    IF frag_colors THEN guidos_image, * info.process, $
      0, 0 - event.x, 0 - event.y ELSE $
      guidos_image, * info.process, info.autostretch_id, $
      0 - event.x, 0 - event.y
    ;; store the scroll x/y information
    info.scroll_x = event.x & info.scroll_y = event.y
    
    ;; reset temporary custom path switch
    if info.is_cost eq 7 then info.is_cost = 3
    if info.is_cost eq 79 then info.is_cost = 9


  ENDIF else IF info.def_marker gt 0 THEN BEGIN
    Widget_Control, event.id, Draw_Keyboard_Events = 1

    IF event.type EQ 5 THEN BEGIN
      ;;==========================================================
      rsf = info.resfac & sy = (size( * info.fr_image, / dim))[1]
      ;; constrain x/y to be within image coordinates
      event.x = 0 > event.x < (info.xsize - 1)
      event.y = 0 > event.y < (info.ysize - 1)

      IF info.selsubregion_id EQ 0 THEN BEGIN
        ;;=============================================================
        ;; mouse move in ORIGINAL display:
        ;; show image position, value, class
        ;;=============================================================
        ;; event positions need to be mutliplied by resfac
        ;; to account for images larger than the display
        xm = (event.x * rsf) < sx1 & ym = (event.y * rsf) < sy1
        ymi = sy1 - ym
      endif else begin
        ;; zoomed window
        x = info.x * rsf & y = info.y * rsf
        ;; current x/y coordinate of the mouse pointer in the enlarged
        ;; image and the value at this location
        xm = (x[0] + (event.x + info.scroll_x) / info.zoomfactor) < sx1
        ym = (y[0] + (event.y + info.scroll_y) / info.zoomfactor) < sy1
        ymi = sy1 - ym
      endelse

      pstr = '(' + strtrim(xm+1,2) + ',' + strtrim(ymi+1,2) + ')'
      pstr1 = strtrim(xm+1,2) + '/' + strtrim(ymi+1,2)

      ;; test if we define LCP within proximity image
      IF strpos(info.add_title,'FGConn for Path setup') GT 0 then proxlcp=1 else proxlcp=0

      ;; object A
      ;;===========
      if info.def_marker eq 1 then begin ;; object A
        wtit = 'Setup Marker Image, Step 1: define object A'
        cancel = ptr_new(1b) & opolpi = ptr_new(0b)
        get_marker, cancel = cancel, opolpi=opolpi, wtitle = wtit, costr = pstr1, proxlcp = proxlcp, Group_Leader = event.top

        IF * cancel EQ 0b THEN BEGIN
          ;; object A is defined
          aobject=[xm+1,ym+1] & apol = *opolpi eq 0
          ;; free and delete the temporary pointers
          ptr_free, cancel & cancel = 0b
          ptr_free, opolpi & opolpi = 0b

          IF proxlcp eq 0 then begin
            msg = 'Object A is now defined. Please select: ' + string(10b) + $
              'Yes: to define object B and/or missing data'  + string(10b) + $
              'No: to finish setup of marker image.'
            res = dialog_message(msg, title = strmid(wtit,0,27), / question)
          ENDIF ELSE BEGIN
            ;; test if the selected pixel is valid (must be 12b:=green pixel of component)
            q = (*info.fr_image)[xm,ym]
            IF q ne 150b THEN BEGIN ;; bail out
              info.def_marker = 0
              Widget_Control, event.id, Draw_Button_Events = 0
              Widget_Control, event.id, Draw_Motion_Events = 1
              Widget_Control, event.id, Draw_Keyboard_Events = 0
              msg = 'Setup of marker image canceled.' + string(10b) + $
                'Please select a (gray) object pixel.'+ string(10b) + 'Returning...'
              res = dialog_message(msg, title='Setup Marker Image',/ information)
              goto,fin
            ENDIF
            msg = 'Object A is now defined.' + string(10b) + $
              'Please continue to define object B.'
            res = dialog_message(msg, title = strmid(wtit,0,27), / information)
          ENDELSE
          save, aobject, apol, filename = info.dir_data + 'markertmp.sav'
          if res eq 'No' then begin
            bpol = 3b & cpol = 0b
            goto, writemarker
          endif

        ENDIF ELSE BEGIN
          ;; cancel selected, back out and inform
          ;; reset all stuff for marker image
          ;; free and delete the temporary pointers
          ptr_free, cancel & cancel = 0b
          ptr_free, opolpi & opolpi = 0b
          info.def_marker = 0
          Widget_Control, event.id, Draw_Button_Events = 0
          Widget_Control, event.id, Draw_Motion_Events = 1
          Widget_Control, event.id, Draw_Keyboard_Events = 0
          msg = 'Setup of marker image canceled.' + string(10b) + 'Returning...'
          res = dialog_message(msg, title='Setup Marker Image',/ information)
          goto,fin
        ENDELSE


        ;; object B
        ;;===========
      endif else if info.def_marker eq 2 then begin
        wtit = 'Setup Marker Image, Step 2: define object B'
        cancel = ptr_new(1b) & opolpi = ptr_new(0b)
        get_marker, cancel = cancel, opolpi=opolpi, wtitle = wtit, costr = pstr1, proxlcp = proxlcp, Group_Leader = event.top

        IF * cancel EQ 0b THEN BEGIN
          ;; object B is defined
          bobject=[xm+1,ym+1] & bpol = *opolpi eq 0
          ;; free and delete the temporary pointers
          ptr_free, cancel & cancel = 0b
          ptr_free, opolpi & opolpi = 0b

          IF proxlcp eq 0 then begin
            msg = 'Object B is now defined. Please select Yes/No: ' + string(10b) + $
              'Yes: to define missing data'  + string(10b) + $
              'No: to finish setup of marker image.'
            res = dialog_message(msg, title = strmid(wtit,0,27), / question)
          ENDIF ELSE BEGIN
            q = (*info.fr_image)[xm,ym]
            IF q ne 150b THEN BEGIN ;; bail out
              info.def_marker = 0
              Widget_Control, event.id, Draw_Button_Events = 0
              Widget_Control, event.id, Draw_Motion_Events = 1
              Widget_Control, event.id, Draw_Keyboard_Events = 0
              msg = 'Setup of marker image canceled.' + string(10b) + $
                'Please select a (gray) object pixel.'+ string(10b) + 'Returning...'
              res = dialog_message(msg, title='Setup Marker Image',/ information)
              goto,fin
            ENDIF
            msg = 'Object B is now defined.'
            res = dialog_message(msg, title = strmid(wtit,0,27), / information)
            ;cpol = 0b
            ;goto, writemarker
          ENDELSE
          ;; add info on object B to sav-file
          restore, info.dir_data + 'markertmp.sav'
          save, aobject, apol, bobject, bpol, filename = info.dir_data + 'markertmp.sav'
          if res eq 'No' or proxlcp eq 1 then begin
            cpol = 0b
            goto, writemarker
          endif

        ENDIF ELSE BEGIN
          ;; cancel selected <=> object B is not needed/defined
          ;; free and delete the temporary pointers
          ptr_free, cancel & cancel = 0b
          ptr_free, opolpi & opolpi = 0b
          bpol = 3b
          IF proxlcp eq 1 then begin
            info.def_marker = 0
            Widget_Control, event.id, Draw_Button_Events = 0
            Widget_Control, event.id, Draw_Motion_Events = 1
            Widget_Control, event.id, Draw_Keyboard_Events = 0
            msg = 'Setup of marker image canceled.' + string(10b) + 'Returning...'
            res = dialog_message(msg, title='Setup Marker Image',/ information)
            goto,fin
          ENDIF

          msg = 'Object B not needed. Please select Yes/No: ' + string(10b) + $
            'Yes: to define missing data'  + string(10b) + $
            'No: to finish setup of marker image.'
          res = dialog_message(msg, title = wtit, / question)
          ;; add info on not using object B to sav-file
          restore, info.dir_data + 'markertmp.sav'
          save, aobject, apol, bpol, filename = info.dir_data + 'markertmp.sav'
          if res eq 'No' then begin
            cpol = 0b
            goto, writemarker
          endif

        ENDELSE


        ;; missing data
        ;;===========
      endif else if info.def_marker ge 3 then begin ;; missing data
        msg = 'Pixel ' + pstr + ' selected for missing data. ' + string(10b) + $
          'All pixels having the same value as pixel ' + pstr + string(10b) + $
          'will be marked as missing data.' + string(10b)  + string(10b) + $
          'The marker image is now defined.'
        res = dialog_message(msg, title='Setup Marker Image, Step 3: define missing data',/ information)
        cobject=[xm+1,ym+1] & cpol = 1b
        goto, writemarker
      endif

      info.def_marker = info.def_marker + 1
    endif

    goto,fin

    ;; we are done, write out the marker image
    writemarker:
    ;; reset all stuff for marker image
    info.def_marker = 0
    Widget_Control, event.id, Draw_Button_Events = 0
    Widget_Control, event.id, Draw_Motion_Events = 1
    Widget_Control, event.id, Draw_Keyboard_Events = 0
    ;; get fullres image
    image0 = *info.fr_image & sz = size(image0,/dim)

    ;; labeling must be done on extended image to avoid
    ;; zeroed boundaries, go back to original dimension later
    ext = bytarr(sz(0) + 2, sz(1) + 2) & sz2=size(ext,/dim)
    ext[1:1 + sz(0) - 1, 1:1 + sz(1) - 1] = temporary(image0) & all_n = 1
    widget_control, / hourglass
    marker = ext * 0b

    ;; Step 1: object A
    ;;========================
    restore, info.dir_data + 'markertmp.sav' & file_delete, info.dir_data + 'markertmp.sav', / quiet

    if apol eq 0b then begin ;; point A
      marker[aobject[0], aobject[1]] = 1b
    endif else begin ;; polygon encompassing point A
      q = ext[aobject[0], aobject[1]] ; class value at point A
      objects = label_region(ext eq q, all_neighbors=all_n, / ulong)
      qob = objects[aobject[0], aobject[1]] & q = where(objects eq qob)
      marker[q]= 1b & objects=0
    endelse


    ;; Step 2: object B
    ;;========================
    if bpol eq 0b then begin ;; point B
      marker[bobject[0], bobject[1]] = 2b
    endif else if bpol eq 1b then begin ;; polygon encompassing point B
      q = ext[bobject[0], bobject[1]] ; class value at point B
      objects = label_region(ext eq q, all_neighbors=all_n, / ulong)
      qob = objects[bobject[0], bobject[1]] & q = where(objects eq qob)
      marker[q]= 2b & objects=0
    endif

    ;; Step 3: missing data
    ;;========================
    if cpol ne 0b then begin ;; missing data was defined
      q = ext[cobject[0], cobject[1]] ; class value for the missing data
      q = where(ext eq q, ct, /l64)
      if ct gt 0 then marker[q] = 3b
    endif

    ;; go back to original dimension and write out marker image
    marker = marker[1:sz2(0) - 2, 1:sz2(1) - 2]
    IF proxlcp eq 1 THEN BEGIN
      ;; test that marker image is suitable
      ;; test for minimum set of required values:
      s = size(marker)
      ;; add missing data if they exist
      q = where(* info.orig_image eq 0b, ct_q, /l64)
      IF ct_q GT 0 THEN marker[q] = 3b
      
      marker_vals = where(histogram(marker) gt 0) & n_marker_vals = n_elements(marker_vals)
      if marker_vals[1] eq 2 then begin
        msg = 'Looks like you selected 2 points ' + string(10b) + $
          'within the same object. '  + string(10b) + $
          'Setup of marker image canceled.' + string(10b) + 'Returning...'
        res = dialog_message(msg, / information) & GOTO, fin
      endif
      condition = marker_vals[0] eq 0 AND marker_vals[1] eq 1 AND marker_vals[2] eq 2
      IF condition NE 1b THEN BEGIN
        msg = 'Marker map must have at least the following values: ' + string(10b) + $
          '0b: background '  + string(10b) + $
          '1b: foreground object A'  + string(10b) + $
          '2b: foreground object B'  + string(10b) + $
          'Returning.'
        res = dialog_message(msg, / information) & GOTO, fin
      ENDIF
      IF n_marker_vals GE 4 THEN BEGIN
        IF marker_vals[3] eq 3 THEN BEGIN ;; we have missing data
          ;; test if A and B are within the same blob, else we can not get a LCP
          ;; how: flood-fill complement of missing and check if A and B are in different blobs
          ;; labeling must be done on extended image to avoid problems if objects are at the image border
          im = bytarr(s[1]+2,s[2]+2)+255b
          im[1:s[1],1:s[2]] = (marker eq 3b) - 1b
          im = label_region(im,/all_n,/ulong) & im = im[1:s[1],1:s[2]]                  
          q = where(marker eq 1b) & v1 = mean(im[q])
          q = where(marker eq 2b) & v2 = mean(im[q])
          im = 0 & eps=1.0e-4 & condition = abs(v1 - v2) lt eps
          
          IF condition EQ 0b THEN BEGIN
            ;; A and B are disjoint
            msg = 'Marker object A and B can not be connected.' + string(10b) + 'Returning.'
            res = dialog_message(msg, / information) & GOTO, fin
          ENDIF
        ENDIF
      ENDIF
      ;; now we are good to go
      p = strpos(info.add_title,'BGresist:')
      tt = strmid(info.add_title,p+10)
      p2 = strpos(tt, '%')
      bgresist = strmid(tt, 0, p2)
      save, marker, filename = info.dir_tmp + 'marker.sav';,/compress
      marker=0
      msg = 'Reconnect Marker Image setup successfully.' + string(10b) + $
        'Please click on FGConn to calculate the Restore Path.' + string(10b) + string(10b) + $
        'Note: ' + string(10b) + $
        'FG-resistance is fixed at: 2%,' + string(10b) + $
        'BG-resistance is set to: ' + bgresist +'%.'
      res = dialog_message(msg, / information) & GOTO, fin
    ENDIF
    if info.is_cost ne 2 then begin
      fn_out = info.dir_data + info.title + '_marker.tif'
      IF info.is_geotiff EQ 1b THEN $
        write_tiff, fn_out, rotate(marker,7), geotiff = * info.geotiffinfo , description = desc, compression = 1 ELSE $
        write_tiff, fn_out, rotate(marker,7), description = desc, compression = 1
      marker = 0
      msg = 'The marker image was saved as: ' + string(10b) + fn_out + string(10b) + 'Returning...'
      res = dialog_message(msg, title='Setup Marker Image',/ information)
    endif

  ENDIF ;; info.def_marker gt 0

ENDIF ELSE IF info.is_cost EQ 3 OR info.is_cost EQ 9 THEN BEGIN
  ;;=======================================================================================
  ;; draw line events
  ;;=======================================================================================
  ;; Deal only with DOWN, UP, and MOTION events.
  IF event.type GT 2 THEN RETURN
  
  ;; What kind of event is this?
  eventTypes = ['DOWN', 'UP', 'MOTION']
  thisEvent = eventTypes[event.type]
  whichButton = ['NONE', 'LEFT', 'MIDDLE', 'NONE', 'RIGHT'] 
  ;print, 'Event: ',thisevent, '  Button used: ', info.buttonUsed
  
  IF (thisEvent EQ 'DOWN') THEN BEGIN
    ;;==========================================================
    ;;
    ;; Which button was used? LEFT or RIGHT?
    info.buttonUsed = whichButton(event.press)

    ;print, 'left/right button pressed and no movement'

    ; Initialize the starting coordinates of the draw line.
    IF info.buttonUsed EQ 'RIGHT' THEN BEGIN
        info.xs = event.x 
        info.ys = event.y
    ENDIF ELSE BEGIN
        info.xvalues = Ptr_New([event.x])
        info.yvalues = Ptr_New([event.y])
    ENDELSE

    ; Turn motion events on for the draw widget.
    WSet, info.draw_ID
    Widget_Control, info.draw_ID, Draw_Motion_Events=1

  ENDIF ELSE IF (thisEvent EQ 'MOTION') AND (info.buttonUsed EQ 'LEFT' or info.buttonUsed EQ 'RIGHT') THEN BEGIN
      ;;==========================================================
      ;; Here is where the actual line is drawn and erased.
      ;; First, erase the last line.
      ;print, 'left/right button pressed and movement'
      WSet, info.draw_ID
      Widget_Control, info.draw_ID, Draw_Motion_Events=1
      Device, Copy=[0, 0, info.xsize, info.ysize, 0, 0, info.pix_ID]
      ;; Load a red color in color index 1 to draw the line with.
      TVLCT, 255B, 0B, 0B, info.colorId

      IF info.buttonUsed EQ 'RIGHT' THEN BEGIN
        ;; Draw a straight line.
        PlotS, [info.xs, event.x], [info.ys, event.y], /Device, color = info.colorID
      ENDIF ELSE BEGIN
        ;; Get the points of the new free-hand line and draw it.
        *info.xvalues = [*info.xvalues, event.x]
        *info.yvalues = [*info.yvalues, event.y]
        PlotS, *info.xvalues, *info.yvalues, /Device, color = info.colorID
      ENDELSE

  ENDIF ELSE IF (thisEvent EQ 'UP') THEN BEGIN
      ;print, 'left/right button is released and no movement'
      
      ;; Turn draw motion events off. Clear events queued for widget.
      Widget_Control, info.draw_ID, Draw_Motion_Events = 0, Clear_Events=1
     
      IF info.is_cost EQ 3 THEN BEGIN
        res = file_info(info.dir_tmp + 'customLCP.sav')
        IF res.exists EQ 0b THEN BEGIN
          msg = "Please first setup your image via either:" + string(10b) + $
            "'Add Custom Path' or 'Find Optimum Path'"
          res = dialog_message(msg, / error)
          GOTO, fin
        ENDIF
        restore, info.dir_tmp + 'customLCP.sav'
      ENDIF
      ;; Make sure the selected line is big enough for
      ;; processing or the user didn't just click in the window.
      
      IF info.buttonUsed EQ 'RIGHT' THEN pointclick = (info.xs EQ event.x) AND (info.ys EQ event.y) ELSE $
         pointclick = (n_elements(*info.yvalues) EQ 1)
      
      IF pointclick THEN BEGIN
        ;; Reset everything:
        ;; Turn draw motion events off. Clear events queued for widget.
        Widget_Control, info.draw_ID, Draw_Motion_Events = 0, Clear_Events=1
        info.xs = -1 & info.ys = -1
        Ptr_Free, info.xvalues
        Ptr_Free, info.yvalues
        info.xvalues = Ptr_New()
        info.yvalues = Ptr_New()
        info.buttonUsed = 'NONE'
        ;; put the color back to not interfere with the image color
        TVLCT, 0B, 0B, 0B, info.colorId
        info.is_cost = 4 & gain = 0.0
        
        IF info.is_cost EQ 3 THEN BEGIN
          restore, info.dir_tmp2 + 'currcolors.sav' & tvlct, r, g, b
          q = strpos(inatit,';',/reverse_search)
          info.add_title = strmid(inatit,0,q+1) + ' DELTA_COH: ' + strtrim(gain,2) + '%; tick FGConn to reset)'
          widget_control, info.tlb, tlb_set_title = info.title + info.add_title
          msg = 'Keep the mouse button pressed to draw a line.' + string(10b) + string(10b) + $
            'tick FGconn to reset'         
        ENDIF ELSE BEGIN
          msg = 'Keep the mouse button pressed to draw a line.' 
        ENDELSE
        res = dialog_message(msg, title='Custom Path setup',/ information)               
        goto, fin
      ENDIF    
      
      ;; Erase the last line drawn. 
      WSet, info.draw_ID
      Device, Copy=[0, 0, info.xsize, info.ysize, 0, 0, info.pix_ID]

      
      ;; Load a red color in color index 1 to draw the line with.
      TVLCT, 255B, 0B, 0B, info.colorId

      ;; Draw the final line.
      IF info.buttonUsed EQ 'RIGHT' THEN BEGIN
        straightline = 1
        PlotS, [info.xs, event.x], [info.ys, event.y], /Device, color = info.colorID
        
        ;; store points for drawing in original image
        IF info.selsubregion_id EQ 0 THEN BEGIN ;; non-zoomed
          xm = (info.xs * rsf) < sx1 & ym = (info.ys * rsf) < sy1 & loc_a = [xm, ym]
          xm = (event.x * rsf) < sx1 & ym = (event.y * rsf) < sy1 & loc_b = [xm, ym]        
        ENDIF ELSE BEGIN ;; enlarged display
          x = (info.x * rsf) < sx1 & y = (info.y * rsf) < sy1 
          xm = (x[0] + (info.xs + info.scroll_x) / info.zoomfactor) < sx1
          ym = (y[0] + (info.ys + info.scroll_y) / info.zoomfactor) < sy1
          loc_a = [xm, ym]
          xm = (x[0] + (event.x + info.scroll_x) / info.zoomfactor) < sx1
          ym = (y[0] + (event.y + info.scroll_y) / info.zoomfactor) < sy1
          loc_b = [xm, ym]        
          ;; reset to zoom mode
          info.selsubregion_id = 0
          ;; deactivate zoomfactor selector
          widget_control, info.w_zoomfac, sensitive = 1
          widget_control, info.w_selsubregion, set_value = 'Zoom Mode'
          info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
        ENDELSE      
        ;; Reinitialize the line starting coordinates.
        info.xs = -1
        info.ys = -1
        
      ENDIF ELSE BEGIN ;; handfree path
        straightline = 0
        PlotS, *info.xvalues, *info.yvalues, /Device, color = info.colorID
        
        ;; store points for drawing in original image
        IF info.selsubregion_id EQ 0 THEN BEGIN ;; non-zoomed
          xm = *info.xvalues & ym = *info.yvalues 
          xm = 0 > (xm * rsf) < sx1 & ym = 0 > (ym * rsf) < sy1
        ENDIF ELSE BEGIN ;; enlarged display       
          x = 0 > (info.x * rsf) < sx1 & y = 0 > (info.y * rsf) < sy1 
          xm = *info.xvalues & ym = *info.yvalues
          xm = (x[0] + (xm + info.scroll_x) / info.zoomfactor) < sx1
          ym = (y[0] + (ym + info.scroll_y) / info.zoomfactor) < sy1
          ;; reset to zoom mode
          info.selsubregion_id = 0
          ;; deactivate zoomfactor selector
          widget_control, info.w_zoomfac, sensitive = 1
          widget_control, info.w_selsubregion, set_value = 'Zoom Mode'
          info.set_zoom = 0 & info.scroll_x = 0 & info.scroll_y = 0
        ENDELSE
        ;; Reinitialize the pointers.
        Ptr_Free, info.xvalues
        Ptr_Free, info.yvalues
        info.xvalues = Ptr_New()
        info.yvalues = Ptr_New()
      ENDELSE
      
      info.buttonUsed = 'NONE'
      ;; put the color back to not interfere with the image color
      TVLCT, 0B, 0B, 0B, info.colorId
      IF info.is_cost EQ 3 THEN BEGIN
        restore, info.dir_tmp2 + 'currcolors.sav' & tvlct, r, g, b
      ENDIF

      ;; add the path into the full resolution image      
      ;; assign resistance image: FG-1, BG- BG-resist, missing=blocking! image0 = resistance map
      image0 = *info.fr_image & sz = size(image0)
      ;; missing pixels in original dimensions
      IF info.is_cost EQ 3 THEN BEGIN
        qm = where(image0 EQ 129b, ctqm, /l64) 
        resist = *info.extra ;; get background resistance 
      ENDIF ELSE BEGIN ;; add custom line (is_cost = 9)
        qm = where(image0 EQ 0b, ctqm, /l64)
      ENDELSE
      data_area = float(sz[4]) - ctqm
      
     
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;     straightline          ;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      IF straightline EQ 1 THEN BEGIN
        ;; build path from P0 to P1 in original image
         ;; insert shortest path loc_a -> loc_b into the map
         q1 = loc_b & q1 = float(q1 - round(loc_a))
         ps = (q1 GE 0) * 2 - 1 & q1 = q1 * ps  ;;sign of loc_b
         fi = q1[1] GT q1[0]
         x = lindgen(round(q1[fi] + 1)) & y = round((x * q1[1 - fi]) / q1[fi])
         x = round(loc_a[fi]) + x[0: * ] * ps[fi]
         y = round(loc_a[1 - fi]) + y[0: * ] * ps[1 - fi]
         IF fi EQ 1 THEN shpath = transpose([[y], [x]]) ELSE shpath = transpose([[x], [y]])
         np = n_elements(shpath[1,*])  
         
         lcp = image0 * 0b
         for id = 0, np-1 do lcp[shpath[0,id],shpath[1,id]] = 1b
         ;; get LCP path index
         lcp = where(lcp eq 1b, length, /l64) ;; full length of drawn path
                             
      ENDIF ELSE BEGIN
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;     freehand line          ;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;; build path for xm,ym in original image
        npdraw = n_elements(xm)
        lcp = image0 * 0b
        ;; we need to interpolate between successive points to catch all path points in the fullres image
        for id = 0, npdraw-2 do begin
          loc_a = [xm[id],ym[id]] & loc_b = [xm[id+1],ym[id+1]]
          tt = total(loc_a eq loc_b)
          if tt gt 1.999 then begin ;; loc_a and loc_b are identical
            goto, skiplcp5
          endif
          q1 = loc_b & q1 = float(q1 - round(loc_a))
          ps = (q1 GE 0) * 2 - 1 & q1 = q1 * ps  ;;sign of loc_b
          fi = q1[1] GT q1[0]
          x = lindgen(round(q1[fi] + 1)) & y = round((x * q1[1 - fi]) / q1[fi])
          x = round(loc_a[fi]) + x[0: * ] * ps[fi]
          y = round(loc_a[1 - fi]) + y[0: * ] * ps[1 - fi]
          IF fi EQ 1 THEN shpath = transpose([[y], [x]]) ELSE shpath = transpose([[x], [y]])          
          np = n_elements(shpath[1,*])
          for idx = 0, np-1 do lcp[shpath[0,idx],shpath[1,idx]] = 1b  
          skiplcp5:    
        endfor             
        ;; get LCP path index
        lcp = where(lcp eq 1b, length, /l64) ;; full length of drawn path        
      ENDELSE               
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;     drawline done         ;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      
      ;; stuff for add custom line to resistance map
      IF info.is_cost EQ 9 THEN BEGIN
        info.is_cost = 0 ;; stop drawing lines
        
        ;; ask for BG-resistance value for the new line
        cancel = ptr_new(1b)
        recline = info.recline
        if recline eq 1 then begin
          target = strtrim(indgen(256), 2)
          tit = 'Assign new value'
          seltarg = target[2]
          info.recline = 0 ;; reset line recoding
        endif else begin
          target = ['0 - Block', '2 - FG', strtrim(indgen(98)+3,2) + ' - BG']
          tit = 'Assign line-resistance'
          seltarg = target[1]
        endelse        
        seltarg = ptr_new(seltarg)
        lw = ['1', '3', '5', '7', '9', '11', '13', '15'] & selwidth = lw[0] & selwidth =  ptr_new(selwidth)
                              
        ;; get the selected mapping
        get_lineres, title = tit, target = target, seltarg = seltarg, $
          lw = lw, selwidth = selwidth, cancel = cancel, Group_Leader = event.top

        ;; check if cancel was selected then do nothing else apply the selected settings
        IF *cancel NE 0b THEN BEGIN ;; cancel was selected
          ptr_free, cancel & cancel = 0b
          ptr_free, seltarg & seltarg = 0b
          ptr_free, selwidth & selwidth = 0b
          showinf = 0 ;; do not display statistic info
          info.add_title = '' ;; reset title
          GOTO, cont_line  
        ENDIF ELSE BEGIN  
          ;; get new settings         
          ptr_free, cancel & cancel = 0b
          selresist = * seltarg & ptr_free, seltarg & seltarg = 0b
          width = * selwidth & ptr_free, selwidth & selwidth = 0b
          ;; assign the selected value
          if recline eq 0 then begin
            tt = strsplit(selresist,' - ',/extract) & tt = byte(tt[0]+0) ;; the resistance value in byte
          endif else begin
            tt = byte(selresist[0]+0) ;; the line recode value in byte
          endelse
                   
          ;; setup the new image        
          IF width EQ '1' THEN BEGIN
            image0[lcp] = tt
          ENDIF ELSE BEGIN
            ;; we need to make the line wider
            im = image0 * 0b & im[lcp] = 1b
            w = byte(width + 0) & sel = replicate(1b, w, w)
            im = dilate(im, sel) & qn = where(im gt 0b, /l64) 
            ;; assign to image0
            image0[qn] = tt 
          ENDELSE
          if recline eq 0 then info.add_title = ' (line-resistance)' else info.add_title = ' (recode line)'
          widget_control, info.tlb, tlb_set_title = info.title + info.add_title
          info.autostretch_id = 1
          showinf = 0 ;; do not display statistic info
          GOTO, cont_line          
        ENDELSE                    
      ENDIF         
      
      
      ;; set indicator from 3 to 4 to stop drawing lines
      info.is_cost = 4 & showinf = 1 ;; display statistic info
      lbl_comp= * info.nw_ids
      h_comp_area = * info.nw_hnw
      path = lbl_comp[lcp] & rp = where(path eq 0, restpix, /l64)
      expense = resist[lcp] & expense = long64(total(expense[rp]))
      ;; test for and add intermediate components
      h = histogram(path) & qintcomp = where(h GT 0)
      q = where(qintcomp gt 0, ct_qintcomp)
      if ct_qintcomp gt 0 then qintcomp = qintcomp[q]           


      ;; overplot intermediate components, beige
      IF ct_qintcomp GT 0 THEN BEGIN
        FOR i = 0, ct_qintcomp - 1 DO BEGIN
          q = where(lbl_comp EQ qintcomp(i), ct)
          if ct gt 0 then image0[q] = 58b
        ENDFOR
      ENDIF
      ;image0[q1b] = 105b & image0[q2b] = 176b ;; start (blue) / target (lightblue) component
      if ctqm gt 0 then image0[qm] = 129b ;; missing
      image0[lcp[rp]] = 33b  ;; overplot restore pixels in red in display image, even through missing!
      
      ;; derive new data_area which might be larger than the original one because of potential drawigna line through missing!
      qm = where(image0 EQ 129b, ctqm, /l64)
      data_area = float(sz[4]) - ctqm
      ;rac = ECA_maxnew / data_area * 100.0
      ;delta_rac = rac - RAC_orig

      ;; build average distance of restore pixels
      q = *info.morphdist & quality = mean(q[lcp[rp]]) & q = 0
 
      ;; new, safer way, calcualte new ECA from scratch
      fg = image0 GT 0b & IF ctqm GT 0 THEN fg[qm] = 0b      
      eew = 2  & eew2 = eew * 2
      ext = bytarr(sz[1] + eew2, sz[2] + eew2)
      ext[eew:eew + sz[1] - 1, eew:eew + sz[2] - 1] = temporary(fg)
      lbl_comp = label_region(ext, / all, / ulong) & ext = 0
      hca = histogram(lbl_comp, / l64) & lbl_comp = 0
      pcnum = total(hca(1: * )^2, / double)
      ECA = sqrt(pcnum) & ECA_maxnew = ECA_max + restpix & delta_eca = ECA - ECA_orig
      DOC = ECA/ECA_maxnew*100.0
      gain = doc - doc_orig
      effic = delta_eca / float(expense)    
      expense_t = 'EXP_' + c_size & statsfile = info.dir_tmp + 'custom_restoration_' + c_size + '.csv'
      close,1 & openw, 1, statsfile, error=error
      IF (error NE 0) then begin
        msg = 'Please close your spreadsheet application, then try again.' + $
          string(10b) + 'Returning...'
        res = dialog_message(msg, /information)
        close,1
        goto,fin
      ENDIF

      printf, 1, 'REST_PIX, AVDIST_RP,' + expense_t + ', EFFIC, ECA_ORIG, ECA_NEW, DELTA_ECA, COH_ORIG, COH_NEW, DELTA_COH'
      rowstr = strtrim(restpix, 2) + ',' + strtrim(quality,2) + ',' +  strtrim(expense,2) + ',' + strtrim(effic,2) + ',' + $
        strtrim(eca_orig,2) + ',' + strtrim(eca,2) + ',' + strtrim(delta_eca,2) + ',' + $  
        strtrim(doc_orig,2) + ',' + strtrim(doc,2) + ',' + strtrim(gain, 2)       
      printf, 1, rowstr & close, 1
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      
      ;; add to title
      q = strpos(inatit,';',/reverse_search)
      info.add_title = strmid(inatit,0,q+1) + ' DELTA_COH: ' + strtrim(gain,2) + '%; tick FGConn to reset)'
      widget_control, info.tlb, tlb_set_title = info.title + info.add_title
      info.autostretch_id = 0 
      
      cont_line:     
      ;; store stuff in the info structure
      ;; use MSPA-colors and set motion events to be active in the new viewport
      mev = 1
      * info.process = temporary(image0)
      * info.fr_image = * info.process
      ;; rescale large images for display if needed
      IF info.bigim THEN BEGIN
        s = size( * info.process,/dim)
        * info.process = congrid(temporary( * info.process), s[0] / info.resfac, s[1] / info.resfac)
      ENDIF

      
      ;; display the new image 
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      widget_control, info.w_autostretch, set_value = info.autostretch_id, / sensitive
      widget_control, info.w_disp_range, set_value = info.disp_range_id
      
      ;; update the pixmap image
      wset, info.pix_id
      guidos_image, * info.process, info.autostretch_id
      s = size( * info.process,/dim)

      ;; create a draw widget sized to the current image
      widget_control, info.w_drawbase, map = 0
      widget_control, info.w_draw, / destroy
      info.w_draw = widget_draw(info.w_drawbase, xsize = s[0], $
        ysize = s[1], retain = 2, motion_events = mev)

      widget_control, info.w_draw, / realize
      widget_control, info.w_draw, get_value = draw_ID & info.draw_ID = draw_ID
      widget_control, info.w_drawbase, map = 1
      widget_control, info.tlb, tlb_set_title = info.title + info.add_title
      widget_control, info.w_do_label_groups, set_value = info.do_label_groups_id

      wset, info.draw_id
      guidos_image, *info.process, info.autostretch_id
      
      ;; show brief info      
      IF showinf THEN BEGIN
        msg = 'Custom Path result: ' + string(10b) + string(10b) + $
          'Restore Pixels: ' + strtrim(restpix, 2) + string(10b) + $
          'DELTA_COH: ' + strtrim(gain,2) + string(10b) + $
          'EFFICIENCY:  ' + strtrim(effic,2) + string(10b) + $
          'AVDIST_RP:     ' + strtrim(quality,2)  + string(10b) + string(10b) + $
          'tick FGconn to reset'
        res = dialog_message(msg, title='Custom Path setup',/ information)
      ENDIF
      
  ENDIF ;; end of UP event
  
;;=======================================================================================
ENDIF ;; drawline events
;;=======================================================================================

fin:
;; Put the info structure back into its storage location.
Widget_Control, event.top, Set_UValue = info, / No_Copy

END ;; OF 'guidos_TLB_EVENTS'
;;=======================================================================
;;=======================================================================

;;========================================================================
;;========================================================================
PRO zimage_factor, event
;; the purpose of this event handler is to set the zoom factor.
widget_control, event.top, get_uvalue = info, / no_copy
widget_control, event.id, get_uvalue = factor
info.zoomfactor = factor(event.index)
widget_control, event.top, set_uvalue = info, / no_copy
END ;; of 'zimage_factor'
;;=======================================================================
;;=======================================================================


;;=======================================================================
;;=======================================================================
PRO guidos_cleanup, tlb
;; the purpose of this procedure is to clean up pointers,
;; objects, pixmaps, and other things in our program that
;; use memory. this procedure is called when the top-level
;; base widget is destroyed.

widget_control, tlb, get_uvalue = info, / no_copy
IF n_elements(info) NE 0 THEN BEGIN
   ;; free the pointers.
   ptr_free, info.image0        ;; working image in main gui
   ptr_free, info.contort
   ptr_free, info.cs22_conn
   ptr_free, info.cs22_nodes
   ptr_free, info.data_min
   ptr_free, info.data_max
   ptr_free, info.extra
   ptr_free, info.fr_image     ;; fullres image
   ptr_free, info.fr_undo      ;; undo option
   ptr_free, info.geotiffinfo
   ptr_free, info.morphdist
   ptr_free, info.nw_ids
   ptr_free, info.nw_conns
   ptr_free, info.nw_hnw
   ptr_free, info.nw_hnwb
   ptr_free, info.orig_image
   ptr_free, info.prezoomprocess;; pre zoomed processed image
   ptr_free, info.process      ;; processed image
   ptr_free, info.subimage     ;; the zoomed part   
   ptr_free, info.undo         ;; undo option
   ptr_free, info.undo_data_min
   ptr_free, info.undo_data_max
ENDIF

;; clean up tmp
pushd, info.dir_tmp
list = file_search() & nl = n_elements(list)
IF list[0] NE '' THEN FOR i = 0, nl - 1 DO file_delete, list[i], / allow_nonexistent, / quiet, / recursive
popd

;; clean up potential tmp sav-files
file_delete, info.dir_guidossub + 'contorttmp.sav', / allow_nonexistent, / quiet
file_delete, info.dir_guidossub + 'fragmtmp.sav', / allow_nonexistent,  / quiet

END  ;; of 'guidos_cleanup'
;;=======================================================================
;;=======================================================================

PRO guidos_quit, event
  widget_control, event.top, / destroy
END ;; of 'guidos_quit'
;;=======================================================================
;;=======================================================================



;;=======================================================================
;;=======================================================================
;;;;     E N D   O F   T L B  E V E N T   H A N D L E R
;;=======================================================================
;;=======================================================================



;;=======================================================================
;;=======================================================================
;;=======================================================================



;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################
;########################################################################

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; main program
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRO guidostoolbox, verify = verify, ColorId = colorId, Bottom=bottom, $
            Group_Leader = group, NColors = ncolors, $
            Cubic = interp_cubic, maindir = maindir, $
            dir_data = dir_data, result_dir_data = result_dir_data

gtb_version = 3.100
isBDAP = 0  ;; default = 0    NOTE: only set to 1 if I test on BDAP! (in directory $HOME/bdap)

IF (xregistered("guidostoolbox") NE 0) THEN BEGIN
   print, 'Please close your previous application before running a new one'
   return
ENDIF

;; Catch any error in the guidos program.
Catch, theError
IF theError NE 0 THEN BEGIN
   Catch, / Cancel
   ok = Error_Message(Traceback = 1)
   RETURN
ENDIF


VERSION = WIDGET_INFO( / VERSION)
my_os = !version.os & sysarch = !version.memory_bits
;; test on widget availability, current device name

IF !version.os_family EQ 'Windows' THEN my_os = 'windows' 
IF my_os EQ 'darwin' THEN my_os = 'apple'

IF my_os EQ 'linux' THEN BEGIN
  ;; test on availability of TrueColor mode for the local display
   spawn, 'unset LD_LIBRARY_PATH; xdpyinfo', res
   q = strpos(res, 'TrueColor') & q = where(q NE - 1, ct)
   IF ct GT 0 THEN device, true_color = 24
ENDIF
device, retain = 2
device, decomposed = 0
device, get_screen_size = screen_size

;; determine OS dependent path seperator
OS_sep = path_sep()
cd, current = dir_guidos
dir_guidos = dir_guidos + OS_sep

;; check for demo-mode
res = lmgr( / demo)
IF res EQ 1 THEN res = $
 dialog_message ('Note: IDL Demo Mode does not allow saving files,' + $
                 string(10b) + 'use the IDL VM instead.', title='GTB startup check:', / information)

colorid=0
interp = Keyword_Set(interp_cubic)
IF keyword_set(maindir) THEN dir_guidos = maindir + OS_sep ELSE dir_guidos = dir_guidos ;; the GUIDOS directory
dir_guidossub = dir_guidos + 'guidos_progs' + os_sep
dir_tmp = dir_guidossub + 'mspatmp' + os_sep
dir_tmp2 = dir_guidossub + 'tmp' + os_sep


READ_JPEG, dir_guidossub + 'guidos.jpg', welcome
IF (size(welcome))[0] EQ 3 THEN BEGIN
   s = size(welcome) & dim_pos = where(s EQ 3) & dim_pos = dim_pos(1)
   welcome = color_quan(welcome, dim_pos, r, g, b, / map_all)
   tvlct, r, g, b
ENDIF
prev_r = r & prev_g = g & prev_b = b
xsize = (size(welcome))[1] & ysize = (size(welcome))[2]

;; get the datatype
dtypes = ['undefined', 'byte', 'integer', 'long integer', 'float', 'double', $
         'complex', 'string', 'structure', 'double complex', 'pointer', $
         'obj ref.', 'unsigned integer', 'unsigned long integer', $
         '64-bit integer', 'unsigned 64-bit integer']
datatype = dtypes(size(welcome, / type))
CASE size(welcome, / n_dim) OF
   2:datalayers = 1
   3:datalayers = 3
   ELSE: datalayers = 0
ENDCASE

;; Make sure a window has been opened in this IDL session for
;; accurate color number determination.
Window, / Pixmap, XSize = 10, YSize = 10
WDelete, !D.Window
;; set pointer in viewport to use the Help icon
Window, 0, XSize = 1, YSize = 1
IF my_os NE 'windows' THEN DEVICE, CURSOR_STANDARD = 92 ELSE DEVICE, CURSOR_STANDARD = 32651
WDelete, !D.Window

;; check the proxy environment
;;------------------------------------------------------------------------------------------------------------------------------------------
proxhost = '' & proxport = ''
;; check if proxt check should be skipped
res = file_info('data' + os_sep + 'noproxycheck.txt') & res = res.exists 
IF res EQ 0b THEN BEGIN ;; if that file does not exist, go ahead with the proxy testing
  IF my_os NE 'windows' THEN BEGIN  ;;  check if the environment variable is set on 'linux' or 'apple'
    spawn, 'env|grep https_proxy', envproxy & envproxy = envproxy[0]
    IF strlen(envproxy) GT 0 THEN BEGIN
      p1 = strpos(envproxy, '=',/reverse_search) & p2 = strpos(envproxy,':',/reverse_search)
      ;; ensure we only set this when the proxy setting is retrieved properly
      IF p2 gt p1 THEN BEGIN
        proxhost = strmid(envproxy,p1+1,p2-p1-1)
        proxport = strmid(envproxy,p2+1)
        ;; remove trailing backslash if present
        proxport = strtrim(fix(proxport),2)
      ENDIF
    ENDIF
  ENDIF ELSE IF my_os EQ 'apple' THEN BEGIN  
    ;; find out proxy configuration if it is not specified as ENV or via proxy.pac
    ;; spawn, 'system_profiler SPNetworkDataType|grep proxy', envproxy 
    ;; system_profiler SPNetworkDataType | grep "HTTP Proxy Server" | awk '{print $4}' | head -1
    ;; system_profiler SPNetworkDataType | grep "HTTP Proxy Port" | awk '{print $4}' | head -1
    ;; or
    ;; networksetup -listallnetworkservices & networksetup -getautoproxyurl "USB 10/100/1000 LAN" or networksetup -getautoproxyurl "Wi-Fi"
       
    ;    $ export http_proxy=`scutil --proxy | awk '\
    ;    /HTTPEnable/ { enabled = $3; } \
    ;      /HTTPProxy/ { server = $3; } \
    ;      /HTTPPort/ { port = $3; } \
    ;    END { if (enabled == "1") { print "http://" server ":" port; } }'`
    ;    $ export HTTP_PROXY="${http_proxy}"
       
  ENDIF ELSE BEGIN ;; MS-Windows
    ;; 1)check if MANUAL proxy is enabled
    cmd = 'reg query "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings" | find /i "ProxyEnable"'
    spawn, cmd, res & res = STRSPLIT(res[0], /EXTRACT, ' ') & res = res[n_elements(res)-1] & proxy_enabled = strmid(res,2) eq '1'
    IF proxy_enabled THEN BEGIN ;; get the proxy settings
      cmd = 'reg query "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings" | find /i "ProxyServer"'
      spawn, cmd, res & res = STRSPLIT(res[0], /EXTRACT, ' ') & res = res[n_elements(res)-1] & p2 = strpos(res,':',/reverse_search)
      proxhost = strmid(res,0,p2)
      proxport = strmid(res,p2+1)
    ENDIF

    ;; 2) check system-wide proxy setup
    cmd = 'netsh winhttp show proxy'
    spawn, cmd, res & p = where(strpos(res,'(no proxy server)') GT -1)
    has_proxy = p[0] eq -1
    ;; find out its content
    IF has_proxy THEN BEGIN
      p = where(strpos(res,'Proxy Server') GT -1) & pp = res[p[0]]
      IF strlen(pp) GT 0 THEN BEGIN
        p1 = strpos(pp,':') & p2 = strpos(pp,':',/reverse_search)
        proxhost = strtrim(strmid(pp,p1+1,p2-p1-1),2)
        proxport = strtrim(strmid(pp,p2+1), 2)
      ENDIF
    ENDIF ELSE BEGIN
      proxhost = ''
      proxport = ''
    ENDELSE
  ENDELSE
ENDIF
;;---------------------------------------------------------------------------------------------------------------------------------
;; Linux: test user copy versus system default and update if needed
;; this is only applicable for non-standard setups like on BDAP
;; where the %posttrans script of the GTB-spec is not executed
;;============================================================
IF my_os EQ 'linux' THEN BEGIN
  cd, dir_guidos
  pushd, '../..'
  cd, current = basedir
  basedir = basedir + OS_sep
  popd
  res = (file_info('/opt/GTB/changelog.txt')).exists ;check if system install exists
  IF res EQ 1 THEN BEGIN ;; we have a system installation
    ;; extract and compare system GTB-version versus user GTB-version
    spawn, "cat /opt/GTB/changelog.txt |grep -m 1 Version| cut -d' ' -f2", sys_version & sys_version = float(sys_version[0])
    res = (gtb_version - sys_version) LT 0.0
    curruser = getenv('USER')
    ;; for all others but myself...
    IF curruser NE 'pinoc64' AND res EQ 1b THEN BEGIN 
      ;; sys_version is newer than user version:
      ;; inform user to run the upgrade script, which will copy over the current GTB sys_version from the system installation
      ;; we are in dir_guidos, set up a self-destructing script here to update the user's outdated version   
      pushd, basedir & close, 1
      openw, 1, 'update_myGTB.sh'
      printf, 1, "#!/bin/sh "
      printf, 1, "# update local GTB to system GTB version "
      printf, 1, " "
      printf, 1, "topdir=`dirname $0` "
      printf, 1, 'if (test $topdir = ".") ; then '
      printf, 1, "   topdir=$PWD; "
      printf, 1, "fi "
      printf, 1, "cd $topdir "            
      printf, 1, "cp -fr /opt/GTB/* . "
      printf, 1, "echo Please restart GTB"  
      printf, 1, "rm -f $topdir/update_myGTB.sh "      
      printf, 1, "exit  "
      close, 1
      file_chmod, 'update_myGTB.sh', /A_EXECUTE
      msg = 'Your local GTB copy is outdated.' + string(10b) + $
        'Please open a terminal in the directory: ' + basedir + string(10b) + $
        "and run the script 'update_myGTB.sh' to upgrade your local copy " + string(10b) + $
        'of GTB to the system-provided version of GTB' + string(10b) + string(10b) + 'Returning...'
      res = dialog_message(msg,title='GTB startup check:', / error)
      popd
      exit
    ENDIF
  ENDIF
ENDIF
;;---------------------------------------------------------------------------------------------------------------------------------

;;=======================================================
;; automatic test for newer version/bugfix and GWS release
;;=======================================================
newupdate = 0b & newGWS = 0b & inetworks = 0b

;; the local file listing the GTB version only
close, 1 & openw,1,dir_guidossub + 'GTBversion.txt' & printf,1,format='(f5.3)', gtb_version & close,1
;; the local file of current GTB-version + workshop 
version_file = dir_guidossub + 'version.txt'
;; delete the file if any was present
file_delete, version_file, / quiet

;; If the url object throws an error it will be caught here
CATCH, errorStatus
IF (errorStatus NE 0) THEN BEGIN
  CATCH, / CANCEL
  goto, url_cont0
ENDIF

oUrl = OBJ_NEW('IDLnetUrl')
oUrl -> SetProperty, URL_SCHEME = 'https'
oUrl -> SetProperty, PROXY_HOSTNAME = proxhost
oUrl -> SetProperty, PROXY_PORT = proxport
oUrl -> SetProperty, URL_HOST = 'ies-ows.jrc.ec.europa.eu'
oUrl -> SetProperty, URL_PATH = 'gtb/version.txt'
fn = oUrl -> Get(FILENAME = version_file)
url_cont0:
OBJ_DESTROY, oUrl

;; check if the file exists and what it contains
res = file_info(version_file) 
IF res.exists EQ 1b THEN BEGIN
  ;; check that it is small else there was an error to
  ;; retrieve the version info
  IF res.size LT 20 THEN BEGIN ;; all is ok!
    inetworks = 1b
    openr, 1, dir_guidossub + 'version.txt'
    newv='' & readf, 1, newv & close, 1
    newupdate = (float(strmid(strtrim(newv,2),0,5)) - gtb_version) GT 0.0001
    ;; GWS version
    GWSfile = dir_guidos+'data'+os_sep+'GWSversion.txt'
    res = file_info(GWSfile)
    If res.exists EQ 1b THEN BEGIN
      openr, 1, GWSfile
      oldGWS = '' & readf, 1, oldGWS & oldGWS = strtrim(oldGWS[0],2) & close, 1
      newGWS = ((strsplit(newv,'__',/extract))[1]) NE oldGWS
    ENDIF
  ENDIF
ENDIF
;;=======================================================
;; end of automatic check for program/bugfix updates
;;=======================================================

;;=======================================================================
;;=======================================================================
;;  define GUI
;;=======================================================================
;;=======================================================================
;; Create three bases:
;; 1) top horizontal:
;; Define the non-resizing TLB with a menu bar.
GTBv = strtrim(gtb_version,2)
GTBrev = strmid(GTBv,3,2) & GTBv = strmid(GTBv,0,3)
if strmid(GTBrev,0,1) eq '0' then GTBrev=strmid(GTBrev,1,1)
title = 'GuidosToolbox ' + gtbv + ', Revision ' + gtbrev + $
  ' (' + strtrim(sysarch,2) + ' bit)'
TLB = Widget_Base( TLB_Frame_Attr = 1, Title = title, $
 MBar = w_menubar, / row)

;; 2) left vertical: pre-processing options
w_ToolbarBase = WIDGET_BASE(TLB, / column, / TOOLBAR, $
 / base_align_center, / frame, Event_Pro = 'guidos_processing')

;; 3) right vertical: image window = draw widget
w_drawbasebox = widget_base(TLB,  / column, / frame)
w_drawbase = Widget_Base(w_drawbasebox)

;;=======================================================================
;; menubar definition
;;=======================================================================
;;-----------------------------------------------------------------------
;; FILE
;;-----------------------------------------------------------------------
;; read in
w_file = Widget_Button(w_menubar, Value = 'File', / menu)
w_file_read = Widget_Button(w_file, Value = 'Read Image', / menu)
button = widget_button(w_file_read, Value = 'GeoTIFF', $
         Event_Pro = 'guidos_io', uvalue = 'read_geotiff')
button = widget_button(w_file_read, Value = 'Generic', $
         Event_Pro = 'guidos_io', uvalue = 'read_generic')
button = widget_button(w_file_read, Value = 'IP Software', $
         Event_Pro = 'guidos_io', uvalue = 'read_ip_soft')
button = widget_button(w_file_read, Value = 'ENVI', $
         Event_Pro = 'guidos_io', uvalue = 'read_ENVI')

;; save results
w_file_save = Widget_Button(w_file, Value = 'Save Image', / menu, sensitive = 0)
w_sgeotiff = widget_button(w_file_save, Value = 'GeoTIFF', $
         Event_Pro = 'guidos_io', uvalue = 'save_geotiff')
w_sgeneric = Widget_Button(w_file_save, Value = 'Generic', / menu)
button = widget_button(w_sgeneric, Value = 'Tiff', $
         Event_Pro = 'guidos_io', uvalue = 'save_generic_tif')
button = widget_button(w_sgeneric, Value = 'PNG', $
         Event_Pro = 'guidos_io', uvalue = 'save_generic_png')
button = widget_button(w_file_save, Value = 'Display Snapshot', $
         Event_Pro = 'guidos_io', uvalue = 'save_display')
w_save_kml = widget_button(w_file_save, Value = 'KML', $
         Event_Pro = 'guidos_io', uvalue = 'save_kml')
        
;; Batch processing 
w_batch = Widget_Button(w_file, Value = 'Batch Process', / menu)

;; Objects
w_batchobj = Widget_Button(w_batch, Value = 'Objects', / Menu)
button = Widget_Button(w_batchobj, Value = 'Accounting', Event_Pro = 'guidos_processing', uvalue = 'batch_accounting')
button = Widget_Button(w_batchobj, Value = 'Parcellation', Event_Pro = 'guidos_processing', uvalue = 'batch_parcellation')

;; Pattern
w_batchpat = Widget_button(w_batch, Value = 'Pattern', / menu)
w_batchm = Widget_Button(w_batchpat, Value = 'Morphological', / Menu)
button = widget_button(w_batchm, Value = 'SPA2', Event_Pro = 'guidos_processing', uvalue = 'batch_spa2')
button = widget_button(w_batchm, Value = 'SPA3', Event_Pro = 'guidos_processing', uvalue = 'batch_spa3')
button = widget_button(w_batchm, Value = 'SPA5', Event_Pro = 'guidos_processing', uvalue = 'batch_spa5')
button = widget_button(w_batchm, Value = 'SPA6', Event_Pro = 'guidos_processing', uvalue = 'batch_spa6')
button = widget_button(w_batchm, Value = 'MSPA', Event_Pro = 'guidos_processing', uvalue = 'batch_mspa')
w_batchk = Widget_Button(w_batchpat, Value = 'Moving Window', / Menu)
button = Widget_Button(w_batchk, Value = 'LM', Event_Pro = 'guidos_processing', uvalue = 'batch_lm')
button = Widget_Button(w_batchk, Value = 'P2', Event_Pro = 'guidos_processing', uvalue = 'batch_p2')
button = Widget_Button(w_batchk, Value = 'P22', Event_Pro = 'guidos_processing', uvalue = 'batch_p22')
button = Widget_Button(w_batchk, Value = 'P23', Event_Pro = 'guidos_processing', uvalue = 'batch_p23')
button = Widget_Button(w_batchk, Value = 'Shannon', Event_Pro = 'guidos_processing', uvalue = 'batch_shannon')
button = Widget_Button(w_batchk, Value = 'SumD', Event_Pro = 'guidos_processing', uvalue = 'batch_sumd')

;; Network
w_batchnw = Widget_button(w_batch, Value = 'Network', / menu)
w_batchnw1 = Widget_button(w_batchnw, Value = 'MSPA-based', / menu)
button = Widget_button(w_batchnw1, Value = 'NW Components', Event_Pro = 'guidos_processing', uvalue = 'batch_nwcomp')
button = Widget_button(w_batchnw1, Value = 'Node/Link Importance', Event_Pro = 'guidos_processing', uvalue = 'batch_nlimp')
button = Widget_button(w_batchnw1, Value = 'MSPA ConeforInputs', Event_Pro = 'guidos_processing', uvalue = 'batch_mspaci')
button = Widget_button(w_batchnw, Value = 'ConeforInputs', Event_Pro = 'guidos_processing', uvalue = 'batch_ci')

;; Fragmentation
w_batchf = Widget_Button(w_batch, Value = 'Fragmentation', / Menu)
w_batchf1 = Widget_Button(w_batchf, Value = 'Index', / Menu)
button = Widget_button(w_batchf1, Value = 'Entropy', Event_Pro = 'guidos_processing', uvalue = 'batch_ent_img')
button = Widget_button(w_batchf1, Value = 'Hypsometry', Event_Pro = 'guidos_processing', uvalue = 'batch_hmc')
w_batchf2 = Widget_Button(w_batchf, Value = 'Map', / Menu)
button = Widget_button(w_batchf2, Value = 'Entropy', Event_Pro = 'guidos_processing', uvalue = 'batch_ent_spa')
button = Widget_button(w_batchf2, Value = 'Contagion', Event_Pro = 'guidos_processing', uvalue = 'batch_cont')
button = Widget_button(w_batchf2, Value = 'FOS', Event_Pro = 'guidos_processing', uvalue = 'batch_fos')
w_batchf3 = Widget_Button(w_batchf, Value = 'MultiScale', / Menu)
button = Widget_button(w_batchf3, Value = 'FAD', Event_Pro = 'guidos_processing', uvalue = 'batch_fad')
button = Widget_button(w_batchf3, Value = 'Dominance', Event_Pro = 'guidos_processing', uvalue = 'batch_lmms')

;; Distance
w_batchd = Widget_Button(w_batch, Value = 'Distance', / Menu)
button = Widget_button(w_batchd, Value = 'Euclidean Distance', Event_Pro = 'guidos_processing', uvalue = 'batch_eucldist')

;; Restoration Status
button = widget_button(w_batch, Value = 'Restoration Status', Event_Pro = 'guidos_processing', uvalue = 'batch_rss')

;; recode
button = widget_button(w_batch, Value = 'Recode Classes', Event_Pro = 'guidos_processing', uvalue = 'batch_recode')

;;; Change Analysis
w_change = Widget_Button(w_file, Value = 'Change', / Menu)
button = Widget_Button(w_change, Value = 'FOS', Event_Pro = 'guidos_processing', uvalue = 'change_fos')
button = Widget_Button(w_change, Value = 'FAD', Event_Pro = 'guidos_processing', uvalue = 'change_fad')
button = Widget_Button(w_change, Value = 'LM heatmap', Event_Pro = 'guidos_processing', uvalue = 'delta_lm')
button = Widget_Button(w_change, Value = 'Simple Change', Event_Pro = 'guidos_processing', uvalue = 'change_simple')
button = Widget_Button(w_change, Value = 'Morph. Change', Event_Pro = 'guidos_processing', uvalue = 'change_morph')

;; set/change the default data directory
button = Widget_Button(w_file, Value = 'Set Data Directory', / Separator, Event_Pro = 'guidos_processing', uvalue = 'set_dd')
;; compress tiff
button = Widget_Button(w_file, Value = 'Tif-Compression', Event_Pro = 'guidos_processing', uvalue = 'compress_tif')

;; Exit
w_quit = Widget_Button(w_file, Value = 'Exit', / Separator, Event_Pro = 'guidos_Quit')


;;-----------------------------------------------------------------------
;; TOOLS
;;-----------------------------------------------------------------------
w_tools = $
 Widget_Button(w_menubar, Value = 'General Tools', $
               Event_Pro = 'guidos_processing', / Menu, sensitive = 0)
;; Preprocessing
w_mspainp = Widget_Button(w_tools, Value = 'Preprocessing', / Menu)
w_conv = Widget_Button(w_mspainp, Value = 'Convert', /Menu)
w_c2b = Widget_Button(w_conv, Value = 'Convert -> Byte', uvalue = 'mspainp_c2b')
w_c2i = Widget_Button(w_conv, Value = 'Convert -> Integer', uvalue = 'mspainp_c2i')
w_c2l = Widget_Button(w_conv, Value = 'Convert -> Long', uvalue = 'mspainp_c2l')
w_c2s = Widget_Button(w_mspainp, Value = 'RGB -> Single Band', uvalue = 'mspainp_c2s')
w_c2ge = Widget_Button(w_mspainp, Value = 'Reproject for GoogleEarth', uvalue = 'mspainp_c2ge')
w_recode = Widget_Button(w_mspainp, Value = 'Recode Classes', uvalue = 'mspainp_recode')
button = Widget_Button(w_mspainp, Value = 'Recode Pixel', uvalue = 'mspainp_recodepixel')
button = Widget_Button(w_mspainp, Value = 'Recode Line', uvalue = 'mspainp_recodeline')
button = Widget_Button(w_mspainp, Value = 'Recode Region Of Interest', uvalue = 'mspainp_recoderoi')
button = Widget_Button(w_mspainp, Value = 'Threshold: FG/BG', uvalue = 'mspainp_thresh')
button = Widget_Button(w_mspainp, Value = 'Group: FG/BG/Missing', uvalue = 'mspainp_group')
button = Widget_Button(w_mspainp, Value = "X -> FG/BG/Missing", uvalue = 'mspainp_xset')
w_invert = Widget_Button(w_mspainp, Value = 'Invert', / Menu)
button = Widget_Button(w_invert, Value = 'FG/BG (2b <-> 1b)', uvalue = 'mspainp_invert21')
button = Widget_Button(w_invert, Value = 'FG/Missing (2b <-> 0b)', uvalue = 'mspainp_invert20')
button = Widget_Button(w_invert, Value = 'BG/Missing (1b <-> 0b)', uvalue = 'mspainp_invert10')
button = Widget_Button(w_mspainp, Value = 'Add 1b', uvalue = 'mspainp_add1')
button = Widget_Button(w_mspainp, Value = 'Subtract 1b', uvalue = 'mspainp_sub1')



;; convolution filters
w_smooth = Widget_Button(w_tools, Value = 'Convolution', / Menu, / Separator)
w_smooth_med = Widget_Button(w_smooth, Value = 'Median', / menu)
button = Widget_Button(w_smooth_med, Value = 'Box 3', uvalue = 'median3')
button = Widget_Button(w_smooth_med, Value = 'Box 5', uvalue = 'median5')
button = Widget_Button(w_smooth_med, Value = 'Box 7', uvalue = 'median7')
button = Widget_Button(w_smooth_med, Value = 'Box 9', uvalue = 'median9')
button = Widget_Button(w_smooth_med, Value = 'Box 15', uvalue = 'median15')

w_smooth_bx = Widget_Button(w_smooth, Value = 'Boxcar',  / menu)
button = Widget_Button(w_smooth_bx, Value = 'Box 3', uvalue = 'boxcar3')
button = Widget_Button(w_smooth_bx, Value = 'Box 5', uvalue = 'boxcar5')
button = Widget_Button(w_smooth_bx, Value = 'Box 7', uvalue = 'boxcar7')
button = Widget_Button(w_smooth_bx, Value = 'Box 9', uvalue = 'boxcar9')

w_smooth_lee = Widget_Button(w_smooth, Value = 'Lee',  / menu)
button = Widget_Button(w_smooth_lee, Value = 'Box 1', uvalue = 'lee1')
button = Widget_Button(w_smooth_lee, Value = 'Box 2', uvalue = 'lee2')
button = Widget_Button(w_smooth_lee, Value = 'Box 3', uvalue = 'lee3')

button = Widget_Button(w_smooth, Value = 'Sigma', uvalue = 'sigma')
button = Widget_Button(w_smooth, Value = 'Hilbert', uvalue = 'hilbert')
button = Widget_Button(w_smooth, Value = 'User-Defined', $
  uvalue = 'user_def')

;; others
w_equal = Widget_Button(w_tools, Value = 'Equalization', / menu)
button = Widget_Button(w_equal, Value = 'Contrast', uvalue = 'contrast')
button = Widget_Button(w_equal, Value = 'Histogram Equalization', $
         uvalue = 'histequal')
button = Widget_Button(w_equal, Value = 'Adaptive Histogram Equalization', $
         uvalue = 'adapthistequal')
button = Widget_Button(w_tools, Value = 'Thresholding', $
         uvalue = 'Thresholding')

;; edge enhance filters
w_edge = Widget_Button(w_tools, Value = 'Edge Enhance', / Menu, $
  / Separator)
w_edge_c = Widget_Button(w_edge, Value = 'Canny', / menu)
button = Widget_Button(w_edge_c, Value = 'Gradient', uvalue = 'canny_gr')
button = Widget_Button(w_edge_c, Value = 'Difference', $
  uvalue = 'canny_df')
button = Widget_Button(w_edge, Value = 'Laplace', uvalue = 'laplace')
button = Widget_Button(w_edge, Value = 'Roberts', uvalue = 'roberts')
button = Widget_Button(w_edge, Value = 'Sobel', uvalue = 'sobel')
button = Widget_button(w_edge, value = 'Sharpen', uvalue = 'sharpen')
w_usm = Widget_Button(w_edge, Value = 'Unsharp masking', / menu)
button = Widget_Button(w_usm, Value = 'Box 3', uvalue = 'unsharp_mask3')
button = Widget_Button(w_usm, Value = 'Box 5', uvalue = 'unsharp_mask5')
button = Widget_Button(w_usm, Value = 'Box 7', uvalue = 'unsharp_mask7')
button = Widget_Button(w_usm, Value = 'Box 9', uvalue = 'unsharp_mask9')
button = Widget_Button(w_edge, Value = 'Skeleton', uvalue = 'skeleton')

;; morphological filters
button = Widget_Button(w_tools, Value = 'Morphological', $
  uvalue = 'morph')

;; other GIS software
w_gissw = Widget_Button(w_tools, Value = 'GIS Software', / Menu, / Separator)
;; GDAL
button = Widget_Button(w_gissw, Value = 'GTB Terminal', uvalue = 'gdalterminal')

;; OpenEV only when in MS-Windows
IF my_os EQ 'windows' THEN BEGIN
   button = Widget_Button(w_gissw, Value = 'OpenEV Viewer', uvalue = 'openev')
ENDIF

;; QGIS / xdgop
qgis_exe = '' & xdgop = ''
IF my_os EQ 'apple' THEN BEGIN
   res = file_info('/Applications/QGIS*')
   if res.exists EQ 1 then qgis_exe = res.name + '/Contents/MacOS/QGIS'
ENDIF ELSE IF my_os EQ 'linux' THEN BEGIN
   spawn, 'unset LD_LIBRARY_PATH; which qgis 2>/dev/null', res & res = res(0)
   IF strmid(res, 0, 1) EQ '/' THEN qgis_exe = res   
   spawn, 'unset LD_LIBRARY_PATH; which xdg-open 2>/dev/null', res &  res = res(0)
   IF strmid(res, 0, 1) EQ '/' THEN xdgop = res   
ENDIF ELSE IF my_os EQ 'windows' THEN BEGIN 
   tt = file_search(getenv('PROGRAMFILES') + '\QGIS*\bin\qgis.bat')
   nr = n_elements(tt) & if nr gt 0 then qgis_exe = (tt)[nr-1]
ENDIF
if qgis_exe ne '' then button = Widget_Button(w_gissw, Value = 'QGIS', uvalue = 'qgis')

;; original and undo
;button = Widget_Button(w_tools, Value = 'Original Image', uvalue = 'Original Image', / Separator)
button = Widget_Button(w_tools, Value = 'Switch Cursor', uvalue = 'switchcursor')
w_undo = Widget_Button(w_tools, Value = 'Undo', UValue = 'Redo', Event_Pro = 'guidos_Undo', Sensitive = 0)


;;-----------------------------------------------------------------------
;; Image Analysis
;;-----------------------------------------------------------------------
w_pa = $
 Widget_Button(w_menubar, Value = 'Image Analysis', / Menu, $
               Event_Pro = 'guidos_processing', sensitive = 0)

w_pa_objects = Widget_Button(w_pa, Value = 'Objects', / Menu)
button = Widget_Button(w_pa_objects, Value = 'Accounting', uvalue = 'accounting')
button = Widget_Button(w_pa_objects, Value = 'Parcellation', uvalue = 'frag_parcellation')
button = Widget_Button(w_pa_objects, Value = 'Contortion', uvalue = 'contortion1')


w_pa_pattern = Widget_Button(w_pa, Value = 'Pattern', / Menu)
w_pa_m = Widget_Button(w_pa_pattern, Value = 'Morphological', /menu)
button = Widget_Button(w_pa_m, Value = 'SPA2 (SLF)', uvalue = 'spa2')
button = Widget_Button(w_pa_m, Value = 'SPA3', uvalue = 'spa3')
button = Widget_Button(w_pa_m, Value = 'SPA5', uvalue = 'spa5')
button = Widget_Button(w_pa_m, Value = 'SPA6', uvalue = 'spa6')
w_pa_morph = Widget_Button(w_pa_m, Value = 'MSPA', uvalue = 'mspa')
button = widget_button(w_pa_m, Value = 'MSPA Tiling', uvalue = 'mspatile')
w_pa_kernel = Widget_Button(w_pa_pattern, Value = 'Moving Window', / Menu)
button = Widget_Button(w_pa_kernel, Value = 'LM', uvalue = 'kernel_lm')
button = Widget_Button(w_pa_kernel, Value = 'P2',  uvalue = 'kernel_p2')
button = Widget_Button(w_pa_kernel, Value = 'P22', uvalue = 'kernel_p22')
button = Widget_Button(w_pa_kernel, Value = 'P23', uvalue = 'kernel_p23')
button = Widget_Button(w_pa_kernel, Value = 'Shannon', uvalue = 'kernel_shannon')
button = Widget_Button(w_pa_kernel, Value = 'SumD', uvalue = 'kernel_sumd')


w_pa_connectivity = Widget_Button(w_pa, Value = 'Network(MSPA)', / Menu)
w_pa_connectivity1 = Widget_Button(w_pa_connectivity, Value = 'NW Components', uvalue = 'nw_components')
w_pa_connectivity2 = Widget_Button(w_pa_connectivity, Value = 'NW Node/Link Importance',  uvalue = 'nw_importance')
w_pa_connectivity20 = Widget_Button(w_pa_connectivity, Value = 'NW Component Connectors', uvalue = 'nw_nwconnect')
w_pa_connectivity3 = Widget_Button(w_pa_connectivity, Value = 'MSPA ConeforInputs', uvalue = 'nw_cs22')


w_pa_frag = Widget_Button(w_pa, Value = 'Fragmentation', / Menu)
w_pa_frag1 = Widget_Button(w_pa_frag, Value = 'Index', /menu)
button = Widget_Button(w_pa_frag1, Value = 'Entropy', uvalue = 'frag_entropy_im')
button = Widget_Button(w_pa_frag1, Value = 'Hypsometry', uvalue = 'frag_hmc')
w_pa_frag2 = Widget_Button(w_pa_frag, Value = 'Map', /menu)
button = Widget_Button(w_pa_frag2, Value = 'Entropy', uvalue = 'frag_entropy_tl')
button = Widget_Button(w_pa_frag2, Value = 'Contagion',uvalue = 'frag_contagion')
button = Widget_Button(w_pa_frag2, Value = 'FOS', uvalue = 'frag_fos')
w_pa_frag3 = Widget_Button(w_pa_frag, Value = 'MultiScale', /menu)
button = Widget_Button(w_pa_frag3, Value = 'FAD',uvalue = 'frag_fad')
button = Widget_Button(w_pa_frag3, Value = 'Dominance',uvalue = 'lmms')


w_pa_distance = Widget_Button(w_pa, Value = 'Distance', / Menu)
button = Widget_Button(w_pa_distance, Value = 'Euclidean Distance', uvalue = 'distance_morph')
button = Widget_Button(w_pa_distance, Value = 'Influence Zones', uvalue = 'distance_influence')
button = Widget_Button(w_pa_distance, Value = 'Proximity', uvalue = 'distance_proximity')


w_pa_cost = Widget_Button(w_pa, Value = 'Restoration Planner', / Menu)
w_pa_costpre = Widget_Button(w_pa_cost, Value = 'Setup Tools', / menu)
button = Widget_Button(w_pa_costpre, Value = 'Fixed BG-Resistance', uvalue = 'cost_fixed')
button = Widget_Button(w_pa_costpre, Value = 'Land Cover -> Resistance', uvalue = 'cost_recode')
button = Widget_Button(w_pa_costpre, Value = 'Distance -> Resistance', uvalue = 'cost_disres')
button = Widget_Button(w_pa_costpre, Value = 'Pixel -> Resistance', uvalue = 'cost_pixel')
button = Widget_Button(w_pa_costpre, Value = 'Line -> Resistance', uvalue = 'cost_line')
button = Widget_Button(w_pa_costpre, Value = 'Region Of Interest -> Resistance', uvalue = 'cost_roi')
button = Widget_Button(w_pa_costpre, Value = 'Isochrone Map Marker Image', uvalue = 'mspainp_costmarker', /Separator)
w_at = Widget_Button(w_pa_cost, Value = 'Assessment', / menu)
button = Widget_Button(w_at, Value = 'Status Summary', uvalue = 'cost_status')
button = Widget_Button(w_at, Value = 'Change Summary', uvalue = 'change_rss')
button = Widget_Button(w_at, Value = 'Add Custom Path', uvalue = 'cost_draw', / Separator)
button = Widget_Button(w_at, Value = 'Find Optimum Path', uvalue = 'cost_reconnect')
button = Widget_Button(w_at, Value = 'Show Optimum Big 5', uvalue = 'cost_restoration')
button = Widget_Button(w_at, Value = 'Isochrone Map A', uvalue = 'cost_map_aa', / Separator)
button = Widget_Button(w_at, Value = 'Isochrone Map AB', uvalue = 'cost_map_ab')

;;-----------------------------------------------------------------------
;; HELP
;;-----------------------------------------------------------------------
w_help = widget_button(w_menubar, value = 'Help', / help, / menu, $
               Event_Pro = 'guidos_processing')
w_help_docu = widget_button(w_help, value = 'GTB Documentation', /menu)
button = widget_button(w_help_docu, value = 'GTB Manual', uvalue = 'guidos_manual')
button = widget_button(w_help_docu, value = 'MSPA Guide', uvalue = 'mspa_guide')
button = widget_button(w_help_docu, value = 'Changelog', uvalue = 'gt_changelog')
button = widget_button(w_help_docu, value = 'EULA', uvalue = 'gt_eula')

w_help_online = widget_button(w_help, value = 'GTB Online', /menu)
button = widget_button(w_help_online, value = 'GTB News', uvalue = 'news')
button = widget_button(w_help_online, value = 'GTB Homepage', uvalue = 'homepage_gtb')
button = widget_button(w_help_online, value = 'Check for Updates', uvalue = 'check4updates')
button = widget_button(w_help_online, value = 'GTB Product Sheets', uvalue = 'productsheets')
button = widget_button(w_help_online, value = 'GWS (GTB Workshop)', uvalue = 'installgws')
button = widget_button(w_help_online, value = 'GWB (GTB Workbench)', uvalue = 'homepage_gwb')

w_help_online2 = widget_button(w_help, value = 'Related Resources', /menu)
button = widget_button(w_help_online2, value = 'GIS Introduction', uvalue = 'homepage_gis')
button = widget_button(w_help_online2, value = 'GDAL', uvalue = 'homepage_gda')
button = widget_button(w_help_online2, value = 'CCRS Tutorial', uvalue = 'homepage_crs')
button = widget_button(w_help_online2, value = 'OpenForis', uvalue = 'homepage_opf')
button = widget_button(w_help_online2, value = 'SEPAL', uvalue = 'homepage_spl')
button = widget_button(w_help_online2, value = 'TreeAtlas', uvalue = 'homepage_atl')
button = Widget_Button(w_help_online2, Value = 'IMPACT Toolbox', uvalue = 'homepage_itb')
button = Widget_Button(w_help_online2, Value = 'Conefor', uvalue = 'homepage_cfr')

button = widget_button(w_help, value = 'Bug Report', uvalue = 'about_system')
button = widget_button(w_help, value = 'About GTB', uvalue = 'about')

;;=======================================================================
;; end of menubar definition
;;=======================================================================


;;=======================================================================
;; left panel definition
;;=======================================================================
w_lp1 = widget_base(w_Toolbarbase, / column)


;;============================
;; FIRST LEFT PANEL WIDGET
;;============================

;; display values
w_lp11 = widget_base(w_lp1, / column, / frame, / align_center, sensitive = 0)
button = $
  widget_label(w_lp11, value = '       IMAGE/DISPLAY ATTRIBUTES       ', $
  / sunken_frame, / align_center)

w_lp111 = widget_base(w_lp11, / row, / align_center)
w_lp1111 = widget_base(w_lp111, / column);, / frame)
w_lp11111 = widget_base(w_lp1111, / column, / frame)
w_disp_range = CW_BGROUP(w_lp11111, 'Normalized', / nonexclusive, uvalue = 'disp_range')
w_autostretch = CW_BGROUP(w_lp11111, 'Autostretch', / NONEXCLUSIVE, uvalue = 'autostretch')
w_iminfo = widget_button(w_lp11111, Value = 'Original Image', uvalue = 'Original Image')
w_iminfo2 = widget_button(w_lp11111, Value = 'Image Info', uvalue = 'mspainp_info')


;; colortable
w_lp1112 = widget_base(w_lp111, / column);, / frame)
w_ctbl = widget_base(w_lp1112, / column, / frame)
button = $
  widget_label(w_ctbl, value = 'Select Colortable', / align_center)
tls = ['Greyscale', 'Rainbow', 'Temperature', 'Classification', $
  'Distance', 'Normalized', 'Contortion', 'LM', 'FOS_6', 'FOS_5', 'FOS-APP_2', 'Resistance', 'User-defined', 'Save/Restore']
w_disp_colors  = Widget_Combobox(w_ctbl, Value = tls, UVALUE = 'disp_colors')

;; zoom factor and factor
w = widget_label(w_lp1112, value =' ') ;; some space
w_zoomfac = widget_base(w_lp1112, / column, / frame)
w_selsubregion = $
 widget_button(w_zoomfac,  Value = 'Zoom Mode', uvalue = 'selsubregion', $
               Event_Pro = 'guidos_processing')

factorString = ['1x', '2x', '4x', '6x', '8x', '10x']
factors = [1, 2, 4, 6, 8, 10]
w_zoomfac1 = widget_base(w_zoomfac, / row)
w_zoomfac_tit = $
 widget_label(w_zoomfac1, value = 'Factor: ')
zoomfactor = $
 Widget_combobox(w_zoomfac1, Value = factorString, UValue = factors, $
                  Event_Pro = 'ZIMAGE_FACTOR', scr_xsize = 60)

;w_undo = Widget_Button(w_lp1112, Value = 'Undo', UValue = 'Redo', /frame, $
;  Event_Pro = 'guidos_Undo', Sensitive = 0)

;;============================
;; SECOND LEFT PANEL WIDGET
;;============================
;; MSPA sections
w_lp12 = widget_base(w_lp1, / column, / frame, sensitive = 0)
button = widget_label(w_lp12, value = '       MSPA SETTINGS       ',$
   / sunken_frame, / align_center)
w_lp121 = widget_base(w_lp12, / row, / frame, / align_center)

;; MSPA-parameter 1
w_lp1211 = widget_base(w_lp121, / column, / frame)
button = widget_label(w_lp1211, value = 'FGConn')
button = widget_label(w_lp1211, value = '[8/4]')
w_mspa_param1 =  CW_BGROUP(w_lp1211, ' ', / NONEXCLUSIVE, $
                           uvalue = 'mspa_param1')
;button = widget_label(w_lp121, value = ' ') ;; some space

;; MSPA-parameter 2
w_lp1212 = widget_base(w_lp121, / column, / frame)
button = widget_label(w_lp1212, value = 'EdgeWidth')
button = widget_label(w_lp1212, value = '[pixels]')
val = ['x', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10']
w_mspa_param2 = $
 Widget_Combobox(w_lp1212, Value = val, scr_xsize = 50, $
                 UVALUE = 'mspa_param2', / editable);, / dynamic_resize)
;button = widget_label(w_lp121, value = ' ') ;; some space

;; MSPA-parameter 3
w_lp1213 = widget_base(w_lp121, / column, / frame)
button = widget_label(w_lp1213, value = 'Transition')
button = widget_label(w_lp1213, value = '[On/Off]')
w_mspa_param3 =  CW_BGROUP(w_lp1213, ' ', / NONEXCLUSIVE, $
                           uvalue = 'mspa_param3')


;; MSPA-parameter 4
w_lp1214 = widget_base(w_lp121, / column, / frame)
button = widget_label(w_lp1214, value = 'Intext')
button = widget_label(w_lp1214, value = '[On/Off]')
w_mspa_param4 =  CW_BGROUP(w_lp1214, ' ', / NONEXCLUSIVE, $
                           uvalue = 'mspa_param4')



;; statistic section
w_lp1222 = widget_base(w_lp12, / column)
w_do_mspa_stats = CW_BGROUP(w_lp1222, 'MSPA STATISTICS', $
                            / NONEXCLUSIVE, uvalue = 'do_mspa_stats')
;; the table
row_lab = $
 ['CORE(s)', 'CORE(m)', 'CORE(l)','ISLET', 'PERFOR', 'EDGE', 'LOOP', 'BRIDGE', 'BRANCH', $
  'Background', 'Missing', 'Opening', 'CoreOpen', 'BorderOpen']
w_mspa_stats = $
 widget_table(w_lp1222, row_labels = row_lab, column_widths = 70, $ ; ysize=11,y_scroll_size = 11, scr_xsize = 230, x_scroll_size = 4,$
              scr_xsize = 230, xsize = 2, y_scroll_size = 14, / resizeable_columns,$
              column_labels = ['FG/data[%]', '#/BGarea'], $
              value = transpose(replicate('n/a', n_elements(row_lab), 2)))

;;=======================================================================
;; end of left panel definition
;;=======================================================================



;;=======================================================================
;; drawbase definition
;;=======================================================================
;; x/ysize are the size of the virtual drawable area, x/y_scroll_size
;; the size of the viewport
xss = screen_size(0) * 0.75 & yss = screen_size(1) * 0.85
w_draw = $
 Widget_Draw(w_drawbasebox, XSize = xsize, YSize = ysize, retain = 2)

msg = 'Please load an image via the menu: File -> Read Image'
w_rdpx = Widget_text(w_drawbasebox, xsize = 70, $
                     value = msg, / frame) ; ysize = 20
                     
w_label = widget_base(w_drawbasebox, / row, Event_Pro = 'guidos_processing', sensitive = 0)
w_do_label_groups = CW_BGROUP(w_label, 'Divide',/ NONEXCLUSIVE, uvalue = 'do_label_groups')
w_labelstr = widget_label(w_label, value = 'MSPA-Core pixels: ', /align_left)
w_labelstr1 = widget_label(w_label, value = 'small < ')
label_t1str = ['X', '1000', '4500', '10000']
w_label_t1 = Widget_Combobox(w_label, Value = label_t1str, UVALUE = 'label_t1v', scr_xsize = 75, / editable)
w_labelstr2 = widget_label(w_label, value = ' medium ')
label_t2str = ['X', '4600', '11000', '25000']
w_label_t2 = Widget_combobox(w_label, Value = label_t2str, UValue = 'label_t2v', scr_xsize = 75, / editable)
w_labelstr3 = widget_label(w_label, value = ' > large')
                    
;;=======================================================================
;; end of drawbase definition
;;=======================================================================
;; do final checks before we realize the widget hierachy 
;;=======================================
;; test for pdf, browser, gdal etc.
;;=======================================
;; initialize 
acroread_exe = '' & html_exe = '' & sysgdal='' & fmanager = '' & linterm='' & ftmp = dir_tmp + 'tmp.txt'
dir_fwtools = 'unset LD_LIBRARY_PATH; ' & windrive = '' & immaxsizeg = -1

CASE my_os OF
  'windows': BEGIN
    ;;================================================================================================
    ;; maximum image size for MSPA 
    immaxsize = 100.0
    fn = dir_guidossub + 'mspa.exe'
    ;; find out how much available RAM (MB) we have
    ;;spawn,'typeperf "\Memory\Available mbytes" -sc 1', res & res = res [2]
    ;;a=strsplit(res,'"',/extract) & a=fix(a[2])
    ;;immaxsize = a/20.0
    file_copy, dir_guidos + 'MSPAstandalone\mspa_win64.exe', fn, / overwrite

    ;; fwtools/gdal
    dir_fwtools = dir_guidossub + 'GTBtools\'
    windrive = strmid(dir_fwtools,0,2)

    ;; check to have at least Win 8.1
    spawn, 'ver', res & res = STRSPLIT(res[1], /EXTRACT, ' ') & res = res[n_elements(res)-1]
    q = strpos(res,'.') & res = float(strmid(res,0,q+2))
    IF res LT 6.3 THEN BEGIN
      res = dialog_message('GuidosToolbox requires Windows 8.1 or newer' + string(10b) + 'Terminating...', title='GTB startup check:',/ error)
      Exit
    ENDIF
    ;; lt 10.0 to deprecate Win 8 supported until January 2023; end of Win 10 in October 2025
    ;; https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions

    ;; compare GTB version in use versus OS-version
    res = file_info(dir_guidossub + 'spatcon\spatcon64.exe') & res = res.exists
    IF res THEN GTBarch = '64bit' ELSE GTBarch = '32bit'
    IF !version.arch EQ 'x86_64' THEN res4 = '64bit' ELSE res4 = '32bit'
    IF GTBarch NE res4 THEN BEGIN
      res = dialog_message('Please use the matching GuidosToolbox architecture: ' + string(10b) + $
        'GuidosToolbox architecture in use: ' + GTBarch  + string(10b) + $
        'Operating system architecture: ' + res4 + string(10b) + $
        'Terminating...',title='GTB startup check:', / error)
      exit
    ENDIF

    res = file_info('data\nolimits.txt') & res = res.exists
    IF res EQ 1b THEN immaxsizeg = 1.0e12
    EULA = dir_guidos + 'EULA_GTB.pdf'
  END

  'linux': BEGIN
    ;;================================================================================================
    ;; check for system-gdal
    spawn, 'unset LD_LIBRARY_PATH; which gdalinfo 2>/dev/null', res &  res = res(0)
    IF strmid(res, 0, 1) EQ '/' THEN BEGIN
      sysgdal=res
    ENDIF ELSE BEGIN
      msg='Could not find GDAL. Please install gdal/gdalinfo via your package manager.' + $
        string(10b) + 'Exiting...'
      res = dialog_message(msg, title='GTB startup check:',/ error)
      exit
    ENDELSE

    ;; check for file manager, first by xdg, if that does not work then use a list of apps
    ;;==============================================================================
    spawn, 'unset LD_LIBRARY_PATH; which xdg-mime 2>/dev/null', res & res = res(0)
    IF strmid(res, 0, 1) EQ '/' THEN BEGIN ;; xdg-mime found
      spawn, 'unset LD_LIBRARY_PATH; xdg-mime query default inode/directory', res & res = res(0)
      if strlen(res) gt 0 then begin ;; association found, take off the .desktop
        res=(strsplit(res, '.',/extract))[0]
        ;; test if it actually works
        spawn, 'unset LD_LIBRARY_PATH; which '+ res + ' 2>/dev/null', res2 & res2 = res2[0]
        IF strmid(res2, 0, 1) EQ '/' THEN BEGIN ;; application found
          fmanager = res2
          GOTO, html_check1
        ENDIF
      endif
    ENDIF
    fm_view = ['dolphin', 'konqueror', 'mate-file-manager', 'caja', 'nemo', 'pcmanfm', 'nautilus', 'thunar']
    nx = n_elements(fm_view) &  id = 0
    fm_again1:
    spawn, 'unset LD_LIBRARY_PATH; which ' + fm_view(id) + ' 2>/dev/null', res &  res = res(0)
    IF strmid(res, 0, 1) EQ '/' THEN BEGIN ;; application found
      fmanager = res & GOTO, html_check1
    ENDIF ELSE BEGIN ;; application not found
      id = id + 1  ;; check the next application
      IF id LT nx THEN GOTO, fm_again1 ELSE GOTO, html_check1
    ENDELSE

    html_check1:
    if fmanager eq '' then begin
      msg='No file manager found. Please install any of: ' + string(10b) + $
        'dolhin, konqueror, thunar, mate-file-manager, caja,' + string(10b) + $
        'nemo, pcmanfm, nautilus' + string(10b) + $
        'or let me know which different file manager you use!' + string(10b) + 'Exiting...'
      res = dialog_message(msg, title='GTB startup check:',/ error)
      exit
    endif


    ;; check for browser, first use a list of apps, if that does not work use xdgs
    ;;================================================================================
    html_view = ['firefox', 'konqueror', 'google-chrome', 'chrome', 'chromium', 'netscape', 'iceweasel', $
      'opera', 'mozilla', 'flock', 'galeon', 'dillo', 'epiphany', 'seamonkey']
    nx = n_elements(html_view) &  id = 0
    html_again1:
    spawn, 'unset LD_LIBRARY_PATH; which ' + html_view(id) + ' 2>/dev/null', res &  res = res(0)
    IF strmid(res, 0, 1) EQ '/' THEN BEGIN ;; application found
      html_exe = res & GOTO, pdf_check1
    ENDIF ELSE BEGIN ;; application not found
      id = id + 1  ;; check the next application
      IF id LT nx THEN GOTO, html_again1
    ENDELSE
    
    ;; still nothing found, try xdg       
    spawn, 'unset LD_LIBRARY_PATH; which xdg-mime 2>/dev/null', res & res = res(0)
    IF strmid(res, 0, 1) EQ '/' THEN BEGIN ;; xdg-mime found
      spawn, 'unset LD_LIBRARY_PATH; xdg-mime query default text/html', res & res = res(0)
      if strlen(res) gt 0 then begin ;; association found, take off the .desktop
        res=(strsplit(res, '.',/extract))[0]
        ;; test if it actually works
        spawn, 'unset LD_LIBRARY_PATH; which '+ res + ' 2>/dev/null', res2 & res2 = res2[0]
        IF strmid(res2, 0, 1) EQ '/' THEN BEGIN ;; application found
          html_exe = res2
          GOTO, pdf_check1
        ENDIF
      endif
    ENDIF

    ;; check for pdf
    ;;=======================================================================
    pdf_check1:
    if html_exe eq '' then begin
      msg='No web browser found. Please install any of: ' + string(10b) + $
        'firefox, konqueror, google-chrome, netscape, iceweasel, opera'  + string(10b) + $
        'mozilla, flock, galeon, dillo, epiphany, seamonkey' + string(10b) + $
        'or let me know which different web browser you use!' + string(10b) + 'Exiting...'
      res = dialog_message(msg, title='GTB startup check:',/ information)
      exit
    endif
    ;; test for pdf-viewer applications, first by xdg, if that does not work then use a list of apps
    spawn, 'unset LD_LIBRARY_PATH; which xdg-mime 2>/dev/null', res & res = res[0]
    IF strmid(res, 0, 1) EQ '/' THEN BEGIN ;; xdg-mime found
      spawn, 'unset LD_LIBRARY_PATH; xdg-mime query default application/pdf', res & res = res[0]
      if strlen(res) gt 0 then begin ;; association found, take off the .desktop
        res=(strsplit(res, '.',/extract))[0]
        ;; test if it actually works
        spawn, 'unset LD_LIBRARY_PATH; which '+ res + ' 2>/dev/null', res2 & res2 = res2[0]
        IF strmid(res2, 0, 1) EQ '/' THEN BEGIN ;; application found
          acroread_exe = res2
          GOTO, term_check
        ENDIF
      endif
    ENDIF
    pdf_view = ['acroread', 'okular', 'kghostview', 'kpdf', 'xpdf', $
      'FoxitReader', 'mupdf', 'epdfview', 'gpdf', 'gv', 'ggv', 'atril', 'calibre', 'FBReader', 'evince']
    nx = n_elements(pdf_view) &  id = 0
    pdf_again1:
    spawn, 'unset LD_LIBRARY_PATH; which ' + pdf_view[id] + ' 2>/dev/null', res & res = res[0]
    IF strmid(res, 0, 1) EQ '/' THEN BEGIN ;; application found
      acroread_exe = res & GOTO, term_check
    ENDIF ELSE BEGIN ;; application not found
      id = id + 1  ;; test the next application
      IF id LT nx THEN GOTO, pdf_again1 ELSE GOTO, term_check
    ENDELSE

    term_check:
    if acroread_exe eq '' then begin
      msg='No pdf-reader found. Please install any of: ' + string(10b) + $
        'acroread, okular, kghostview, kpdf, xpdf, mupdf' + string(10b) + $
        'FoxitReader, epdfview, gpdf, gv, ggv, atril, calibre, FBReader, evince' + string(10b) + $
        'or let me know which different pdf-reader you use!' + string(10b) + 'Exiting...'
      res = dialog_message(msg, title='GTB startup check:',/ information)
      exit
    endif

    ;; check for terminal
    ;;=======================================================================
    ;; test which terminal is available in this sequence to put the best at the end
    ;; xterm, gnome, konsole rxvt dtterm eterm Eterm kvt
    termtest=['konsole', 'mate-terminal', 'gnome-terminal', 'aterm', 'eterm', 'Eterm', 'lxterm', 'roxterm', 'rxvt', 'xterm']
    for idx=0, n_elements(termtest)-1 do begin
      spawn, 'unset LD_LIBRARY_PATH; which '+termtest(idx)+' 2>/dev/null', res & res = res(0)
      IF strmid(res, 0, 1) EQ '/' THEN BEGIN
        linterm=res & goto, cont_lin
      ENDIF
    endfor
    if linterm eq '' then begin
      msg='No terminal found. Please install any of: ' + string(10b) + $
        'konsole, mate-terminal, gnome-terminal, aterm,' + string(10b) + $
        'eterm, lxterm, roxterm, rxvt, xterm' + string(10b) + $
        'or let me know which different terminal you use!' + string(10b) + 'Exiting...'
      res = dialog_message(msg, title='GTB startup check:',/ information)
      exit
    endif

    cont_lin:
    ;; maximum image size for MSPA
    immaxsize = 101.0
    fn = dir_guidossub + 'mspa_lin'
    ;; find out how much available RAM (MB) we have: free+buffers+cache
    spawn,"free|awk 'FNR == 2 {print $7}'", mbavail & mbavail = float(mbavail[0])/1024 ;; available
    spawn,"free|awk 'FNR == 3 {print $4}'", mbavail2 & mbavail2 = float(mbavail2[0])/1024 ;; swap
    mbavail = mbavail + mbavail2
    immaxsize = uint(mbavail/19)
    file_copy, dir_guidos + 'MSPAstandalone/mspa_lin64', fn, / overwrite

    ;; find out if nolimits is set
    res = file_info('../../data/nolimits.txt') & res = res.exists
    IF res EQ 1b THEN immaxsizeg = 1.0e12
    EULA = dir_guidos + '../../EULA_GTB.pdf'
    ;; BDAP testing
    IF isBDAP then EULA = dir_guidos + 'EULA_GTB.pdf'
  END

  'apple':BEGIN
    ;;================================================================================================
    ;; test for Yosemite or later
    spawn, 'sw_vers -productVersion', res & res=res[0] 
    os1 = fix((strsplit(res,'.',/extract))[0]) & os2 = fix((strsplit(res,'.',/extract))[1])   
    IF (os1 EQ 10) AND (os2 LT 10) THEN BEGIN
      res = dialog_message('GuidosToolbox requires Yosemite (OSX 10.10) or newer' + string(10b) + 'Exiting...', title='GTB startup check:',/ error)
      exit
    ENDIF
    ;; test for gdal installation
    osxgdal = file_test('/Library/Frameworks/GDAL.framework/Versions/Current', /Directory)
    IF osxgdal eq 0 THEN BEGIN
      st = "IMPORTANT: GDAL libraries are required but were NOT found. " + $
        string(10b) + "Please install the latest package: GDAL Complete" + $
        string(10b) + "available at the following URL:" + $
        string(10b) + "https://www.kyngchaos.com/software/frameworks" + $
        string(10b) + "  " + $
        string(10b) + "GuidosToolbox will now exit."
      res = dialog_message(st, title='GTB startup check:',/ error)
      spawn, 'open https://www.kyngchaos.com/software/frameworks'
      exit
    ENDIF

    ;; maximum image size for MSPA
    ;; use command "vm_stat" and get amounts for
    ;; TOTAL = FREE_BLOCKS + INACTIVE_BLOCKS + SPECULATIVE_BLOCKS + PURGEABLE
    ;; see http://apple.stackexchange.com/questions/4286/is-there-a-mac-os-x-terminal-version-of-the-free-command-in-linux-systems
    spawn, "vm_stat | grep free | awk '{ print $3 }' | sed 's/\.//'",fra & fra=float(fra[0])
      spawn,"vm_stat | grep inactive | awk '{ print $3 }' | sed 's/\.//'", frb & frb=float(frb[0])
      spawn,"vm_stat | grep speculative | awk '{ print $3 }' | sed 's/\.//'", frc & frc=float(frc[0])
      spawn,"vm_stat | grep purgeable | awk '{ print $3 }' | sed 's/\.//'",frd & frd=float(frd[0])
      mbavail = (fra+frb+frc+frd)*4096/1048576
    immaxsize = uint(mbavail/19)
    fn = dir_guidossub + 'mspa_mac'
    file_copy, dir_guidos + 'MSPAstandalone/mspa_mac', fn, / overwrite
    dir_fwtools = '/Library/Frameworks/GDAL.framework/Programs/'
    ;; check for osx first start
    fn = dir_guidossub + 'firststart.txt'
    if file_test(fn) then begin
      ;; we are in save_add
      spawn, '../../../../../mkShortcuts'
      spawn, 'open ../../../../../quickstart.rtf'
      file_delete, fn
    endif

    ;; find out if nolimits is set
    res = file_info('../../../../../data/nolimits.txt') & res = res.exists
    IF res EQ 1b THEN immaxsizeg = 1.0e12
    EULA = dir_guidos + '../../../../../EULA_GTB.pdf'
  END

ENDCASE


;; OS-X/Linux post startup test
;;==============================
;; check and exit if run as root
IF my_os NE 'windows' THEN BEGIN
  spawn, 'whoami 2>/dev/null', res & res = res[0]
  IF res EQ 'root' THEN BEGIN
    msg = "We don't want to run as root, right?" + string(10b) + 'Terminating...'
    res = dialog_message(msg, title='GTB startup check:',/ error)
    exit
  ENDIF
ENDIF

;;  write-permission post startup test
;;==============================
IF file_test('guidos_progs', / write) NE 1 THEN BEGIN
  msg = 'Please install GuidosToolbox in a directory ' + string(10b) + $
    'where you have execute-permissions.' + string(10b) + 'Returning...'
  res = dialog_message(msg,title='GTB startup check:', / error)
  exit
ENDIF

;;=======================================================================
;;=======================================================================
;; Realize the widget hierarchy.
Widget_Control, TLB, / Realize
;;=======================================================================
;;=======================================================================

;; set the initial processed image to the original image
image0 = welcome
process = image0
data_min = 0b & data_max = 2b

;; Get the window index number of the draw widget window. Make it active.
Widget_Control, w_draw, Get_Value = draw_ID
WSet, draw_ID

;; Draw the graphic display.
Guidos_Image, process, 1


;; Create a pixmap window the same size as the draw widget window.
;; Store its window index number in a local variable. Display the
;; image you just put in the draw widget in the pixmap window.
Window, / Free, XSize = screen_size(0), YSize = screen_size(1), / Pixmap
pix_ID = !D.Window & wset, pix_ID
Guidos_Image, process, 1

;;=========================================================
;; default settings in left panel
;;=========================================================
;; exclusive button list:  set the first option (0)  on
ctbl = - 1 & disp_colors_id = 5 
widget_control, w_disp_colors, set_combobox_select = disp_colors_id
prev_disp_colors_id = disp_colors_id
widget_control, zoomfactor, set_combobox_select = 2

mspa_param1_id = 1b
widget_control, w_mspa_param1, set_value = mspa_param1_id
widget_control, w_mspa_param2, set_combobox_select = 1
mspa_param3_id = 1b
widget_control, w_mspa_param3, set_value = mspa_param3_id
mspa_param4_id = 1b
widget_control, w_mspa_param4, set_value = mspa_param4_id
do_mspa_stats_id = 0b
widget_control, w_do_mspa_stats, set_value = do_mspa_stats_id
do_label_groups_id = 0b
widget_control, w_do_label_groups, set_value = do_label_groups_id
widget_control, w_label_t1, set_combobox_select = 1
widget_control, w_label_t2, set_combobox_select = 1

disp_range_id = 0 & prev_disp_range_id = disp_range_id
widget_control, w_disp_range, set_value = disp_range_id

selsubregion_id = 0
widget_control, w_selsubregion, set_value = 'Zoom Mode'

autostretch_id = 0b & prev_autostretch_id = autostretch_id
widget_control, w_autostretch, sensitive = 0, set_value = autostretch_id

;; center the tlb on screen
centertlb, tlb
;; set the rubberband box color
boxcolor = !d.n_colors - 1

;; test for running IDL runtime
;; we should not use several instances of GTB because they may mix up the
;; intermediate files in mspatmp and result in crashes
CASE my_OS OF
  'apple': BEGIN
    spawn,'ps -ef|grep -c guidostoolbox.sav',res & ct = fix(res[0])
    if ct gt 4 then begin
      res = dialog_message('Existing IDL runtime process detected.' + string(10b) + $
        'Running more than 1 instance of GuidosToolbox' + string(10b) + $
        'from the SAME GuidosToolbox directory' + string(10b) + $
        'may result in program crashes or incorrect results.', title='GTB startup check:' )
    endif    
  END
  'linux': BEGIN
    spawn,'unset LD_LIBRARY_PATH; ps -ef|grep -c guidostoolbox.sav',res & ct = fix(res[0])
    if ct gt 3 then begin
      res = dialog_message('Existing IDL runtime process detected.' + string(10b) + $
        'Running more than 1 instance of GuidosToolbox' + string(10b) + $
        'from the SAME GuidosToolbox directory' + string(10b) + $
        'may result in program crashes or incorrect results.', title='GTB startup check:' )
    endif
  END
  'windows': BEGIN
    spawn,'tasklist',res,/hide & res = strmid(res,0,9) & q = where(res eq 'idlrt.exe',ct)
    if ct gt 1 then begin
       res = dialog_message('Existing IDL runtime process detected.' + string(10b) + $
        'Running more than 1 instance of GuidosToolbox' + string(10b) + $
        'from the SAME GuidosToolbox directory' + string(10b) + $
        'may result in program crashes or incorrect results.', title='GTB startup check:' )
    endif
  END
ENDCASE

;; set the default path to the data directory
CASE my_OS OF
  'apple': BEGIN
    pushd, '../../../../../data' & cd, current = datapath & popd
  END
  'linux': BEGIN
    IF isBDAP THEN pushd, 'data' ELSE pushd, '../../data'
    cd, current = datapath & popd
  END
  'windows': BEGIN
    datapath = dir_guidos + 'data' 
  END
ENDCASE
dir_data = datapath + OS_sep  ;; this is the default data directory inside GTB
gtbdd_def = dir_data

;; check if previously defined, then restore that path
dd = dir_guidossub + 'gtbdd.sav'
res = file_info(dd) & res = res.exists
IF res EQ 0 THEN BEGIN ;; nothing is defined
  save, dir_data, filename = dd
ENDIF ELSE BEGIN ;; restore a previously defined default data directory and check if it still exists
  restore, dd
  res = file_info(dir_data)
  IF res.exists EQ 0b THEN BEGIN
    ;; previously defined datadir no longer exists: restore to default instead
    dir_data = gtbdd_def
    save, dir_data, filename = dd
  ENDIF
ENDELSE
widget_control, tlb, tlb_set_title =  title + ' - Default data directory: ' + dir_data


IF newupdate EQ 1b THEN BEGIN
  res = dialog_message('New program version or revision available!' + string(10b) + string(10b) + $
    'Because support will only be provided on the' + string(10b) + $
    'latest version/revision you should upgrade *NOW*.' + string(10b) + string(10b) + $
    'Please select: Help -> GTB Online -> Check for Updates', title='GTB startup check:',/ information)
ENDIF
IF newGWS EQ 1b THEN BEGIN
  res = dialog_message('New GWS (GTB Workshop) material available!' + string(10b) + string(10b)  + $
    'Please select: Help -> GTB Online -> GWS (GTB Workshop)', title='GTB startup check:',/ information)
ENDIF

wronginput = $
 'Invalid input, returning. Please provide a (pseudo-)' + $
 string(10b) + 'BINARY input mask of the following type: ' + $
 string(10b) + '' + string(10b) + $
 '0b: missing data (optional, e.g., clouds)' + string(10b) + $
 '1b: background (e.g., non-forest' + string(10b) + $
 '2b: foreground (e.g., forest)' + string(10b) + $
 'or click on "Original Image"'

;; empty the temporary files from the initial installation script
res = file_test(dir_tmp, /directory, /write)
if res eq 0 then file_mkdir, dir_tmp
pushd, dir_tmp
list = file_search() & nl = n_elements(list)
if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
popd
res = file_test(dir_tmp2, /directory, /write)
if res eq 0 then file_mkdir, dir_tmp2
pushd, dir_tmp2
list = file_search() & nl = n_elements(list)
if list[0] ne '' then for i = 0, nl -1 do file_delete, list[i] ,/ allow_nonexistent, / quiet, / recursive
popd

;; the MSPA class names
mspa_class_int =  strarr(230)
mspa_class_int(0) = 'BACKGROUND'
mspa_class_int(220) = 'BORDER-Opening'
mspa_class_int(100) = 'CORE-Opening'
mspa_class_int(129) = 'MISSING'
mspa_class_int(1) = 'BRANCH (external)'
mspa_class_int(101) = 'BRANCH (internal)'
mspa_class_int(37) = 'BRIDGE in PERFORATION'
mspa_class_int(137) = 'BRIDGE in PERFORATION'
mspa_class_int(35) = 'BRIDGE in EDGE (external)'
mspa_class_int(135) = 'BRIDGE in EDGE (internal)'
mspa_class_int(33) = 'BRIDGE (external)'
mspa_class_int(133) = 'BRIDGE (internal)'
mspa_class_int(69) = 'LOOP in PERFORATION'
mspa_class_int(169) = 'LOOP in PERFORATION'
mspa_class_int(67) = 'LOOP in EDGE (external)'
mspa_class_int(167) = 'LOOP in EDGE (internal)'
mspa_class_int(65) = 'LOOP (external)'
mspa_class_int(165) = 'LOOP (internal)'
mspa_class_int(3) = 'EDGE (external)'
mspa_class_int(103) = 'EDGE (internal)'
mspa_class_int(5) = 'PERFORATION'
mspa_class_int(105) = 'PERFORATION'
mspa_class_int(9) = 'ISLET (external)'
mspa_class_int(109) = 'ISLET (internal)'
mspa_class_int(16) = 'CORE (small, external)'
mspa_class_int(116) = 'CORE (small, internal)'
mspa_class_int(17) = 'CORE (medium, external)'
mspa_class_int(117) = 'CORE (medium, internal)'
mspa_class_int(18) = 'CORE (large, external)'
mspa_class_int(118) = 'CORE (large, internal)'

mspa_class_ext = strarr(230)
mspa_class_ext(0) = 'BACKGROUND'
mspa_class_ext(220) = 'OPENING'
mspa_class_ext(129) = 'MISSING'
mspa_class_ext(1) = 'BRANCH'
mspa_class_ext(37) = 'BRIDGE in PERFORATION'
mspa_class_ext(35) = 'BRIDGE in EDGE'
mspa_class_ext(33) = 'BRIDGE'
mspa_class_ext(69) = 'LOOP in PERFORATION'
mspa_class_ext(67) = 'LOOP in EDGE'
mspa_class_ext(65) = 'LOOP'
mspa_class_ext(3) = 'EDGE'
mspa_class_ext(5) = 'PERFORATION'
mspa_class_ext(9) = 'ISLET'
mspa_class_ext(16) = 'CORE (small)'
mspa_class_ext(17) = 'CORE (medium)'
mspa_class_ext(18) = 'CORE (large)'
             
;; set maximum image size allowed to load into Guidos GUI: 31600 x 31600 pixels
;; note: this is NOT the maximum size for MSPA-processing, the parameter for that is: immaxsize       
if immaxsizeg eq -1 then immaxsizeg = 1.0e9 ;if not specified use the default value 
resfloat = 1    ;; use float calculation in spatcon


;; Create the info structure with the information required to run the
;; program.
info = { image0:Ptr_New(image0), $    ;; A pointer to the original image.
         contort:Ptr_New(image0), $
         cs22_conn:Ptr_New(image0), $
         cs22_nodes:Ptr_New(image0), $
         data_min:Ptr_New(data_min), $      ;; minimum data range
         data_max:Ptr_New(data_max), $    ;; maximum data range
         extra:Ptr_New(extra), $  ;; A pointer to "extra" keywords.
         fr_image:Ptr_New(image0), $  ;; ptr2 fullres image
         fr_undo:Ptr_New(image0), $  ;; pointer to the last fr image
         geotiffinfo:Ptr_New(0b), $
         morphdist:Ptr_New(image0), $
         nw_ids:Ptr_New(image0), $ ;; the network ids (inw+icore)
         nw_conns:Ptr_New(image0), $ ;; component connectors
         nw_hnw:Ptr_New(0l), $ ;; histogram of nw_ids
         nw_hnwb:Ptr_New(0l), $ ;; histogram of nw_ids
         orig_image:Ptr_New(image0), $  ;; ptr2 original fullres image
         prezoomprocess:Ptr_New(image0), $ ;; ptr2 proc image before zoom
         process:Ptr_New(image0), $  ;; A pointer to the process image.
         subimage:Ptr_New(image0), $ ;; The scaled and resized subimage.
         undo:Ptr_New(image0), $  ;; pointer to the last processed image
         mscale:Ptr_New(90b), $ ;; pointer for multiscale analysis
         undo_data_min:Ptr_New(data_min), $
         undo_data_max:Ptr_New(data_max), $
         costrange:intarr(6), $
         cursor:'help', $  ;; default cursor theme in viewport
         def_marker:0, $  ;; index to define if we set up a marker image
         orig_image_title:'', $
         immaxsize:immaxsize, $  ;; maximum for MSPA
         immaxsizeg:immaxsizeg, $  ;; maximum for Guidos
         dtypes:dtypes, $       ;; possible data types
         datatype:datatype, $   ;; type of the input data
         datalayers:datalayers, $  ;; number of layers
         undo_datatype:'', $
         fname_input:'', $  ;; initial full path to input file
         epsgname:'', $  ;; epsg projection name
         epsg:'', $  ;; epsg code number
         add_title:'', $     ;; add on title in main GUI
         prev_add_title:'', $     ;; add on title in main GUI
         resfac:1, $      ;; rescale factor for display of large images
         bigim:0, $        ;; switch for large images
         w_undo:w_undo, $         ;; The identifier of the UNDO button.
         dir_guidos:dir_guidos, $       ;; dir of the GUIDOS program
         dir_data:dir_data, $       ;; directory to read data from
         gtbdd_def:gtbdd_def, $             ;; default GTB data directory
         dir_guidossub:dir_guidossub, $   ;; directory of GUIDOS subroutines
         dir_tmp:dir_tmp, $         ;; directory of temp. processing
         dir_tmp2:dir_tmp2, $         ;; second directory of temp. processing
         dir_fwtools:dir_fwtools, $  ;; directory of GTBtools/FWTools
         windrive:windrive, $     ;; drive letter on MS-Windows where GTB is running
         screen_size:screen_size, $      ;; screen size dimensions
         title:title, $                  ;; The window title.
         OS_sep:OS_sep, $                ;; OS filepath delimiter
         my_os:my_os, $        ;; the used operating system
         sysarch:sysarch, $        ;; the system architecture
         w_help:w_help, $
         w_file:w_file, $
         w_file_save:w_file_save, $
         w_save_kml:w_save_kml, $  ;; the save as kml menu entry
         w_pa_morph:w_pa_morph, $  ;; the mspa menu entry
         w_batch:w_batch, $
         w_mspa_param1:w_mspa_param1, $
         w_mspa_param2:w_mspa_param2, $
         w_mspa_param3:w_mspa_param3, $
         w_mspa_param4:w_mspa_param4, $
         w_pa_connectivity1:w_pa_connectivity1, $
         w_pa_connectivity2:w_pa_connectivity2, $
         w_pa_connectivity20:w_pa_connectivity20, $
         w_pa_connectivity3:w_pa_connectivity3, $
         w_sgeotiff:w_sgeotiff, $
         small_lt_old:-1,$
         allcomp:ulong64(0), $
         mspa_param1_id:mspa_param1_id, $
         mspa_size_current:'1', $
         mspa_size_old:'1',  $
         mspa_param3_id:mspa_param3_id, $
         mspa_param4_id:mspa_param4_id, $
         w_do_mspa_stats:w_do_mspa_stats, $
         do_mspa_stats_id:do_mspa_stats_id, $
         w_mspa_stats:w_mspa_stats, $
         w_do_label_groups:w_do_label_groups, $
         do_label_groups_id:do_label_groups_id, $
         mspa_stats_show:0, $
         mspa_class_ext:mspa_class_ext, $  ;; class names for MSPA
         mspa_class_int:mspa_class_int, $
         is_mspa:0, $          ;; indicator if mspa is active or not
         is_fragm:0, $          ;; indicator if fragmentation is active or not
         is_contort:0, $          ;; indicator if contortion is active or not
         is_cost:0, $          ;; indicator if cost analysis is active or not
         is_nw:0, $          ;; indicator if network analysis is active or not
         is_nwconnect:0, $  ;; indicator if comp-connectors is active or not
         is_cs22:0, $          ;; indicator if cs22 is active or not
         is_dist:0, $          ;; indicator if dist is active or not
         is_influ:0, $          ;; indicator if influence zones is active or not
         cs22_nr_core:0l, $  ;; number of core objects for cs22
         cs22_mx_core:0.0, $  ;; max connectivity value of core
         cs22_mx_bridge:0.0, $  ;; max connectivity value of bridge
         nw_mxinw:0, $  ;; max of networks in network analysis
         w_c2b:w_c2b, $  ;; convert2byte menu-option
         w_c2i:w_c2i, $  ;; convert2integer menu-option
         w_c2l:w_c2l, $  ;; convert2long menu-option
         w_c2s:w_c2s, $  ;; RGB2singleband menu-option
         w_c2ge:w_c2ge, $  ;; reproject to 4326 menu-option
         w_recode:w_recode, $  ;; Recode menu-option
         w_disp_colors:w_disp_colors, $
         disp_colors_id:disp_colors_id, $ ;; the initial colortable
         w_disp_range:w_disp_range, $
         disp_range_id:disp_range_id, $
         w_selsubregion:w_selsubregion, $
         selsubregion_id:selsubregion_id, $  ;; select subregion switch
         w_autostretch:w_autostretch, $
         autostretch_id:autostretch_id, $    ;; autostretch image values
         ctbl:ctbl, $             ;; the color table index (-1 mspa)
         colorId:colorId, $       ;; The drawing color index.
         xs:0l, $                  ;; X static corner of the zoom box.
         ys:0l, $                  ;; Y static corner of the zoom box.
         xd:0l, $                  ;; X dynamic corner of the zoom box.
         yd:0l, $                  ;; Y dynamic corner of the zoom box.
         pix_ID:pix_ID, $         ;; The pixmap window index number.
         xsize:xsize, $                  ;; xsize of graphics window
         ysize:ysize, $                  ;; ysize of graphics window
         w_tools:w_tools, $
         w_pa:w_pa, $
         w_lp11:w_lp11, $  ;; left panel widget 1: Display attributes
         w_lp12:w_lp12, $     ;; left panel widget 2: MSPA attributes
         w_label:w_label, $     ;; left panel widget 2: core groups 
         w_labelstr:w_labelstr, $
         w_labelstr1:w_labelstr1, $
         w_labelstr2:w_labelstr2, $
         w_labelstr3:w_labelstr3, $
         w_lp1222:w_lp1222, $     ;; left panel widget 2: MSPA statistics
         w_label_t1:w_label_t1, $
         w_label_t2:w_label_t2, $
         w_iminfo:w_iminfo, $
         w_iminfo2:w_iminfo2, $
         label_t1:1000ul, $
         label_t2:4600ul, $
         w_zoomfac:w_zoomfac, $
         zoomfactor:4, $                 ;; The initial zoom factor.
         set_zoom:0, $  ;; switch when defining the su-region in zoom mode
         interp:interp, $ ;; flag 2 select near. neighbor bil. resampling
         boxcolor:boxcolor, $            ;; rubberband color index
         w_drawbase:w_drawbase, $
         w_draw:w_draw, $     ;; The identifier of the draw widget.
         draw_ID:draw_ID, $   ;; window index # of graphics window.
         w_rdpx:w_rdpx, $    ;; the pixel information below the draw widget
         scroll_x:0l, $  ;; x-position of scroll in enlarged view
         scroll_y:0l, $  ;; x-position of scroll in enlarged view
         xpos:0l, $
         ypos:0l, $
         x:[0l, 0l], $
         y:[0l, 0l], $
         TLB:TLB, $            ;; TLB identifier.
         fullres:0, $         ;; full resolution image indicator
         wronginput:wronginput, $
         sysgdal:sysgdal, $
         linterm:linterm, $
         fmanager:fmanager, $
         resfloat:resfloat, $
         html_exe:html_exe, $
         acroread_exe:acroread_exe, $
         qgis_exe:qgis_exe, $
         xdgop:xdgop, $
         recline:0, $
         w_ZoomTLB:0l, $ ;; zoom TLB & stuff below to be initialized now
         zoomDraw_ID:0l, $      ;; for later use in 'zoom_window'
         is_geotiff:0b, $    ;; initialize geotiff=no
         gtb_version:gtb_version, $
         proxhost:proxhost, $
         proxport:proxport, $
         isBDAP:isBDAP, $
         prev_disp_colors_id:prev_disp_colors_id, $
         prev_disp_range_id:prev_disp_range_id, $
         prev_autostretch_id:prev_autostretch_id, $
         prev_r:prev_r, $
         prev_g:prev_g, $
         prev_b:prev_b, $
         prev_is_mspa:0, $
         prev_is_fragm:0, $
         prev_is_contort:0, $
         prev_is_dist:0, $
         prev_is_influ:0, $
         prev_is_cs22:0, $
         prev_is_cost:0, $
         prev_is_nw:0, $
         prev_is_nwconnect:0, $
         app_dtype:'', $
         xstart:-1, $          ; The starting X coordinate of the free-hand line.
         ystart:-1, $          ; The starting Y coordinate of the free-hand line.
         xvalues:Ptr_New(), $  ; The X coordinates of the free-hand line.
         yvalues:Ptr_New(), $  ; The Y coordinates of the free-hand line.
         xvalues2:Ptr_New(), $  ; The X coordinates of the free-hand line.
         yvalues2:Ptr_New(), $  ; The Y coordinates of the free-hand line.
         buttonUsed:'NONE', $
         w_save:0l }

;; Store the info structure in the user value of the TLB.
Widget_Control, TLB, Set_UValue = info, / No_Copy
close, /all
;; Set up the event loop. Register the program with the window manager.
XManager, 'guidostoolbox', TLB,  Event_Handler = 'guidos_TLB_EVENTS',$
 / No_Block, Cleanup = 'guidos_Cleanup', Group_Leader = group
 

END ;; of 'guidostoolbox'
;;=======================================================================
;;=======================================================================
;;;;        E N D   O F    M A I N   G U I   S E T U P
;;=======================================================================
;;=======================================================================
